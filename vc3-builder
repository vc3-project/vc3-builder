#! /usr/bin/env perl
#
# This is an automatically generated file. Do not modify! All changes
# should go into vc3-builder-bare and the modules in VC3.
#
# Copyright (C) 2016- The University of Notre Dame
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.
# 

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CWD';
  package Cwd;
  use strict;
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  
  $VERSION = '3.62';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//d;
  
  @ISA = qw/ Exporter /;
  @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  if(! defined &getcwd && defined &DynaLoader::boot_DynaLoader) {
    eval {#eval is questionable since we are handling potential errors like
          #"Cwd object version 3.48 does not match bootstrap parameter 3.50
          #at lib/DynaLoader.pm line 216." by having this eval
      if ( $] >= 5.006 ) {
        require XSLoader;
        XSLoader::load( __PACKAGE__, $xs_version);
      } else {
        require DynaLoader;
        push @ISA, 'DynaLoader';
        __PACKAGE__->bootstrap( $xs_version );
      }
    };
  }
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     epoc =>
     {
      cwd			=> '_epoc_cwd',
      getcwd	        => '_epoc_cwd',
      fastgetcwd		=> '_epoc_cwd',
      fastcwd		=> '_epoc_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     MacOS =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     amigaos =>
     {
      getcwd              => '_backtick_pwd',
      fastgetcwd          => '_backtick_pwd',
      fastcwd             => '_backtick_pwd',
      abs_path            => 'fast_abs_path',
     }
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  if($^O ne 'MSWin32') {
      foreach my $try ('/bin/pwd',
  		     '/usr/bin/pwd',
  		     '/QOpenSys/bin/pwd', # OS/400 PASE.
  		    ) {
  	if( -x $try ) {
  	    $pwd_cmd = $try;
  	    last;
  	}
      }
  }
  
  # Android has a built-in pwd. Using $pwd_cmd will DTRT if
  # this perl was compiled with -Dd_useshellcmds, which is the
  # default for Android, but the block below is needed for the
  # miniperl running on the host when cross-compiling, and
  # potentially for native builds with -Ud_useshellcmds.
  if ($^O =~ /android/) {
      # If targetsh is executable, then we're either a full
      # perl, or a miniperl for a native build.
      if (-x $Config::Config{targetsh}) {
          $pwd_cmd = "$Config::Config{targetsh} -c pwd"
      }
      else {
          my $sh = $Config::Config{sh} || (-x '/system/bin/sh' ? '/system/bin/sh' : 'sh');
          $pwd_cmd = "$sh -c pwd"
      }
  }
  
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if someone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
  
      # Localize %ENV entries in a way that won't create new hash keys.
      # Under AmigaOS we don't want to localize as it stops perl from
      # finding 'sh' in the PATH.
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV) if $^O ne "amigaos";
      local @ENV{@localize} if @localize;
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      # MacOS has some special magic to make `pwd` work.
      if( $os eq 'MacOS' || $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      if ($^O eq "cygwin") {
        $newdir =~ s|\A///+|//|;
        $newdir =~ s|(?<=[^/])//+|/|g;
      }
      elsif ($^O ne 'MSWin32') {
        $newdir =~ s|///*|/|g;
      }
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MacOS') {
  	return $ENV{'PWD'} = cwd();
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	_carp("stat($start): $!");
  	return '';
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    # probably a permissions issue.  Try the native command.
  	    require File::Spec;
  	    return File::Spec->rel2abs( $start, _backtick_pwd() );
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    _carp("stat($dotdots): $!");
  	    closedir(PARENT);
  	    return '';
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    _carp("readdir($dotdots): $!");
  		    closedir(PARENT);
  		    return '';
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/s;
      ($cwd)  = $cwd  =~ /(.*)/s;
  
      unless (-e $path) {
   	_croak("$path: No such file or directory");
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    die "Can't resolve link $path: $!" unless defined $link_target;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
   	_croak("Cannot chdir to $path: $!");
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      my $pwd = `cmd /c cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd_simple {
      my $pwd = `cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd {
      my $pwd;
      $pwd = Win32::GetCwd();
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
  
  sub _dos_cwd {
      my $pwd;
      if (!defined &Dos::GetCwd) {
          chomp($pwd = `command /c cd`);
          $pwd =~ s:\\:/:g ;
      } else {
          $pwd = Dos::GetCwd();
      }
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $pwd = `/usr/bin/fullpath -t`;
      chomp $pwd;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  sub _epoc_cwd {
      return $ENV{'PWD'} = EPOC::getcwd();
  }
  
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
  __END__
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture.  For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in.  If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly".  That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path separators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`.  Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
CWD

$fatpacked{"Digest/Perl/MD5.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DIGEST_PERL_MD5';
  package Digest::Perl::MD5;
  use strict;
  use integer;
  use Exporter;
  use vars qw($VERSION @ISA @EXPORTER @EXPORT_OK);
  
  @EXPORT_OK = qw(md5 md5_hex md5_base64);
  
  @ISA = 'Exporter';
  $VERSION = '1.9';
  
  # I-Vektor
  sub A() { 0x67_45_23_01 }
  sub B() { 0xef_cd_ab_89 }
  sub C() { 0x98_ba_dc_fe }
  sub D() { 0x10_32_54_76 }
  
  # for internal use
  sub MAX() { 0xFFFFFFFF }
  
  # pad a message to a multiple of 64
  sub padding {
      my $l = length (my $msg = shift() . chr(128));    
      $msg .= "\0" x (($l%64<=56?56:120)-$l%64);
      $l = ($l-1)*8;
      $msg .= pack 'VV', $l & MAX , ($l >> 16 >> 16);
  }
  
  
  sub rotate_left($$) {
  	#$_[0] << $_[1] | $_[0] >> (32 - $_[1]);
  	#my $right = $_[0] >> (32 - $_[1]);
  	#my $rmask = (1 << $_[1]) - 1;
  	($_[0] << $_[1]) | (( $_[0] >> (32 - $_[1])  )  & ((1 << $_[1]) - 1));
  	#$_[0] << $_[1] | (($_[0]>> (32 - $_[1])) & (1 << (32 - $_[1])) - 1);
  }
  
  sub gen_code {
    # Discard upper 32 bits on 64 bit archs.
    my $MSK = ((1 << 16) << 16) ? ' & ' . MAX : '';
  #	FF => "X0=rotate_left(((X1&X2)|(~X1&X3))+X0+X4+X6$MSK,X5)+X1$MSK;",
  #	GG => "X0=rotate_left(((X1&X3)|(X2&(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
    my %f = (
  	FF => "X0=rotate_left((X3^(X1&(X2^X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
  	GG => "X0=rotate_left((X2^(X3&(X1^X2)))+X0+X4+X6$MSK,X5)+X1$MSK;",
  	HH => "X0=rotate_left((X1^X2^X3)+X0+X4+X6$MSK,X5)+X1$MSK;",
  	II => "X0=rotate_left((X2^(X1|(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;",
    );
    #unless ( (1 << 16) << 16) { %f = %{$CODES{'32bit'}} }
    #else { %f = %{$CODES{'64bit'}} }
  
    my %s = (  # shift lengths
  	S11 => 7, S12 => 12, S13 => 17, S14 => 22, S21 => 5, S22 => 9, S23 => 14,
  	S24 => 20, S31 => 4, S32 => 11, S33 => 16, S34 => 23, S41 => 6, S42 => 10,
  	S43 => 15, S44 => 21
    );
  
    my $insert = "\n";
    while(defined( my $data = <DATA> )) {
  	chomp $data;
  	next unless $data =~ /^[FGHI]/;
  	my ($func,@x) = split /,/, $data;
  	my $c = $f{$func};
  	$c =~ s/X(\d)/$x[$1]/g;
  	$c =~ s/(S\d{2})/$s{$1}/;
  	$c =~ s/^(.*)=rotate_left\((.*),(.*)\)\+(.*)$//;
  
  	my $su = 32 - $3;
  	my $sh = (1 << $3) - 1;
  
  	$c = "$1=(((\$r=$2)<<$3)|((\$r>>$su)&$sh))+$4";
  
  	#my $rotate = "(($2 << $3) || (($2 >> (32 - $3)) & (1 << $2) - 1)))"; 
  	# $c = "\$r = $2;
  	# $1 = ((\$r << $3) | ((\$r >> (32 - $3))  & ((1 << $3) - 1))) + $4";
  	$insert .= "\t$c\n";
    }
    close DATA;
    
    my $dump = '
    sub round {
  	my ($a,$b,$c,$d) = @_[0 .. 3];
  	my $r;' . $insert . '
  	$_[0]+$a' . $MSK . ', $_[1]+$b ' . $MSK . 
          ', $_[2]+$c' . $MSK . ', $_[3]+$d' . $MSK . ';
    }';
    eval $dump;
    # print "$dump\n";
    # exit 0;
  }
  
  gen_code();
  
  #########################################
  # Private output converter functions:
  sub _encode_hex { unpack 'H*', $_[0] }
  sub _encode_base64 {
  	my $res;
  	while ($_[0] =~ /(.{1,45})/gs) {
  		$res .= substr pack('u', $1), 1;
  		chop $res;
  	}
  	$res =~ tr|` -_|AA-Za-z0-9+/|;#`
  	chop $res; chop $res;
  	$res
  }
  
  #########################################
  # OOP interface:
  sub new {
  	my $proto = shift;
  	my $class = ref $proto || $proto;
  	my $self = {};
  	bless $self, $class;
  	$self->reset();
  	$self
  }
  
  sub reset {
  	my $self = shift;
  	delete $self->{_data};
  	$self->{_state} = [A,B,C,D];
  	$self->{_length} = 0;
  	$self
  }
  
  sub add {
  	my $self = shift;
  	$self->{_data} .= join '', @_ if @_;
  	my ($i,$c);
  	for $i (0 .. (length $self->{_data})/64-1) {
  		my @X = unpack 'V16', substr $self->{_data}, $i*64, 64;
  		@{$self->{_state}} = round(@{$self->{_state}},@X);
  		++$c;
  	}
  	if ($c) {
  		substr ($self->{_data}, 0, $c*64) = '';
  		$self->{_length} += $c*64;
  	}
  	$self
  }
  
  sub finalize {
  	my $self = shift;
  	$self->{_data} .= chr(128);
      my $l = $self->{_length} + length $self->{_data};
      $self->{_data} .= "\0" x (($l%64<=56?56:120)-$l%64);
      $l = ($l-1)*8;
      $self->{_data} .= pack 'VV', $l & MAX , ($l >> 16 >> 16);
  	$self->add();
  	$self
  }
  
  sub addfile {
    	my ($self,$fh) = @_;
  	if (!ref($fh) && ref(\$fh) ne "GLOB") {
  	    require Symbol;
  	    $fh = Symbol::qualify($fh, scalar caller);
  	}
  	# $self->{_data} .= do{local$/;<$fh>};
  	my $read = 0;
  	my $buffer = '';
  	$self->add($buffer) while $read = read $fh, $buffer, 8192;
  	die __PACKAGE__, " read failed: $!" unless defined $read;
  	$self
  }
  
  sub add_bits {
  	my $self = shift;
  	return $self->add( pack 'B*', shift ) if @_ == 1;
  	my ($b,$n) = @_;
  	die __PACKAGE__, " Invalid number of bits\n" if $n%8;
  	$self->add( substr $b, 0, $n/8 )
  }
  
  sub digest {
  	my $self = shift;
  	$self->finalize();
  	my $res = pack 'V4', @{$self->{_state}};
  	$self->reset();
  	$res
  }
  
  sub hexdigest {
  	_encode_hex($_[0]->digest)
  }
  
  sub b64digest {
  	_encode_base64($_[0]->digest)
  }
  
  sub clone {
  	my $self = shift;
  	my $clone = { 
  		_state => [@{$self->{_state}}],
  		_length => $self->{_length},
  		_data => $self->{_data}
  	};
  	bless $clone, ref $self || $self;
  }
  
  #########################################
  # Procedural interface:
  sub md5 {
  	my $message = padding(join'',@_);
  	my ($a,$b,$c,$d) = (A,B,C,D);
  	my $i;
  	for $i (0 .. (length $message)/64-1) {
  		my @X = unpack 'V16', substr $message,$i*64,64;	
  		($a,$b,$c,$d) = round($a,$b,$c,$d,@X);
  	}
  	pack 'V4',$a,$b,$c,$d;
  }
  sub md5_hex { _encode_hex &md5 } 
  sub md5_base64 { _encode_base64 &md5 }
  
  
  1;
  
  =head1 NAME
  
  Digest::MD5::Perl - Perl implementation of Ron Rivests MD5 Algorithm
  
  =head1 DISCLAIMER
  
  This is B<not> an interface (like C<Digest::MD5>) but a Perl implementation of MD5.
  It is written in perl only and because of this it is slow but it works without C-Code.
  You should use C<Digest::MD5> instead of this module if it is available.
  This module is only useful for
  
  =over 4
  
  =item
  
  computers where you cannot install C<Digest::MD5> (e.g. lack of a C-Compiler)
  
  =item
  
  encrypting only small amounts of data (less than one million bytes). I use it to
  hash passwords.
  
  =item
  
  educational purposes
  
  =back
  
  =head1 SYNOPSIS
  
   # Functional style
   use Digest::MD5  qw(md5 md5_hex md5_base64);
  
   $hash = md5 $data;
   $hash = md5_hex $data;
   $hash = md5_base64 $data;
      
  
   # OO style
   use Digest::MD5;
  
   $ctx = Digest::MD5->new;
  
   $ctx->add($data);
   $ctx->addfile(*FILE);
  
   $digest = $ctx->digest;
   $digest = $ctx->hexdigest;
   $digest = $ctx->b64digest;
  
  =head1 DESCRIPTION
  
  This modules has the same interface as the much faster C<Digest::MD5>. So you can
  easily exchange them, e.g.
  
  	BEGIN {
  	  eval {
  	    require Digest::MD5;
  	    import Digest::MD5 'md5_hex'
  	  };
  	  if ($@) { # ups, no Digest::MD5
  	    require Digest::Perl::MD5;
  	    import Digest::Perl::MD5 'md5_hex'
  	  }		
  	}
  
  If the C<Digest::MD5> module is available it is used and if not you take
  C<Digest::Perl::MD5>.
  
  You can also install the Perl part of Digest::MD5 together with Digest::Perl::MD5
  and use Digest::MD5 as normal, it falls back to Digest::Perl::MD5 if it
  cannot load its object files.
  
  For a detailed Documentation see the C<Digest::MD5> module.
  
  =head1 EXAMPLES
  
  The simplest way to use this library is to import the md5_hex()
  function (or one of its cousins):
  
      use Digest::Perl::MD5 'md5_hex';
      print 'Digest is ', md5_hex('foobarbaz'), "\n";
  
  The above example would print out the message
  
      Digest is 6df23dc03f9b54cc38a0fc1483df6e21
  
  provided that the implementation is working correctly.  The same
  checksum can also be calculated in OO style:
  
      use Digest::MD5;
      
      $md5 = Digest::MD5->new;
      $md5->add('foo', 'bar');
      $md5->add('baz');
      $digest = $md5->hexdigest;
      
      print "Digest is $digest\n";
  
  The digest methods are destructive. That means you can only call them
  once and the $md5 objects is reset after use. You can make a copy with clone:
  
  	$md5->clone->hexdigest
  
  =head1 LIMITATIONS
  
  This implementation of the MD5 algorithm has some limitations:
  
  =over 4
  
  =item
  
  It's slow, very slow. I've done my very best but Digest::MD5 is still about 100 times faster.
  You can only encrypt Data up to one million bytes in an acceptable time. But it's very useful
  for encrypting small amounts of data like passwords.
  
  =item
  
  You can only encrypt up to 2^32 bits = 512 MB on 32bit archs. But You should
  use C<Digest::MD5> for those amounts of data anyway.
  
  =back
  
  =head1 SEE ALSO
  
  L<Digest::MD5>
  
  L<md5(1)>
  
  RFC 1321
  
  tools/md5: a small BSD compatible md5 tool written in pure perl.
  
  =head1 COPYRIGHT
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
   Copyright 2000 Christian Lackas, Imperia Software Solutions
   Copyright 1998-1999 Gisle Aas.
   Copyright 1995-1996 Neil Winton.
   Copyright 1991-1992 RSA Data Security, Inc.
  
  The MD5 algorithm is defined in RFC 1321. The basic C code
  implementing the algorithm is derived from that in the RFC and is
  covered by the following copyright:
  
  =over 4
  
  =item
  
  Copyright (C) 1991-1992, RSA Data Security, Inc. Created 1991. All
  rights reserved.
  
  License to copy and use this software is granted provided that it
  is identified as the "RSA Data Security, Inc. MD5 Message-Digest
  Algorithm" in all material mentioning or referencing this software
  or this function.
  
  License is also granted to make and use derivative works provided
  that such works are identified as "derived from the RSA Data
  Security, Inc. MD5 Message-Digest Algorithm" in all material
  mentioning or referencing the derived work.
  
  RSA Data Security, Inc. makes no representations concerning either
  the merchantability of this software or the suitability of this
  software for any particular purpose. It is provided "as is"
  without express or implied warranty of any kind.
  
  These notices must be retained in any copies of any part of this
  documentation and/or software.
  
  =back
  
  This copyright does not prohibit distribution of any version of Perl
  containing this extension under the terms of the GNU or Artistic
  licenses.
  
  =head1 AUTHORS
  
  The original MD5 interface was written by Neil Winton
  (<N.Winton (at) axion.bt.co.uk>).
  
  C<Digest::MD5> was made by Gisle Aas <gisle (at) aas.no> (I took his Interface
  and part of the documentation).
  
  Thanks to Guido Flohr for his 'use integer'-hint.
  
  This release was made by Christian Lackas <delta (at) lackas.net>.
  
  =cut
  
  __DATA__
  FF,$a,$b,$c,$d,$_[4],7,0xd76aa478,/* 1 */
  FF,$d,$a,$b,$c,$_[5],12,0xe8c7b756,/* 2 */
  FF,$c,$d,$a,$b,$_[6],17,0x242070db,/* 3 */
  FF,$b,$c,$d,$a,$_[7],22,0xc1bdceee,/* 4 */
  FF,$a,$b,$c,$d,$_[8],7,0xf57c0faf,/* 5 */
  FF,$d,$a,$b,$c,$_[9],12,0x4787c62a,/* 6 */
  FF,$c,$d,$a,$b,$_[10],17,0xa8304613,/* 7 */
  FF,$b,$c,$d,$a,$_[11],22,0xfd469501,/* 8 */
  FF,$a,$b,$c,$d,$_[12],7,0x698098d8,/* 9 */
  FF,$d,$a,$b,$c,$_[13],12,0x8b44f7af,/* 10 */
  FF,$c,$d,$a,$b,$_[14],17,0xffff5bb1,/* 11 */
  FF,$b,$c,$d,$a,$_[15],22,0x895cd7be,/* 12 */
  FF,$a,$b,$c,$d,$_[16],7,0x6b901122,/* 13 */
  FF,$d,$a,$b,$c,$_[17],12,0xfd987193,/* 14 */
  FF,$c,$d,$a,$b,$_[18],17,0xa679438e,/* 15 */
  FF,$b,$c,$d,$a,$_[19],22,0x49b40821,/* 16 */ 
  GG,$a,$b,$c,$d,$_[5],5,0xf61e2562,/* 17 */
  GG,$d,$a,$b,$c,$_[10],9,0xc040b340,/* 18 */
  GG,$c,$d,$a,$b,$_[15],14,0x265e5a51,/* 19 */
  GG,$b,$c,$d,$a,$_[4],20,0xe9b6c7aa,/* 20 */
  GG,$a,$b,$c,$d,$_[9],5,0xd62f105d,/* 21 */
  GG,$d,$a,$b,$c,$_[14],9,0x2441453,/* 22 */
  GG,$c,$d,$a,$b,$_[19],14,0xd8a1e681,/* 23 */
  GG,$b,$c,$d,$a,$_[8],20,0xe7d3fbc8,/* 24 */
  GG,$a,$b,$c,$d,$_[13],5,0x21e1cde6,/* 25 */
  GG,$d,$a,$b,$c,$_[18],9,0xc33707d6,/* 26 */
  GG,$c,$d,$a,$b,$_[7],14,0xf4d50d87,/* 27 */
  GG,$b,$c,$d,$a,$_[12],20,0x455a14ed,/* 28 */
  GG,$a,$b,$c,$d,$_[17],5,0xa9e3e905,/* 29 */
  GG,$d,$a,$b,$c,$_[6],9,0xfcefa3f8,/* 30 */
  GG,$c,$d,$a,$b,$_[11],14,0x676f02d9,/* 31 */
  GG,$b,$c,$d,$a,$_[16],20,0x8d2a4c8a,/* 32 */
  HH,$a,$b,$c,$d,$_[9],4,0xfffa3942,/* 33 */
  HH,$d,$a,$b,$c,$_[12],11,0x8771f681,/* 34 */
  HH,$c,$d,$a,$b,$_[15],16,0x6d9d6122,/* 35 */
  HH,$b,$c,$d,$a,$_[18],23,0xfde5380c,/* 36 */
  HH,$a,$b,$c,$d,$_[5],4,0xa4beea44,/* 37 */
  HH,$d,$a,$b,$c,$_[8],11,0x4bdecfa9,/* 38 */
  HH,$c,$d,$a,$b,$_[11],16,0xf6bb4b60,/* 39 */
  HH,$b,$c,$d,$a,$_[14],23,0xbebfbc70,/* 40 */
  HH,$a,$b,$c,$d,$_[17],4,0x289b7ec6,/* 41 */
  HH,$d,$a,$b,$c,$_[4],11,0xeaa127fa,/* 42 */
  HH,$c,$d,$a,$b,$_[7],16,0xd4ef3085,/* 43 */
  HH,$b,$c,$d,$a,$_[10],23,0x4881d05,/* 44 */
  HH,$a,$b,$c,$d,$_[13],4,0xd9d4d039,/* 45 */
  HH,$d,$a,$b,$c,$_[16],11,0xe6db99e5,/* 46 */
  HH,$c,$d,$a,$b,$_[19],16,0x1fa27cf8,/* 47 */
  HH,$b,$c,$d,$a,$_[6],23,0xc4ac5665,/* 48 */
  II,$a,$b,$c,$d,$_[4],6,0xf4292244,/* 49 */
  II,$d,$a,$b,$c,$_[11],10,0x432aff97,/* 50 */
  II,$c,$d,$a,$b,$_[18],15,0xab9423a7,/* 51 */
  II,$b,$c,$d,$a,$_[9],21,0xfc93a039,/* 52 */
  II,$a,$b,$c,$d,$_[16],6,0x655b59c3,/* 53 */
  II,$d,$a,$b,$c,$_[7],10,0x8f0ccc92,/* 54 */
  II,$c,$d,$a,$b,$_[14],15,0xffeff47d,/* 55 */
  II,$b,$c,$d,$a,$_[5],21,0x85845dd1,/* 56 */
  II,$a,$b,$c,$d,$_[12],6,0x6fa87e4f,/* 57 */
  II,$d,$a,$b,$c,$_[19],10,0xfe2ce6e0,/* 58 */
  II,$c,$d,$a,$b,$_[10],15,0xa3014314,/* 59 */
  II,$b,$c,$d,$a,$_[17],21,0x4e0811a1,/* 60 */
  II,$a,$b,$c,$d,$_[8],6,0xf7537e82,/* 61 */
  II,$d,$a,$b,$c,$_[15],10,0xbd3af235,/* 62 */
  II,$c,$d,$a,$b,$_[6],15,0x2ad7d2bb,/* 63 */
  II,$b,$c,$d,$a,$_[13],21,0xeb86d391,/* 64 */
DIGEST_PERL_MD5

$fatpacked{"English.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ENGLISH';
  package English;
  
  our $VERSION = '1.10';
  
  require Exporter;
  @ISA = qw(Exporter);
  
  =head1 NAME
  
  English - use nice English (or awk) names for ugly punctuation variables
  
  =head1 SYNOPSIS
  
      use English;
      use English qw( -no_match_vars ) ;  # Avoids regex performance
                                          # penalty in perl 5.16 and
                                          # earlier
      ...
      if ($ERRNO =~ /denied/) { ... }
  
  =head1 DESCRIPTION
  
  This module provides aliases for the built-in variables whose
  names no one seems to like to read.  Variables with side-effects
  which get triggered just by accessing them (like $0) will still 
  be affected.
  
  For those variables that have an B<awk> version, both long
  and short English alternatives are provided.  For example, 
  the C<$/> variable can be referred to either $RS or 
  $INPUT_RECORD_SEPARATOR if you are using the English module.
  
  See L<perlvar> for a complete list of these.
  
  =head1 PERFORMANCE
  
  NOTE: This was fixed in perl 5.20.  Mentioning these three variables no
  longer makes a speed difference.  This section still applies if your code
  is to run on perl 5.18 or earlier.
  
  This module can provoke sizeable inefficiencies for regular expressions,
  due to unfortunate implementation details.  If performance matters in
  your application and you don't need $PREMATCH, $MATCH, or $POSTMATCH,
  try doing
  
     use English qw( -no_match_vars ) ;
  
  .  B<It is especially important to do this in modules to avoid penalizing
  all applications which use them.>
  
  =cut
  
  no warnings;
  
  my $globbed_match ;
  
  # Grandfather $NAME import
  sub import {
      my $this = shift;
      my @list = grep { ! /^-no_match_vars$/ } @_ ;
      local $Exporter::ExportLevel = 1;
      if ( @_ == @list ) {
          *EXPORT = \@COMPLETE_EXPORT ;
          $globbed_match ||= (
  	    eval q{
  		*MATCH				= *&	;
  		*PREMATCH			= *`	;
  		*POSTMATCH			= *'	;
  		1 ;
  	       }
  	    || do {
  		require Carp ;
  		Carp::croak("Can't create English for match leftovers: $@") ;
  	    }
  	) ;
      }
      else {
          *EXPORT = \@MINIMAL_EXPORT ;
      }
      Exporter::import($this,grep {s/^\$/*/} @list);
  }
  
  @MINIMAL_EXPORT = qw(
  	*ARG
  	*LAST_PAREN_MATCH
  	*INPUT_LINE_NUMBER
  	*NR
  	*INPUT_RECORD_SEPARATOR
  	*RS
  	*OUTPUT_AUTOFLUSH
  	*OUTPUT_FIELD_SEPARATOR
  	*OFS
  	*OUTPUT_RECORD_SEPARATOR
  	*ORS
  	*LIST_SEPARATOR
  	*SUBSCRIPT_SEPARATOR
  	*SUBSEP
  	*FORMAT_PAGE_NUMBER
  	*FORMAT_LINES_PER_PAGE
  	*FORMAT_LINES_LEFT
  	*FORMAT_NAME
  	*FORMAT_TOP_NAME
  	*FORMAT_LINE_BREAK_CHARACTERS
  	*FORMAT_FORMFEED
  	*CHILD_ERROR
  	*OS_ERROR
  	*ERRNO
  	*EXTENDED_OS_ERROR
  	*EVAL_ERROR
  	*PROCESS_ID
  	*PID
  	*REAL_USER_ID
  	*UID
  	*EFFECTIVE_USER_ID
  	*EUID
  	*REAL_GROUP_ID
  	*GID
  	*EFFECTIVE_GROUP_ID
  	*EGID
  	*PROGRAM_NAME
  	*PERL_VERSION
  	*OLD_PERL_VERSION
  	*ACCUMULATOR
  	*COMPILING
  	*DEBUGGING
  	*SYSTEM_FD_MAX
  	*INPLACE_EDIT
  	*PERLDB
  	*BASETIME
  	*WARNING
  	*EXECUTABLE_NAME
  	*OSNAME
  	*LAST_REGEXP_CODE_RESULT
  	*EXCEPTIONS_BEING_CAUGHT
  	*LAST_SUBMATCH_RESULT
  	@LAST_MATCH_START
  	@LAST_MATCH_END
  );
  
  
  @MATCH_EXPORT = qw(
  	*MATCH
  	*PREMATCH
  	*POSTMATCH
  );
  
  @COMPLETE_EXPORT = ( @MINIMAL_EXPORT, @MATCH_EXPORT ) ;
  
  # The ground of all being.
  
  	*ARG					= *_	;
  
  # Matching.
  
  	*LAST_PAREN_MATCH			= *+	;
  	*LAST_SUBMATCH_RESULT			= *^N ;
  	*LAST_MATCH_START			= *-{ARRAY} ;
  	*LAST_MATCH_END				= *+{ARRAY} ;
  
  # Input.
  
  	*INPUT_LINE_NUMBER			= *.	;
  	    *NR					= *.	;
  	*INPUT_RECORD_SEPARATOR			= */	;
  	    *RS					= */	;
  
  # Output.
  
  	*OUTPUT_AUTOFLUSH			= *|	;
  	*OUTPUT_FIELD_SEPARATOR			= *,	;
  	    *OFS				= *,	;
  	*OUTPUT_RECORD_SEPARATOR		= *\	;
  	    *ORS				= *\	;
  
  # Interpolation "constants".
  
  	*LIST_SEPARATOR				= *"	;
  	*SUBSCRIPT_SEPARATOR			= *;	;
  	    *SUBSEP				= *;	;
  
  # Formats
  
  	*FORMAT_PAGE_NUMBER			= *%	;
  	*FORMAT_LINES_PER_PAGE			= *=	;
  	*FORMAT_LINES_LEFT			= *-{SCALAR}	;
  	*FORMAT_NAME				= *~	;
  	*FORMAT_TOP_NAME			= *^	;
  	*FORMAT_LINE_BREAK_CHARACTERS		= *:	;
  	*FORMAT_FORMFEED			= *^L	;
  
  # Error status.
  
  	*CHILD_ERROR				= *?	;
  	*OS_ERROR				= *!	;
  	    *ERRNO				= *!	;
  	*OS_ERROR				= *!	;
  	    *ERRNO				= *!	;
  	*EXTENDED_OS_ERROR			= *^E	;
  	*EVAL_ERROR				= *@	;
  
  # Process info.
  
  	*PROCESS_ID				= *$	;
  	    *PID				= *$	;
  	*REAL_USER_ID				= *<	;
  	    *UID				= *<	;
  	*EFFECTIVE_USER_ID			= *>	;
  	    *EUID				= *>	;
  	*REAL_GROUP_ID				= *(	;
  	    *GID				= *(	;
  	*EFFECTIVE_GROUP_ID			= *)	;
  	    *EGID				= *)	;
  	*PROGRAM_NAME				= *0	;
  
  # Internals.
  
  	*PERL_VERSION				= *^V	;
  	*OLD_PERL_VERSION			= *]	;
  	*ACCUMULATOR				= *^A	;
  	*COMPILING				= *^C	;
  	*DEBUGGING				= *^D	;
  	*SYSTEM_FD_MAX				= *^F	;
  	*INPLACE_EDIT				= *^I	;
  	*PERLDB					= *^P	;
  	*LAST_REGEXP_CODE_RESULT		= *^R	;
  	*EXCEPTIONS_BEING_CAUGHT		= *^S	;
  	*BASETIME				= *^T	;
  	*WARNING				= *^W	;
  	*EXECUTABLE_NAME			= *^X	;
  	*OSNAME					= *^O	;
  
  # Deprecated.
  
  #	*ARRAY_BASE				= *[	;
  #	*OFMT					= *#	;
  
  1;
ENGLISH

$fatpacked{"File/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC';
  package File::Spec;
  
  use strict;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  my %module = (
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin',
  	      amigaos => 'AmigaOS');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  our @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of files in a directory (such as from C<readdir()>),
  strip out C<'.'> and C<'..'>.
  
  B<SECURITY NOTE:> This does NOT filter paths containing C<'..'>, like
  C<'../../../../etc/passwd'>, only literal matches to C<'.'> and C<'..'>.
  
      @paths = File::Spec->no_upwards( readdir $dirhandle );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path );
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2013 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
FILE_SPEC

$fatpacked{"File/Spec/AmigaOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_AMIGAOS';
  package File::Spec::AmigaOS;
  
  use strict;
  require File::Spec::Unix;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::AmigaOS - File::Spec for AmigaOS
  
  =head1 SYNOPSIS
  
   require File::Spec::AmigaOS; # Done automatically by File::Spec
                                # if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item tmpdir
  
  Returns $ENV{TMPDIR} or if that is unset, "/t".
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
    return $tmpdir if defined $tmpdir;
    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/t" );
  }
  
  =item file_name_is_absolute
  
  Returns true if there's a colon in the file name,
  or if it begins with a slash.
  
  =cut
  
  sub file_name_is_absolute {
    my ($self, $file) = @_;
  
    # Not 100% robust as a "/" must not preceded a ":"
    # but this cannot happen in a well formed path.
    return $file =~ m{^/|:}s;
  }
  
  =back
  
  All the other methods are from L<File::Spec::Unix>.
  
  =cut
  
  1;
FILE_SPEC_AMIGAOS

$fatpacked{"File/Spec/Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  require File::Spec::Unix;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TMP TEMP');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir(
          $_[0]->_tmpdir(
              $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp'
          ),
          qw 'TMPDIR TMP TEMP'
      );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval {
        local @INC = @INC;
        pop @INC if $INC[-1] eq '.';
        require Win32API::File;
    } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
FILE_SPEC_CYGWIN

$fatpacked{"File/Spec/Epoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  require File::Spec::Unix;
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there.  This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still a work in progress. ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path.  On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
FILE_SPEC_EPOC

$fatpacked{"File/Spec/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  require Exporter;
  
  our @ISA = qw(Exporter);
  
  our @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  our @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  our %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  require File::Spec::Unix;
  my %udeps = (
      canonpath => [],
      catdir => [qw(canonpath)],
      catfile => [qw(canonpath catdir)],
      case_tolerant => [],
      curdir => [],
      devnull => [],
      rootdir => [],
      updir => [],
  );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      if (exists($udeps{$meth}) && $sub == File::Spec::Unix->can($meth) &&
  	    !(grep {
  		File::Spec->can($_) != File::Spec::Unix->can($_)
  	    } @{$udeps{$meth}}) &&
  	    defined(&{"File::Spec::Unix::_fn_$meth"})) {
  	*{$meth} = \&{"File::Spec::Unix::_fn_$meth"};
      } else {
  	*{$meth} = sub {&$sub('File::Spec', @_)};
      }
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
FILE_SPEC_FUNCTIONS

$fatpacked{"File/Spec/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  L<File::Spec::Unix/canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"        # can't go
                                                        # beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()  # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()  # can't go
                                                        # beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"
                                                      # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see L<File::Spec::Unix/canonpath()>. If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns the empty string.  Mac OS has no real root directory.
  
  =cut
  
  sub rootdir { '' }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR} ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");         # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");     # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");
                                                      # true (absolute)
      File::Spec->file_name_is_absolute("");          # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = Cwd::getcwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# ignore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
FILE_SPEC_MAC

$fatpacked{"File/Spec/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TEMP TMP');
      return $cached if defined $cached;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $_[0]->_cache_tmpdir(
  	$_[0]->_tmpdir( @d, '/tmp', '/' ), qw 'TMPDIR TEMP TMP'
      );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = Cwd::getcwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
FILE_SPEC_OS2

$fatpacked{"File/Spec/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use Cwd ();
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub _pp_canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  *canonpath = \&_pp_canonpath unless defined &canonpath;
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub _pp_catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  *catdir = \&_pp_catdir unless defined &catdir;
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub _pp_catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  *catfile = \&_pp_catfile unless defined &catfile;
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  use constant _fn_curdir => ".";
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  use constant _fn_devnull => "/dev/null";
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  use constant _fn_rootdir => "/";
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my ($tmpdir, %tmpenv);
  # Cache and return the calculated tmpdir, recording which env vars
  # determined it.
  sub _cache_tmpdir {
      @tmpenv{@_[2..$#_]} = @ENV{@_[2..$#_]};
      return $tmpdir = $_[1];
  }
  # Retrieve the cached tmpdir, checking first whether relevant env vars have
  # changed and invalidated the cache.
  sub _cached_tmpdir {
      shift;
      local $^W;
      return if grep $ENV{$_} ne $tmpenv{$_}, @_;
      return $tmpdir;
  }
  sub _tmpdir {
      my $self = shift;
      my @dirlist = @_;
      my $taint = do { no strict 'refs'; ${"\cTAINT"} };
      if ($taint) { # Check for taint mode on perl >= 5.8.0
  	require Scalar::Util;
  	@dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
      }
      elsif ($] < 5.007) { # No ${^TAINT} before 5.8
  	@dirlist = grep { !defined($_) || eval { eval('1'.substr $_,0,0) } }
  			@dirlist;
      }
      
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      if ( !$self->file_name_is_absolute($tmpdir) ) {
          # See [perl #120593] for the full details
          # If possible, return a full path, rather than '.' or 'lib', but
          # jump through some hoops to avoid returning a tainted value.
          ($tmpdir) = grep {
              $taint     ? ! Scalar::Util::tainted($_) :
              $] < 5.007 ? eval { eval('1'.substr $_,0,0) } : 1
          } $self->rel2abs($tmpdir), $tmpdir;
      }
      return $tmpdir;
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  use constant _fn_updir => "..";
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  use constant _fn_case_tolerant => 0;
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made, so the result may not be correct if
  C<$base> contains symbolic links.  (Apply
  L<Cwd::abs_path()|Cwd/abs_path> beforehand if that
  is a concern.)  On VMS, there is interaction with the working environment, as
  logicals and macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = Cwd::getcwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      my $path_directories;
      my $base_directories;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
  
  	my ($path_volume) = $self->splitpath($path, 1);
  	my ($base_volume) = $self->splitpath($base, 1);
  
  	# Can't relativize across volumes
  	return $path unless $path_volume eq $base_volume;
  
  	$path_directories = ($self->splitpath($path, 1))[1];
  	$base_directories = ($self->splitpath($base, 1))[1];
  
  	# For UNC paths, the user might give a volume like //foo/bar that
  	# strictly speaking has no directory portion.  Treat it as if it
  	# had the root directory for that volume.
  	if (!length($base_directories) and $self->file_name_is_absolute($base)) {
  	    $base_directories = $self->rootdir;
  	}
      }
      else {
  	my $wd= ($self->splitpath(Cwd::getcwd(), 1))[1];
  	$path_directories = $self->catdir($wd, $path);
  	$base_directories = $self->catdir($wd, $base);
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        return $self->curdir if $path_directories eq $self->rootdir;
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      my @common;
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          push @common, shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # @basechunks now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.  If there
      # are updir components, we must descend into the corresponding directories
      # (this only works if they are no symlinks).
      my @reverse_base;
      while( defined(my $dir= shift @basechunks) ) {
  	if( $dir ne $self->updir ) {
  	    unshift @reverse_base, $self->updir;
  	    push @common, $dir;
  	}
  	elsif( @common ) {
  	    if( @reverse_base && $reverse_base[0] eq $self->updir ) {
  		shift @reverse_base;
  		pop @common;
  	    }
  	    else {
  		unshift @reverse_base, pop @common;
  	    }
  	}
      }
      my $result_dirs = $self->catdir( @reverse_base, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please submit bug reports and patches to perlbug@perl.org.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
FILE_SPEC_UNIX

$fatpacked{"File/Spec/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The default behavior is to allow either VMS or Unix syntax on input and to 
  return VMS syntax on output unless Unix syntax has been explicitly requested
  via the C<DECC$FILENAME_UNIX_REPORT> CRTL feature.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__};
                 local @INC = @INC;
                 pop @INC if $INC[-1] eq '.';
                 require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications and returns results
  in native syntax unless Unix filename reporting has been enabled.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $unix_rpt = $self->_unix_rpt;
  
      if ($path =~ m|/|) {
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        return $path if $unix_rpt;
        $path = $pathify ? vmspath($path) : vmsify($path);
      }
  
      $path =~ s/(?<!\^)</[/;			# < and >       ==> [ and ]
      $path =~ s/(?<!\^)>/]/;
      $path =~ s/(?<!\^)\]\[\./\.\]\[/g;		# ][.		==> .][
      $path =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $path =~ s/(?<!\^)\[000000\./\[/g;		# [000000.	==> [
      $path =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $path =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar     ==> foo.bar
      1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
      1 while ($path =~ s/(?<!\^)([\[\.])(?:\^.|[^\]\.])+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
      $path =~ s/(?<!\^)\[\.-/[-/;		# [.-		==> [-
      $path =~ s/(?<!\^)\.(?:\^.|[^\]\.])+\.-\./\./g;	# .foo.-.	==> .
      $path =~ s/(?<!\^)\[(?:\^.|[^\]\.])+\.-\./\[/g;	# [foo.-.	==> [
      $path =~ s/(?<!\^)\.(?:\^.|[^\]\.])+\.-\]/\]/g;	# .foo.-]	==> ]
  						# [foo.-]       ==> [000000]
      $path =~ s/(?<!\^)\[(?:\^.|[^\]\.])+\.-\]/\[000000\]/g;
  						# []		==>
      $path =~ s/(?<!\^)\[\]// unless $path eq '[]';
      return $unix_rpt ? unixify($path) : $path;
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  native directory specification unless the Unix filename reporting feature
  has been enabled.  No check is made for "impossible" cases (e.g. elements
  other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my @dirs = grep {defined() && length()} @_;
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  	$spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	if ($unix_rpt) {
  	    $spath = unixify($spath) unless $spath =~ m#/#;
  	    $sdir= unixify($sdir) unless $sdir =~ m#/#;
              return $self->SUPER::catdir($spath, $sdir)
  	}
  
  	$rslt = vmspath( unixify($spath) . '/' . unixify($sdir));
  
  	# Special case for VMS absolute directory specs: these will have
  	# had device prepended during trip through Unix syntax in
  	# eliminate_macros(), since Unix syntax has no way to express
  	# "absolute from the top of this device's directory tree".
  	if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  
      } else {
  	# Single directory. Return an empty string on null input; otherwise
  	# just return a canonical path.
  
  	if    (not defined $dir or not length $dir) {
  	    $rslt = '';
  	} else {
  	    $rslt = $unix_rpt ? $dir : vmspath($dir);
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my $rslt;
      if (@files) {
  	my $path = (@files == 1 ? $files[0] : $self->catdir(@files));
  	my $spath = $path;
  
          # Something building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # If the spath ends with a directory delimiter and the file is bare,
          # then just concatenate them.
  	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
             $rslt = unixify($spath);
             $rslt .= (defined($rslt) && length($rslt) ? '/' : '') . unixify($file);
             $rslt = vmsify($rslt) unless $unix_rpt;
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = (defined($file) && length($file)) ? $file : '';
  
          $rslt = $unix_rpt ? $xfile : vmsify($xfile);
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundant path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  sub tmpdir {
      my $self = shift @_;
      my $tmpdir = $self->_cached_tmpdir('TMPDIR');
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
      }
      else {
          $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
      }
      $self->_cache_tmpdir($tmpdir, 'TMPDIR');
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /^[A-Za-z0-9_\$\-\~]+(?<!\^):/);
  }
  
  =item splitpath (override)
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $vmsify_path = vmsify($path);
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      $dirspec =~ s/(?<!\^)</[/;                  # < and >	==> [ and ]
      $dirspec =~ s/(?<!\^)>/]/;
      $dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;	# ][.		==> .][
      $dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $dirspec =~ s/(?<!\^)\[000000\./\[/g;	# [000000.	==> [
      $dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $dirspec =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      # We look for a volume in $dev, then in $dir, but not both
      my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
      $dev = $dir_volume unless length $dev;
      $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
      
      if ($dev =~ m|^(?<!\^)/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
          $dir = "[$dir]" unless $dir =~ /(?<!\^)[\[<\/]/;
          $dir = vmspath($dir);
      }
      $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert an absolute file specification to a relative specification.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      my($path,$base) = @_;
  
      $base = Cwd::getcwd() unless defined $base and length $base;
  
      # If there is no device or directory syntax on $base, make sure it
      # is treated as a directory.
      $base = vmspath($base) unless $base =~ m{(?<!\^)[\[<:]};
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $self->canonpath( $path ) unless lc($path_volume) eq lc($base_volume);
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
      if ($path =~ m/\//) {
         $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
                    ? vmspath($path)             # whether it's a directory
                    : vmsify($path) );
      }
      $base = vmspath($base) if defined $base && $base =~ m/\//;
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
          $sep = '.'
              if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                   $path_directories =~ m{^[^.\[<]}s
              ) ;
          $base_directories = "$base_directories$sep$path_directories";
          $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-14 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.
  
  =cut
  
  1;
FILE_SPEC_VMS

$fatpacked{"File/Spec/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.74';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $tmpdir = $_[0]->_cached_tmpdir(qw(TMPDIR TEMP TMP));
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
      $_[0]->_cache_tmpdir($tmpdir, qw(TMPDIR TEMP TMP));
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval {
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      require Win32API::File;
    } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( Cwd::getcwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = Cwd::getcwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
FILE_SPEC_WIN32

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;
  
  use strict;
  use warnings;
  use Exporter   ();
  use File::Spec ();
  
  # ABSTRACT: Perl implementation of the which utility as an API
  our $VERSION = '1.23'; # VERSION
  
  
  our @ISA       = 'Exporter';
  our @EXPORT    = 'which';
  our @EXPORT_OK = 'where';
  
  use constant IS_VMS => ($^O eq 'VMS');
  use constant IS_MAC => ($^O eq 'MacOS');
  use constant IS_WIN => ($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');
  use constant IS_DOS => IS_WIN();
  use constant IS_CYG => ($^O eq 'cygwin' || $^O eq 'msys');
  
  our $IMPLICIT_CURRENT_DIR = IS_WIN || IS_VMS || IS_MAC;
  
  # For Win32 systems, stores the extensions used for
  # executable files
  # For others, the empty string is used
  # because 'perl' . '' eq 'perl' => easier
  my @PATHEXT = ('');
  if ( IS_WIN ) {
    # WinNT. PATHEXT might be set on Cygwin, but not used.
    if ( $ENV{PATHEXT} ) {
      push @PATHEXT, split ';', $ENV{PATHEXT};
    } else {
      # Win9X or other: doesn't have PATHEXT, so needs hardcoded.
      push @PATHEXT, qw{.com .exe .bat};
    }
  } elsif ( IS_VMS ) {
    push @PATHEXT, qw{.exe .com};
  } elsif ( IS_CYG ) {
    # See this for more info
    # http://cygwin.com/cygwin-ug-net/using-specialnames.html#pathnames-exe
    push @PATHEXT, qw{.exe .com};
  }
  
  
  sub which {
    my ($exec) = @_;
  
    return undef unless defined $exec;
    return undef if $exec eq '';
  
    my $all = wantarray;
    my @results = ();
  
    # check for aliases first
    if ( IS_VMS ) {
      my $symbol = `SHOW SYMBOL $exec`;
      chomp($symbol);
      unless ( $? ) {
        return $symbol unless $all;
        push @results, $symbol;
      }
    }
    if ( IS_MAC ) {
      my @aliases = split /\,/, $ENV{Aliases};
      foreach my $alias ( @aliases ) {
        # This has not been tested!!
        # PPT which says MPW-Perl cannot resolve `Alias $alias`,
        # let's just hope it's fixed
        if ( lc($alias) eq lc($exec) ) {
          chomp(my $file = `Alias $alias`);
          last unless $file;  # if it failed, just go on the normal way
          return $file unless $all;
          push @results, $file;
          # we can stop this loop as if it finds more aliases matching,
          # it'll just be the same result anyway
          last;
        }
      }
    }
  
    return $exec
            if !IS_VMS and !IS_MAC and !IS_WIN and $exec =~ /\// and -f $exec and -x $exec;
  
    my @path;
    if($^O eq 'MSWin32') {
      # File::Spec (at least recent versions)
      # add the implicit . for you on MSWin32,
      # but we may or may not want to include
      # that.
      @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
    } else {
      @path = File::Spec->path;
    }
    if ( $IMPLICIT_CURRENT_DIR ) {
      unshift @path, File::Spec->curdir;
    }
  
    foreach my $base ( map { File::Spec->catfile($_, $exec) } @path ) {
      for my $ext ( @PATHEXT ) {
        my $file = $base.$ext;
  
        # We don't want dirs (as they are -x)
        next if -d $file;
  
        if (
          # Executable, normal case
          -x _
          or (
            # MacOS doesn't mark as executable so we check -e
            IS_MAC
            ||
            (
              ( IS_WIN or IS_CYG )
              and
              grep {
                $file =~ /$_\z/i
              } @PATHEXT[1..$#PATHEXT]
            )
            # DOSish systems don't pass -x on
            # non-exe/bat/com files. so we check -e.
            # However, we don't want to pass -e on files
            # that aren't in PATHEXT, like README.
            and -e _
          )
        ) {
          return $file unless $all;
          push @results, $file;
        }
      }
    }
  
    if ( $all ) {
      return @results;
    } else {
      return undef;
    }
  }
  
  
  sub where {
    # force wantarray
    my @res = which($_[0]);
    return @res;
  }
  
  1;
  
FILE_WHICH

$fatpacked{"Getopt/Long.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GETOPT_LONG';
  #! perl
  
  # Getopt::Long.pm -- Universal options parsing
  # Author          : Johan Vromans
  # Created On      : Tue Sep 11 15:00:12 1990
  # Last Modified By: Johan Vromans
  # Last Modified On: Sat May 27 12:11:39 2017
  # Update Count    : 1715
  # Status          : Released
  
  ################ Module Preamble ################
  
  use 5.004;
  
  use strict;
  use warnings;
  
  package Getopt::Long;
  
  use vars qw($VERSION);
  $VERSION        =  2.50;
  # For testing versions only.
  use vars qw($VERSION_STRING);
  $VERSION_STRING = "2.50";
  
  use Exporter;
  use vars qw(@ISA @EXPORT @EXPORT_OK);
  @ISA = qw(Exporter);
  
  # Exported subroutines.
  sub GetOptions(@);		# always
  sub GetOptionsFromArray(@);	# on demand
  sub GetOptionsFromString(@);	# on demand
  sub Configure(@);		# on demand
  sub HelpMessage(@);		# on demand
  sub VersionMessage(@);		# in demand
  
  BEGIN {
      # Init immediately so their contents can be used in the 'use vars' below.
      @EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
      @EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
  		    &GetOptionsFromArray &GetOptionsFromString);
  }
  
  # User visible variables.
  use vars @EXPORT, @EXPORT_OK;
  use vars qw($error $debug $major_version $minor_version);
  # Deprecated visible variables.
  use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
  	    $passthrough);
  # Official invisible variables.
  use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
  
  # Really invisible variables.
  my $bundling_values;
  
  # Public subroutines.
  sub config(@);			# deprecated name
  
  # Private subroutines.
  sub ConfigDefaults();
  sub ParseOptionSpec($$);
  sub OptCtl($);
  sub FindOption($$$$$);
  sub ValidValue ($$$$$);
  
  ################ Local Variables ################
  
  # $requested_version holds the version that was mentioned in the 'use'
  # or 'require', if any. It can be used to enable or disable specific
  # features.
  my $requested_version = 0;
  
  ################ Resident subroutines ################
  
  sub ConfigDefaults() {
      # Handle POSIX compliancy.
      if ( defined $ENV{"POSIXLY_CORRECT"} ) {
  	$genprefix = "(--|-)";
  	$autoabbrev = 0;		# no automatic abbrev of options
  	$bundling = 0;			# no bundling of single letter switches
  	$getopt_compat = 0;		# disallow '+' to start options
  	$order = $REQUIRE_ORDER;
      }
      else {
  	$genprefix = "(--|-|\\+)";
  	$autoabbrev = 1;		# automatic abbrev of options
  	$bundling = 0;			# bundling off by default
  	$getopt_compat = 1;		# allow '+' to start options
  	$order = $PERMUTE;
      }
      # Other configurable settings.
      $debug = 0;			# for debugging
      $error = 0;			# error tally
      $ignorecase = 1;		# ignore case when matching options
      $passthrough = 0;		# leave unrecognized options alone
      $gnu_compat = 0;		# require --opt=val if value is optional
      $longprefix = "(--)";       # what does a long prefix look like
      $bundling_values = 0;	# no bundling of values
  }
  
  # Override import.
  sub import {
      my $pkg = shift;		# package
      my @syms = ();		# symbols to import
      my @config = ();		# configuration
      my $dest = \@syms;		# symbols first
      for ( @_ ) {
  	if ( $_ eq ':config' ) {
  	    $dest = \@config;	# config next
  	    next;
  	}
  	push(@$dest, $_);	# push
      }
      # Hide one level and call super.
      local $Exporter::ExportLevel = 1;
      push(@syms, qw(&GetOptions)) if @syms; # always export GetOptions
      $requested_version = 0;
      $pkg->SUPER::import(@syms);
      # And configure.
      Configure(@config) if @config;
  }
  
  ################ Initialization ################
  
  # Values for $order. See GNU getopt.c for details.
  ($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
  # Version major/minor numbers.
  ($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
  
  ConfigDefaults();
  
  ################ OO Interface ################
  
  package Getopt::Long::Parser;
  
  # Store a copy of the default configuration. Since ConfigDefaults has
  # just been called, what we get from Configure is the default.
  my $default_config = do {
      Getopt::Long::Configure ()
  };
  
  sub new {
      my $that = shift;
      my $class = ref($that) || $that;
      my %atts = @_;
  
      # Register the callers package.
      my $self = { caller_pkg => (caller)[0] };
  
      bless ($self, $class);
  
      # Process config attributes.
      if ( defined $atts{config} ) {
  	my $save = Getopt::Long::Configure ($default_config, @{$atts{config}});
  	$self->{settings} = Getopt::Long::Configure ($save);
  	delete ($atts{config});
      }
      # Else use default config.
      else {
  	$self->{settings} = $default_config;
      }
  
      if ( %atts ) {		# Oops
  	die(__PACKAGE__.": unhandled attributes: ".
  	    join(" ", sort(keys(%atts)))."\n");
      }
  
      $self;
  }
  
  sub configure {
      my ($self) = shift;
  
      # Restore settings, merge new settings in.
      my $save = Getopt::Long::Configure ($self->{settings}, @_);
  
      # Restore orig config and save the new config.
      $self->{settings} = Getopt::Long::Configure ($save);
  }
  
  sub getoptions {
      my ($self) = shift;
  
      return $self->getoptionsfromarray(\@ARGV, @_);
  }
  
  sub getoptionsfromarray {
      my ($self) = shift;
  
      # Restore config settings.
      my $save = Getopt::Long::Configure ($self->{settings});
  
      # Call main routine.
      my $ret = 0;
      $Getopt::Long::caller = $self->{caller_pkg};
  
      eval {
  	# Locally set exception handler to default, otherwise it will
  	# be called implicitly here, and again explicitly when we try
  	# to deliver the messages.
  	local ($SIG{__DIE__}) = 'DEFAULT';
  	$ret = Getopt::Long::GetOptionsFromArray (@_);
      };
  
      # Restore saved settings.
      Getopt::Long::Configure ($save);
  
      # Handle errors and return value.
      die ($@) if $@;
      return $ret;
  }
  
  package Getopt::Long;
  
  ################ Back to Normal ################
  
  # Indices in option control info.
  # Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
  use constant CTL_TYPE    => 0;
  #use constant   CTL_TYPE_FLAG   => '';
  #use constant   CTL_TYPE_NEG    => '!';
  #use constant   CTL_TYPE_INCR   => '+';
  #use constant   CTL_TYPE_INT    => 'i';
  #use constant   CTL_TYPE_INTINC => 'I';
  #use constant   CTL_TYPE_XINT   => 'o';
  #use constant   CTL_TYPE_FLOAT  => 'f';
  #use constant   CTL_TYPE_STRING => 's';
  
  use constant CTL_CNAME   => 1;
  
  use constant CTL_DEFAULT => 2;
  
  use constant CTL_DEST    => 3;
   use constant   CTL_DEST_SCALAR => 0;
   use constant   CTL_DEST_ARRAY  => 1;
   use constant   CTL_DEST_HASH   => 2;
   use constant   CTL_DEST_CODE   => 3;
  
  use constant CTL_AMIN    => 4;
  use constant CTL_AMAX    => 5;
  
  # FFU.
  #use constant CTL_RANGE   => ;
  #use constant CTL_REPEAT  => ;
  
  # Rather liberal patterns to match numbers.
  use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
  use constant PAT_XINT  =>
    "(?:".
  	  "[-+]?_*[1-9][0-9_]*".
    "|".
  	  "0x_*[0-9a-f][0-9a-f_]*".
    "|".
  	  "0b_*[01][01_]*".
    "|".
  	  "0[0-7_]*".
    ")";
  use constant PAT_FLOAT =>
    "[-+]?".			# optional sign
    "(?=[0-9.])".			# must start with digit or dec.point
    "[0-9_]*".			# digits before the dec.point
    "(\.[0-9_]+)?".		# optional fraction
    "([eE][-+]?[0-9_]+)?";	# optional exponent
  
  sub GetOptions(@) {
      # Shift in default array.
      unshift(@_, \@ARGV);
      # Try to keep caller() and Carp consistent.
      goto &GetOptionsFromArray;
  }
  
  sub GetOptionsFromString(@) {
      my ($string) = shift;
      require Text::ParseWords;
      my $args = [ Text::ParseWords::shellwords($string) ];
      $caller ||= (caller)[0];	# current context
      my $ret = GetOptionsFromArray($args, @_);
      return ( $ret, $args ) if wantarray;
      if ( @$args ) {
  	$ret = 0;
  	warn("GetOptionsFromString: Excess data \"@$args\" in string \"$string\"\n");
      }
      $ret;
  }
  
  sub GetOptionsFromArray(@) {
  
      my ($argv, @optionlist) = @_;	# local copy of the option descriptions
      my $argend = '--';		# option list terminator
      my %opctl = ();		# table of option specs
      my $pkg = $caller || (caller)[0];	# current context
  				# Needed if linkage is omitted.
      my @ret = ();		# accum for non-options
      my %linkage;		# linkage
      my $userlinkage;		# user supplied HASH
      my $opt;			# current option
      my $prefix = $genprefix;	# current prefix
  
      $error = '';
  
      if ( $debug ) {
  	# Avoid some warnings if debugging.
  	local ($^W) = 0;
  	print STDERR
  	  ("Getopt::Long $Getopt::Long::VERSION ",
  	   "called from package \"$pkg\".",
  	   "\n  ",
  	   "argv: ",
  	   defined($argv)
  	   ? UNIVERSAL::isa( $argv, 'ARRAY' ) ? "(@$argv)" : $argv
  	   : "<undef>",
  	   "\n  ",
  	   "autoabbrev=$autoabbrev,".
  	   "bundling=$bundling,",
  	   "bundling_values=$bundling_values,",
  	   "getopt_compat=$getopt_compat,",
  	   "gnu_compat=$gnu_compat,",
  	   "order=$order,",
  	   "\n  ",
  	   "ignorecase=$ignorecase,",
  	   "requested_version=$requested_version,",
  	   "passthrough=$passthrough,",
  	   "genprefix=\"$genprefix\",",
  	   "longprefix=\"$longprefix\".",
  	   "\n");
      }
  
      # Check for ref HASH as first argument.
      # First argument may be an object. It's OK to use this as long
      # as it is really a hash underneath.
      $userlinkage = undef;
      if ( @optionlist && ref($optionlist[0]) and
  	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
  	$userlinkage = shift (@optionlist);
  	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
      }
  
      # See if the first element of the optionlist contains option
      # starter characters.
      # Be careful not to interpret '<>' as option starters.
      if ( @optionlist && $optionlist[0] =~ /^\W+$/
  	 && !($optionlist[0] eq '<>'
  	      && @optionlist > 0
  	      && ref($optionlist[1])) ) {
  	$prefix = shift (@optionlist);
  	# Turn into regexp. Needs to be parenthesized!
  	$prefix =~ s/(\W)/\\$1/g;
  	$prefix = "([" . $prefix . "])";
  	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
      }
  
      # Verify correctness of optionlist.
      %opctl = ();
      while ( @optionlist ) {
  	my $opt = shift (@optionlist);
  
  	unless ( defined($opt) ) {
  	    $error .= "Undefined argument in option spec\n";
  	    next;
  	}
  
  	# Strip leading prefix so people can specify "--foo=i" if they like.
  	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
  
  	if ( $opt eq '<>' ) {
  	    if ( (defined $userlinkage)
  		&& !(@optionlist > 0 && ref($optionlist[0]))
  		&& (exists $userlinkage->{$opt})
  		&& ref($userlinkage->{$opt}) ) {
  		unshift (@optionlist, $userlinkage->{$opt});
  	    }
  	    unless ( @optionlist > 0
  		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
  		$error .= "Option spec <> requires a reference to a subroutine\n";
  		# Kill the linkage (to avoid another error).
  		shift (@optionlist)
  		  if @optionlist && ref($optionlist[0]);
  		next;
  	    }
  	    $linkage{'<>'} = shift (@optionlist);
  	    next;
  	}
  
  	# Parse option spec.
  	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
  	unless ( defined $name ) {
  	    # Failed. $orig contains the error message. Sorry for the abuse.
  	    $error .= $orig;
  	    # Kill the linkage (to avoid another error).
  	    shift (@optionlist)
  	      if @optionlist && ref($optionlist[0]);
  	    next;
  	}
  
  	# If no linkage is supplied in the @optionlist, copy it from
  	# the userlinkage if available.
  	if ( defined $userlinkage ) {
  	    unless ( @optionlist > 0 && ref($optionlist[0]) ) {
  		if ( exists $userlinkage->{$orig} &&
  		     ref($userlinkage->{$orig}) ) {
  		    print STDERR ("=> found userlinkage for \"$orig\": ",
  				  "$userlinkage->{$orig}\n")
  			if $debug;
  		    unshift (@optionlist, $userlinkage->{$orig});
  		}
  		else {
  		    # Do nothing. Being undefined will be handled later.
  		    next;
  		}
  	    }
  	}
  
  	# Copy the linkage. If omitted, link to global variable.
  	if ( @optionlist > 0 && ref($optionlist[0]) ) {
  	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
  		if $debug;
  	    my $rl = ref($linkage{$orig} = shift (@optionlist));
  
  	    if ( $rl eq "ARRAY" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
  	    }
  	    elsif ( $rl eq "HASH" ) {
  		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
  	    }
  	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
  #		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  #		    my $t = $linkage{$orig};
  #		    $$t = $linkage{$orig} = [];
  #		}
  #		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  #		}
  #		else {
  		    # Ok.
  #		}
  	    }
  	    elsif ( $rl eq "CODE" ) {
  		# Ok.
  	    }
  	    else {
  		$error .= "Invalid option linkage for \"$opt\"\n";
  	    }
  	}
  	else {
  	    # Link to global $opt_XXX variable.
  	    # Make sure a valid perl identifier results.
  	    my $ov = $orig;
  	    $ov =~ s/\W/_/g;
  	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
  		print STDERR ("=> link \"$orig\" to \@$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\@".$pkg."::opt_$ov;");
  	    }
  	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
  		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
  	    }
  	    else {
  		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
  		    if $debug;
  		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
  	    }
  	}
  
  	if ( $opctl{$name}[CTL_TYPE] eq 'I'
  	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
  		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
  	   ) {
  	    $error .= "Invalid option linkage for \"$opt\"\n";
  	}
  
      }
  
      $error .= "GetOptionsFromArray: 1st parameter is not an array reference\n"
        unless $argv && UNIVERSAL::isa( $argv, 'ARRAY' );
  
      # Bail out if errors found.
      die ($error) if $error;
      $error = 0;
  
      # Supply --version and --help support, if needed and allowed.
      if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{version}) ) {
  	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
  	    $linkage{version} = \&VersionMessage;
  	}
  	$auto_version = 1;
      }
      if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
  	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
  	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
  	    $linkage{help} = \&HelpMessage;
  	}
  	$auto_help = 1;
      }
  
      # Show the options tables if debugging.
      if ( $debug ) {
  	my ($arrow, $k, $v);
  	$arrow = "=> ";
  	while ( ($k,$v) = each(%opctl) ) {
  	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
  	    $arrow = "   ";
  	}
      }
  
      # Process argument list
      my $goon = 1;
      while ( $goon && @$argv > 0 ) {
  
  	# Get next argument.
  	$opt = shift (@$argv);
  	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
  
  	# Double dash is option list terminator.
  	if ( defined($opt) && $opt eq $argend ) {
  	  push (@ret, $argend) if $passthrough;
  	  last;
  	}
  
  	# Look it up.
  	my $tryopt = $opt;
  	my $found;		# success status
  	my $key;		# key (if hash type)
  	my $arg;		# option argument
  	my $ctl;		# the opctl entry
  
  	($found, $opt, $ctl, $arg, $key) =
  	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
  
  	if ( $found ) {
  
  	    # FindOption undefines $opt in case of errors.
  	    next unless defined $opt;
  
  	    my $argcnt = 0;
  	    while ( defined $arg ) {
  
  		# Get the canonical name.
  		print STDERR ("=> cname for \"$opt\" is ") if $debug;
  		$opt = $ctl->[CTL_CNAME];
  		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
  
  		if ( defined $linkage{$opt} ) {
  		    print STDERR ("=> ref(\$L{$opt}) -> ",
  				  ref($linkage{$opt}), "\n") if $debug;
  
  		    if ( ref($linkage{$opt}) eq 'SCALAR'
  			 || ref($linkage{$opt}) eq 'REF' ) {
  			if ( $ctl->[CTL_TYPE] eq '+' ) {
  			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
  			      if $debug;
  			    if ( defined ${$linkage{$opt}} ) {
  			        ${$linkage{$opt}} += $arg;
  			    }
  		            else {
  			        ${$linkage{$opt}} = $arg;
  			    }
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to ARRAY\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = [];
  			    print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			      if $debug;
  			    push (@{$linkage{$opt}}, $arg);
  			}
  			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
  					  " to HASH\n")
  			      if $debug;
  			    my $t = $linkage{$opt};
  			    $$t = $linkage{$opt} = {};
  			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			      if $debug;
  			    $linkage{$opt}->{$key} = $arg;
  			}
  			else {
  			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
  			      if $debug;
  			    ${$linkage{$opt}} = $arg;
  		        }
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
  			print STDERR ("=> push(\@{\$L{$opt}, \"$arg\")\n")
  			    if $debug;
  			push (@{$linkage{$opt}}, $arg);
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
  			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$linkage{$opt}->{$key} = $arg;
  		    }
  		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
  			print STDERR ("=> &L{$opt}(\"$opt\"",
  				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
  				      ", \"$arg\")\n")
  			    if $debug;
  			my $eval_error = do {
  			    local $@;
  			    local $SIG{__DIE__}  = 'DEFAULT';
  			    eval {
  				&{$linkage{$opt}}
  				  (Getopt::Long::CallBack->new
  				   (name    => $opt,
  				    ctl     => $ctl,
  				    opctl   => \%opctl,
  				    linkage => \%linkage,
  				    prefix  => $prefix,
  				   ),
  				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
  				   $arg);
  			    };
  			    $@;
  			};
  			print STDERR ("=> die($eval_error)\n")
  			  if $debug && $eval_error ne '';
  			if ( $eval_error =~ /^!/ ) {
  			    if ( $eval_error =~ /^!FINISH\b/ ) {
  				$goon = 0;
  			    }
  			}
  			elsif ( $eval_error ne '' ) {
  			    warn ($eval_error);
  			    $error++;
  			}
  		    }
  		    else {
  			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
  				      "\" in linkage\n");
  			die("Getopt::Long -- internal error!\n");
  		    }
  		}
  		# No entry in linkage means entry in userlinkage.
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> push(\@{\$L{$opt}}, \"$arg\")\n")
  			    if $debug;
  			push (@{$userlinkage->{$opt}}, $arg);
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
  			    if $debug;
  			$userlinkage->{$opt} = [$arg];
  		    }
  		}
  		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  		    if ( defined $userlinkage->{$opt} ) {
  			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
  			    if $debug;
  			$userlinkage->{$opt}->{$key} = $arg;
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
  			    if $debug;
  			$userlinkage->{$opt} = {$key => $arg};
  		    }
  		}
  		else {
  		    if ( $ctl->[CTL_TYPE] eq '+' ) {
  			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
  			  if $debug;
  			if ( defined $userlinkage->{$opt} ) {
  			    $userlinkage->{$opt} += $arg;
  			}
  			else {
  			    $userlinkage->{$opt} = $arg;
  			}
  		    }
  		    else {
  			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
  			$userlinkage->{$opt} = $arg;
  		    }
  		}
  
  		$argcnt++;
  		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
  		undef($arg);
  
  		# Need more args?
  		if ( $argcnt < $ctl->[CTL_AMIN] ) {
  		    if ( @$argv ) {
  			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
  			    $arg = shift(@$argv);
  			    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  				$arg =~ tr/_//d;
  				$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  				  ? oct($arg)
  				  : 0+$arg
  			    }
  			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  			    next;
  			}
  			warn("Value \"$$argv[0]\" invalid for option $opt\n");
  			$error++;
  		    }
  		    else {
  			warn("Insufficient arguments for option $opt\n");
  			$error++;
  		    }
  		}
  
  		# Any more args?
  		if ( @$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
  		    $arg = shift(@$argv);
  		    if ( $ctl->[CTL_TYPE] =~ /^[iIo]$/ ) {
  			$arg =~ tr/_//d;
  			$arg = $ctl->[CTL_TYPE] eq 'o' && $arg =~ /^0/
  			  ? oct($arg)
  			  : 0+$arg
  		    }
  		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
  		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  		    next;
  		}
  	    }
  	}
  
  	# Not an option. Save it if we $PERMUTE and don't have a <>.
  	elsif ( $order == $PERMUTE ) {
  	    # Try non-options call-back.
  	    my $cb;
  	    if ( defined ($cb = $linkage{'<>'}) ) {
  		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
  		  if $debug;
  		my $eval_error = do {
  		    local $@;
  		    local $SIG{__DIE__}  = 'DEFAULT';
  		    eval {
  			# The arg to <> cannot be the CallBack object
  			# since it may be passed to other modules that
  			# get confused (e.g., Archive::Tar). Well,
  			# it's not relevant for this callback anyway.
  			&$cb($tryopt);
  		    };
  		    $@;
  		};
  		print STDERR ("=> die($eval_error)\n")
  		  if $debug && $eval_error ne '';
  		if ( $eval_error =~ /^!/ ) {
  		    if ( $eval_error =~ /^!FINISH\b/ ) {
  			$goon = 0;
  		    }
  		}
  		elsif ( $eval_error ne '' ) {
  		    warn ($eval_error);
  		    $error++;
  		}
  	    }
  	    else {
  		print STDERR ("=> saving \"$tryopt\" ",
  			      "(not an option, may permute)\n") if $debug;
  		push (@ret, $tryopt);
  	    }
  	    next;
  	}
  
  	# ...otherwise, terminate.
  	else {
  	    # Push this one back and exit.
  	    unshift (@$argv, $tryopt);
  	    return ($error == 0);
  	}
  
      }
  
      # Finish.
      if ( @ret && $order == $PERMUTE ) {
  	#  Push back accumulated arguments
  	print STDERR ("=> restoring \"", join('" "', @ret), "\"\n")
  	    if $debug;
  	unshift (@$argv, @ret);
      }
  
      return ($error == 0);
  }
  
  # A readable representation of what's in an optbl.
  sub OptCtl ($) {
      my ($v) = @_;
      my @v = map { defined($_) ? ($_) : ("<undef>") } @$v;
      "[".
        join(",",
  	   "\"$v[CTL_TYPE]\"",
  	   "\"$v[CTL_CNAME]\"",
  	   "\"$v[CTL_DEFAULT]\"",
  	   ("\$","\@","\%","\&")[$v[CTL_DEST] || 0],
  	   $v[CTL_AMIN] || '',
  	   $v[CTL_AMAX] || '',
  #	   $v[CTL_RANGE] || '',
  #	   $v[CTL_REPEAT] || '',
  	  ). "]";
  }
  
  # Parse an option specification and fill the tables.
  sub ParseOptionSpec ($$) {
      my ($opt, $opctl) = @_;
  
      # Match option spec.
      if ( $opt !~ m;^
  		   (
  		     # Option name
  		     (?: \w+[-\w]* )
  		     # Alias names, or "?"
  		     (?: \| (?: \? | \w[-\w]* ) )*
  		     # Aliases
  		     (?: \| (?: [^-|!+=:][^|!+=:]* )? )*
  		   )?
  		   (
  		     # Either modifiers ...
  		     [!+]
  		     |
  		     # ... or a value/dest/repeat specification
  		     [=:] [ionfs] [@%]? (?: \{\d*,?\d*\} )?
  		     |
  		     # ... or an optional-with-default spec
  		     : (?: -?\d+ | \+ ) [@%]?
  		   )?
  		   $;x ) {
  	return (undef, "Error in option spec: \"$opt\"\n");
      }
  
      my ($names, $spec) = ($1, $2);
      $spec = '' unless defined $spec;
  
      # $orig keeps track of the primary name the user specified.
      # This name will be used for the internal or external linkage.
      # In other words, if the user specifies "FoO|BaR", it will
      # match any case combinations of 'foo' and 'bar', but if a global
      # variable needs to be set, it will be $opt_FoO in the exact case
      # as specified.
      my $orig;
  
      my @names;
      if ( defined $names ) {
  	@names =  split (/\|/, $names);
  	$orig = $names[0];
      }
      else {
  	@names = ('');
  	$orig = '';
      }
  
      # Construct the opctl entries.
      my $entry;
      if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
  	# Fields are hard-wired here.
  	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
      }
      elsif ( $spec =~ /^:(-?\d+|\+)([@%])?$/ ) {
  	my $def = $1;
  	my $dest = $2;
  	my $type = $def eq '+' ? 'I' : 'i';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,$def eq '+' ? undef : $def,
  		  $dest,0,1];
      }
      else {
  	my ($mand, $type, $dest) =
  	  $spec =~ /^([=:])([ionfs])([@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
  	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
  	  if $bundling && defined($4);
  	my ($mi, $cm, $ma) = ($5, $6, $7);
  	return (undef, "{0} is useless in option spec: \"$opt\"\n")
  	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);
  
  	$type = 'i' if $type eq 'n';
  	$dest ||= '$';
  	$dest = $dest eq '@' ? CTL_DEST_ARRAY
  	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
  	# Default minargs to 1/0 depending on mand status.
  	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
  	# Adjust mand status according to minargs.
  	$mand = $mi ? '=' : ':';
  	# Adjust maxargs.
  	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
  	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
  	  if defined($ma) && !$ma;
  	return (undef, "Max less than min in option spec: \"$opt\"\n")
  	  if defined($ma) && $ma < $mi;
  
  	# Fields are hard-wired here.
  	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
      }
  
      # Process all names. First is canonical, the rest are aliases.
      my $dups = '';
      foreach ( @names ) {
  
  	$_ = lc ($_)
  	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);
  
  	if ( exists $opctl->{$_} ) {
  	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
  	}
  
  	if ( $spec eq '!' ) {
  	    $opctl->{"no$_"} = $entry;
  	    $opctl->{"no-$_"} = $entry;
  	    $opctl->{$_} = [@$entry];
  	    $opctl->{$_}->[CTL_TYPE] = '';
  	}
  	else {
  	    $opctl->{$_} = $entry;
  	}
      }
  
      if ( $dups && $^W ) {
  	foreach ( split(/\n+/, $dups) ) {
  	    warn($_."\n");
  	}
      }
      ($names[0], $orig);
  }
  
  # Option lookup.
  sub FindOption ($$$$$) {
  
      # returns (1, $opt, $ctl, $arg, $key) if okay,
      # returns (1, undef) if option in error,
      # returns (0) otherwise.
  
      my ($argv, $prefix, $argend, $opt, $opctl) = @_;
  
      print STDERR ("=> find \"$opt\"\n") if $debug;
  
      return (0) unless defined($opt);
      return (0) unless $opt =~ /^($prefix)(.*)$/s;
      return (0) if $opt eq "-" && !defined $opctl->{''};
  
      $opt = substr( $opt, length($1) ); # retain taintedness
      my $starter = $1;
  
      print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;
  
      my $optarg;			# value supplied with --opt=value
      my $rest;			# remainder from unbundling
  
      # If it is a long option, it may include the value.
      # With getopt_compat, only if not bundling.
      if ( ($starter=~/^$longprefix$/
  	  || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
  	 && (my $oppos = index($opt, '=', 1)) > 0) {
  	my $optorg = $opt;
  	$opt = substr($optorg, 0, $oppos);
  	$optarg = substr($optorg, $oppos + 1); # retain tainedness
  	print STDERR ("=> option \"", $opt,
  		      "\", optarg = \"$optarg\"\n") if $debug;
      }
  
      #### Look it up ###
  
      my $tryopt = $opt;		# option to try
  
      if ( ( $bundling || $bundling_values ) && $starter eq '-' ) {
  
  	# To try overrides, obey case ignore.
  	$tryopt = $ignorecase ? lc($opt) : $opt;
  
  	# If bundling == 2, long options can override bundles.
  	if ( $bundling == 2 && length($tryopt) > 1
  	     && defined ($opctl->{$tryopt}) ) {
  	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
  	      if $debug;
  	}
  
  	# If bundling_values, option may be followed by the value.
  	elsif ( $bundling_values ) {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    # Whatever remains may not be considered an option.
  	    $optarg = $rest eq '' ? undef : $rest;
  	    $rest = undef;
  	}
  
  	# Split off a single letter and leave the rest for
  	# further processing.
  	else {
  	    $tryopt = $opt;
  	    # Unbundle single letter option.
  	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
  	    $tryopt = substr ($tryopt, 0, 1);
  	    $tryopt = lc ($tryopt) if $ignorecase > 1;
  	    print STDERR ("=> $starter$tryopt unbundled from ",
  			  "$starter$tryopt$rest\n") if $debug;
  	    $rest = undef unless $rest ne '';
  	}
      }
  
      # Try auto-abbreviation.
      elsif ( $autoabbrev && $opt ne "" ) {
  	# Sort the possible long option names.
  	my @names = sort(keys (%$opctl));
  	# Downcase if allowed.
  	$opt = lc ($opt) if $ignorecase;
  	$tryopt = $opt;
  	# Turn option name into pattern.
  	my $pat = quotemeta ($opt);
  	# Look up in option names.
  	my @hits = grep (/^$pat/, @names);
  	print STDERR ("=> ", scalar(@hits), " hits (@hits) with \"$pat\" ",
  		      "out of ", scalar(@names), "\n") if $debug;
  
  	# Check for ambiguous results.
  	unless ( (@hits <= 1) || (grep ($_ eq $opt, @hits) == 1) ) {
  	    # See if all matches are for the same option.
  	    my %hit;
  	    foreach ( @hits ) {
  		my $hit = $opctl->{$_}->[CTL_CNAME]
  		  if defined $opctl->{$_}->[CTL_CNAME];
  		$hit = "no" . $hit if $opctl->{$_}->[CTL_TYPE] eq '!';
  		$hit{$hit} = 1;
  	    }
  	    # Remove auto-supplied options (version, help).
  	    if ( keys(%hit) == 2 ) {
  		if ( $auto_version && exists($hit{version}) ) {
  		    delete $hit{version};
  		}
  		elsif ( $auto_help && exists($hit{help}) ) {
  		    delete $hit{help};
  		}
  	    }
  	    # Now see if it really is ambiguous.
  	    unless ( keys(%hit) == 1 ) {
  		return (0) if $passthrough;
  		warn ("Option ", $opt, " is ambiguous (",
  		      join(", ", @hits), ")\n");
  		$error++;
  		return (1, undef);
  	    }
  	    @hits = keys(%hit);
  	}
  
  	# Complete the option name, if appropriate.
  	if ( @hits == 1 && $hits[0] ne $opt ) {
  	    $tryopt = $hits[0];
  	    $tryopt = lc ($tryopt)
  	      if $ignorecase > (($bundling && length($tryopt) == 1) ? 1 : 0);
  	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
  		if $debug;
  	}
      }
  
      # Map to all lowercase if ignoring case.
      elsif ( $ignorecase ) {
  	$tryopt = lc ($opt);
      }
  
      # Check validity by fetching the info.
      my $ctl = $opctl->{$tryopt};
      unless  ( defined $ctl ) {
  	return (0) if $passthrough;
  	# Pretend one char when bundling.
  	if ( $bundling == 1 && length($starter) == 1 ) {
  	    $opt = substr($opt,0,1);
              unshift (@$argv, $starter.$rest) if defined $rest;
  	}
  	if ( $opt eq "" ) {
  	    warn ("Missing option after ", $starter, "\n");
  	}
  	else {
  	    warn ("Unknown option: ", $opt, "\n");
  	}
  	$error++;
  	return (1, undef);
      }
      # Apparently valid.
      $opt = $tryopt;
      print STDERR ("=> found ", OptCtl($ctl),
  		  " for \"", $opt, "\"\n") if $debug;
  
      #### Determine argument status ####
  
      # If it is an option w/o argument, we're almost finished with it.
      my $type = $ctl->[CTL_TYPE];
      my $arg;
  
      if ( $type eq '' || $type eq '!' || $type eq '+' ) {
  	if ( defined $optarg ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " does not take an argument\n");
  	    $error++;
  	    undef $opt;
  	    undef $optarg if $bundling_values;
  	}
  	elsif ( $type eq '' || $type eq '+' ) {
  	    # Supply explicit value.
  	    $arg = 1;
  	}
  	else {
  	    $opt =~ s/^no-?//i;	# strip NO prefix
  	    $arg = 0;		# supply explicit value
  	}
  	unshift (@$argv, $starter.$rest) if defined $rest;
  	return (1, $opt, $ctl, $arg);
      }
  
      # Get mandatory status and type info.
      my $mand = $ctl->[CTL_AMIN];
  
      # Check if there is an option argument available.
      if ( $gnu_compat ) {
  	my $optargtype = 0; # none, 1 = empty, 2 = nonempty, 3 = aux
  	if ( defined($optarg) ) {
  	    $optargtype = (length($optarg) == 0) ? 1 : 2;
  	}
  	elsif ( defined $rest || @$argv > 0 ) {
  	    # GNU getopt_long() does not accept the (optional)
  	    # argument to be passed to the option without = sign.
  	    # We do, since not doing so breaks existing scripts.
  	    $optargtype = 3;
  	}
  	if(($optargtype == 0) && !$mand) {
  	    my $val
  	      = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT]
  	      : $type eq 's'                 ? ''
  	      :                                0;
  	    return (1, $opt, $ctl, $val);
  	}
  	return (1, $opt, $ctl, $type eq 's' ? '' : 0)
  	  if $optargtype == 1;  # --foo=  -> return nothing
      }
  
      # Check if there is an option argument available.
      if ( defined $optarg
  	 ? ($optarg eq '')
  	 : !(defined $rest || @$argv > 0) ) {
  	# Complain if this option needs an argument.
  #	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
  	if ( $mand ) {
  	    return (0) if $passthrough;
  	    warn ("Option ", $opt, " requires an argument\n");
  	    $error++;
  	    return (1, undef);
  	}
  	if ( $type eq 'I' ) {
  	    # Fake incremental type.
  	    my @c = @$ctl;
  	    $c[CTL_TYPE] = '+';
  	    return (1, $opt, \@c, 1);
  	}
  	return (1, $opt, $ctl,
  		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  		$type eq 's' ? '' : 0);
      }
  
      # Get (possibly optional) argument.
      $arg = (defined $rest ? $rest
  	    : (defined $optarg ? $optarg : shift (@$argv)));
  
      # Get key if this is a "name=value" pair for a hash option.
      my $key;
      if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
  	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
  	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
  	     ($mand ? undef : ($type eq 's' ? "" : 1)));
  	if (! defined $arg) {
  	    warn ("Option $opt, key \"$key\", requires a value\n");
  	    $error++;
  	    # Push back.
  	    unshift (@$argv, $starter.$rest) if defined $rest;
  	    return (1, undef);
  	}
      }
  
      #### Check if the argument is valid for this option ####
  
      my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1, $opt, $ctl, $arg, $key) if $mand;
  
  	# Same for optional string as a hash value
  	return (1, $opt, $ctl, $arg, $key)
  	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;
  
  	# An optional string takes almost anything.
  	return (1, $opt, $ctl, $arg, $key)
  	  if defined $optarg || defined $rest;
  	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
  
  	# Check for option or option list terminator.
  	if ($arg eq $argend ||
  	    $arg =~ /^$prefix.+/) {
  	    # Push back.
  	    unshift (@$argv, $arg);
  	    # Supply empty value.
  	    $arg = '';
  	}
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  
  	if ( $bundling && defined $rest
  	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/si ) {
  	    $arg =~ tr/_//d;
  	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (",
  		      $type eq 'o' ? "extended " : '',
  		      "number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		if ( $type eq 'I' ) {
  		    # Fake incremental type.
  		    my @c = @$ctl;
  		    $c[CTL_TYPE] = '+';
  		    return (1, $opt, \@c, 1);
  		}
  		# Supply default value.
  		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
  	    }
  	}
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	if ( $bundling && defined $rest &&
  	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
  	    $arg =~ tr/_//d;
  	    ($key, $arg, $rest) = ($1, $2, $+);
  	    chop($key) if $key;
  	    unshift (@$argv, $starter.$rest) if defined $rest && $rest ne '';
  	}
  	elsif ( $arg =~ /^$o_valid$/ ) {
  	    $arg =~ tr/_//d;
  	}
  	else {
  	    if ( defined $optarg || $mand ) {
  		if ( $passthrough ) {
  		    unshift (@$argv, defined $rest ? $starter.$rest : $arg)
  		      unless defined $optarg;
  		    return (0);
  		}
  		warn ("Value \"", $arg, "\" invalid for option ",
  		      $opt, " (real number expected)\n");
  		$error++;
  		# Push back.
  		unshift (@$argv, $starter.$rest) if defined $rest;
  		return (1, undef);
  	    }
  	    else {
  		# Push back.
  		unshift (@$argv, defined $rest ? $starter.$rest : $arg);
  		# Supply default value.
  		$arg = 0.0;
  	    }
  	}
      }
      else {
  	die("Getopt::Long internal error (Can't happen)\n");
      }
      return (1, $opt, $ctl, $arg, $key);
  }
  
  sub ValidValue ($$$$$) {
      my ($ctl, $arg, $mand, $argend, $prefix) = @_;
  
      if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
  	return 0 unless $arg =~ /[^=]+=(.*)/;
  	$arg = $1;
      }
  
      my $type = $ctl->[CTL_TYPE];
  
      if ( $type eq 's' ) {	# string
  	# A mandatory string takes anything.
  	return (1) if $mand;
  
  	return (1) if $arg eq "-";
  
  	# Check for option or option list terminator.
  	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
  	return 1;
      }
  
      elsif ( $type eq 'i'	# numeric/integer
              || $type eq 'I'	# numeric/integer w/ incr default
  	    || $type eq 'o' ) { # dec/oct/hex/bin value
  
  	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
  	return $arg =~ /^$o_valid$/si;
      }
  
      elsif ( $type eq 'f' ) { # real number, int is also ok
  	my $o_valid = PAT_FLOAT;
  	return $arg =~ /^$o_valid$/;
      }
      die("ValidValue: Cannot happen\n");
  }
  
  # Getopt::Long Configuration.
  sub Configure (@) {
      my (@options) = @_;
  
      my $prevconfig =
        [ $error, $debug, $major_version, $minor_version, $caller,
  	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	$longprefix, $bundling_values ];
  
      if ( ref($options[0]) eq 'ARRAY' ) {
  	( $error, $debug, $major_version, $minor_version, $caller,
  	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
  	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
  	  $longprefix, $bundling_values ) = @{shift(@options)};
      }
  
      my $opt;
      foreach $opt ( @options ) {
  	my $try = lc ($opt);
  	my $action = 1;
  	if ( $try =~ /^no_?(.*)$/s ) {
  	    $action = 0;
  	    $try = $+;
  	}
  	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
  	    ConfigDefaults ();
  	}
  	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
  	    local $ENV{POSIXLY_CORRECT};
  	    $ENV{POSIXLY_CORRECT} = 1 if $action;
  	    ConfigDefaults ();
  	}
  	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
  	    $autoabbrev = $action;
  	}
  	elsif ( $try eq 'getopt_compat' ) {
  	    $getopt_compat = $action;
              $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
  	}
  	elsif ( $try eq 'gnu_getopt' ) {
  	    if ( $action ) {
  		$gnu_compat = 1;
  		$bundling = 1;
  		$getopt_compat = 0;
                  $genprefix = "(--|-)";
  		$order = $PERMUTE;
  		$bundling_values = 0;
  	    }
  	}
  	elsif ( $try eq 'gnu_compat' ) {
  	    $gnu_compat = $action;
  	    $bundling = 0;
  	    $bundling_values = 1;
  	}
  	elsif ( $try =~ /^(auto_?)?version$/ ) {
  	    $auto_version = $action;
  	}
  	elsif ( $try =~ /^(auto_?)?help$/ ) {
  	    $auto_help = $action;
  	}
  	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
  	    $ignorecase = $action;
  	}
  	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
  	    $ignorecase = $action ? 2 : 0;
  	}
  	elsif ( $try eq 'bundling' ) {
  	    $bundling = $action;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_override' ) {
  	    $bundling = $action ? 2 : 0;
  	    $bundling_values = 0 if $action;
  	}
  	elsif ( $try eq 'bundling_values' ) {
  	    $bundling_values = $action;
  	    $bundling = 0 if $action;
  	}
  	elsif ( $try eq 'require_order' ) {
  	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
  	}
  	elsif ( $try eq 'permute' ) {
  	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
  	}
  	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
  	    $passthrough = $action;
  	}
  	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Turn into regexp. Needs to be parenthesized!
  	    $genprefix = "(" . quotemeta($genprefix) . ")";
  	    eval { '' =~ /$genprefix/; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
  	    $genprefix = $1;
  	    # Parenthesize if needed.
  	    $genprefix = "(" . $genprefix . ")"
  	      unless $genprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$genprefix"; };
  	    die("Getopt::Long: invalid pattern \"$genprefix\"\n") if $@;
  	}
  	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
  	    $longprefix = $1;
  	    # Parenthesize if needed.
  	    $longprefix = "(" . $longprefix . ")"
  	      unless $longprefix =~ /^\(.*\)$/;
  	    eval { '' =~ m"$longprefix"; };
  	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"\n") if $@;
  	}
  	elsif ( $try eq 'debug' ) {
  	    $debug = $action;
  	}
  	else {
  	    die("Getopt::Long: unknown or erroneous config parameter \"$opt\"\n")
  	}
      }
      $prevconfig;
  }
  
  # Deprecated name.
  sub config (@) {
      Configure (@_);
  }
  
  # Issue a standard message for --version.
  #
  # The arguments are mostly the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub VersionMessage(@) {
      # Massage args.
      my $pa = setup_pa_args("version", @_);
  
      my $v = $main::VERSION;
      my $fh = $pa->{-output} ||
        ( ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR );
  
      print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
  	       $0, defined $v ? " version $v" : (),
  	       "\n",
  	       "(", __PACKAGE__, "::", "GetOptions",
  	       " version ",
  	       defined($Getopt::Long::VERSION_STRING)
  	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
  	       " Perl version ",
  	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
  	       ")\n");
      exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
  }
  
  # Issue a standard message for --help.
  #
  # The arguments are the same as for Pod::Usage::pod2usage:
  #
  #  - a number (exit value)
  #  - a string (lead in message)
  #  - a hash with options. See Pod::Usage for details.
  #
  sub HelpMessage(@) {
      eval {
  	require Pod::Usage;
  	import Pod::Usage;
  	1;
      } || die("Cannot provide help: cannot load Pod::Usage\n");
  
      # Note that pod2usage will issue a warning if -exitval => NOEXIT.
      pod2usage(setup_pa_args("help", @_));
  
  }
  
  # Helper routine to set up a normalized hash ref to be used as
  # argument to pod2usage.
  sub setup_pa_args($@) {
      my $tag = shift;		# who's calling
  
      # If called by direct binding to an option, it will get the option
      # name and value as arguments. Remove these, if so.
      @_ = () if @_ == 2 && $_[0] eq $tag;
  
      my $pa;
      if ( @_ > 1 ) {
  	$pa = { @_ };
      }
      else {
  	$pa = shift || {};
      }
  
      # At this point, $pa can be a number (exit value), string
      # (message) or hash with options.
  
      if ( UNIVERSAL::isa($pa, 'HASH') ) {
  	# Get rid of -msg vs. -message ambiguity.
  	$pa->{-message} = $pa->{-msg};
  	delete($pa->{-msg});
      }
      elsif ( $pa =~ /^-?\d+$/ ) {
  	$pa = { -exitval => $pa };
      }
      else {
  	$pa = { -message => $pa };
      }
  
      # These are _our_ defaults.
      $pa->{-verbose} = 0 unless exists($pa->{-verbose});
      $pa->{-exitval} = 0 unless exists($pa->{-exitval});
      $pa;
  }
  
  # Sneak way to know what version the user requested.
  sub VERSION {
      $requested_version = $_[1];
      shift->SUPER::VERSION(@_);
  }
  
  package Getopt::Long::CallBack;
  
  sub new {
      my ($pkg, %atts) = @_;
      bless { %atts }, $pkg;
  }
  
  sub name {
      my $self = shift;
      ''.$self->{name};
  }
  
  use overload
    # Treat this object as an ordinary string for legacy API.
    '""'	   => \&name,
    fallback => 1;
  
  1;
  
  ################ Documentation ################
  
  =head1 NAME
  
  Getopt::Long - Extended processing of command line options
  
  =head1 SYNOPSIS
  
    use Getopt::Long;
    my $data   = "file.dat";
    my $length = 24;
    my $verbose;
    GetOptions ("length=i" => \$length,    # numeric
                "file=s"   => \$data,      # string
                "verbose"  => \$verbose)   # flag
    or die("Error in command line arguments\n");
  
  =head1 DESCRIPTION
  
  The Getopt::Long module implements an extended getopt function called
  GetOptions(). It parses the command line from C<@ARGV>, recognizing
  and removing specified options and their possible values.
  
  This function adheres to the POSIX syntax for command
  line options, with GNU extensions. In general, this means that options
  have long names instead of single letters, and are introduced with a
  double dash "--". Support for bundling of command line options, as was
  the case with the more traditional single-letter approach, is provided
  but not enabled by default.
  
  =head1 Command Line Options, an Introduction
  
  Command line operated programs traditionally take their arguments from
  the command line, for example filenames or other information that the
  program needs to know. Besides arguments, these programs often take
  command line I<options> as well. Options are not necessary for the
  program to work, hence the name 'option', but are used to modify its
  default behaviour. For example, a program could do its job quietly,
  but with a suitable option it could provide verbose information about
  what it did.
  
  Command line options come in several flavours. Historically, they are
  preceded by a single dash C<->, and consist of a single letter.
  
      -l -a -c
  
  Usually, these single-character options can be bundled:
  
      -lac
  
  Options can have values, the value is placed after the option
  character. Sometimes with whitespace in between, sometimes not:
  
      -s 24 -s24
  
  Due to the very cryptic nature of these options, another style was
  developed that used long names. So instead of a cryptic C<-l> one
  could use the more descriptive C<--long>. To distinguish between a
  bundle of single-character options and a long one, two dashes are used
  to precede the option name. Early implementations of long options used
  a plus C<+> instead. Also, option values could be specified either
  like
  
      --size=24
  
  or
  
      --size 24
  
  The C<+> form is now obsolete and strongly deprecated.
  
  =head1 Getting Started with Getopt::Long
  
  Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
  first Perl module that provided support for handling the new style of
  command line options, in particular long option names, hence the Perl5
  name Getopt::Long. This module also supports single-character options
  and bundling.
  
  To use Getopt::Long from a Perl program, you must include the
  following line in your Perl program:
  
      use Getopt::Long;
  
  This will load the core of the Getopt::Long module and prepare your
  program for using it. Most of the actual Getopt::Long code is not
  loaded until you really call one of its functions.
  
  In the default configuration, options names may be abbreviated to
  uniqueness, case does not matter, and a single dash is sufficient,
  even for long option names. Also, options may be placed between
  non-option arguments. See L<Configuring Getopt::Long> for more
  details on how to configure Getopt::Long.
  
  =head2 Simple options
  
  The most simple options are the ones that take no values. Their mere
  presence on the command line enables the option. Popular examples are:
  
      --all --verbose --quiet --debug
  
  Handling simple options is straightforward:
  
      my $verbose = '';	# option variable with default value (false)
      my $all = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose, 'all' => \$all);
  
  The call to GetOptions() parses the command line arguments that are
  present in C<@ARGV> and sets the option variable to the value C<1> if
  the option did occur on the command line. Otherwise, the option
  variable is not touched. Setting the option value to true is often
  called I<enabling> the option.
  
  The option name as specified to the GetOptions() function is called
  the option I<specification>. Later we'll see that this specification
  can contain more than just the option name. The reference to the
  variable is called the option I<destination>.
  
  GetOptions() will return a true value if the command line could be
  processed successfully. Otherwise, it will write error messages using
  die() and warn(), and return a false result.
  
  =head2 A little bit less simple options
  
  Getopt::Long supports two useful variants of simple options:
  I<negatable> options and I<incremental> options.
  
  A negatable option is specified with an exclamation mark C<!> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose!' => \$verbose);
  
  Now, using C<--verbose> on the command line will enable C<$verbose>,
  as expected. But it is also allowed to use C<--noverbose>, which will
  disable C<$verbose> by setting its value to C<0>. Using a suitable
  default value, the program can find out whether C<$verbose> is false
  by default, or disabled by using C<--noverbose>.
  
  An incremental option is specified with a plus C<+> after the
  option name:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose+' => \$verbose);
  
  Using C<--verbose> on the command line will increment the value of
  C<$verbose>. This way the program can keep track of how many times the
  option occurred on the command line. For example, each occurrence of
  C<--verbose> could increase the verbosity level of the program.
  
  =head2 Mixing command line option with other arguments
  
  Usually programs take command line options as well as other arguments,
  for example, file names. It is good practice to always specify the
  options first, and the other arguments last. Getopt::Long will,
  however, allow the options and arguments to be mixed and 'filter out'
  all the options before passing the rest of the arguments to the
  program. To stop Getopt::Long from processing further arguments,
  insert a double dash C<--> on the command line:
  
      --size 24 -- --all
  
  In this example, C<--all> will I<not> be treated as an option, but
  passed to the program unharmed, in C<@ARGV>.
  
  =head2 Options with values
  
  For options that take values it must be specified whether the option
  value is required or not, and what kind of value the option expects.
  
  Three kinds of values are supported: integer numbers, floating point
  numbers, and strings.
  
  If the option value is required, Getopt::Long will take the
  command line argument that follows the option and assign this to the
  option variable. If, however, the option value is specified as
  optional, this will only be done if that value does not look like a
  valid command line option itself.
  
      my $tag = '';	# option variable with default value
      GetOptions ('tag=s' => \$tag);
  
  In the option specification, the option name is followed by an equals
  sign C<=> and the letter C<s>. The equals sign indicates that this
  option requires a value. The letter C<s> indicates that this value is
  an arbitrary string. Other possible value types are C<i> for integer
  values, and C<f> for floating point values. Using a colon C<:> instead
  of the equals sign indicates that the option value is optional. In
  this case, if no suitable value is supplied, string valued options get
  an empty string C<''> assigned, while numeric options are set to C<0>.
  
  =head2 Options with multiple values
  
  Options sometimes take several values. For example, a program could
  use multiple directories to search for library files:
  
      --library lib/stdlib --library lib/extlib
  
  To accomplish this behaviour, simply specify an array reference as the
  destination for the option:
  
      GetOptions ("library=s" => \@libfiles);
  
  Alternatively, you can specify that the option can have multiple
  values by adding a "@", and pass a reference to a scalar as the
  destination:
  
      GetOptions ("library=s@" => \$libfiles);
  
  Used with the example above, C<@libfiles> c.q. C<@$libfiles> would
  contain two strings upon completion: C<"lib/stdlib"> and
  C<"lib/extlib">, in that order. It is also possible to specify that
  only integer or floating point numbers are acceptable values.
  
  Often it is useful to allow comma-separated lists of values as well as
  multiple occurrences of the options. This is easy using Perl's split()
  and join() operators:
  
      GetOptions ("library=s" => \@libfiles);
      @libfiles = split(/,/,join(',',@libfiles));
  
  Of course, it is important to choose the right separator string for
  each purpose.
  
  Warning: What follows is an experimental feature.
  
  Options can take multiple values at once, for example
  
      --coordinates 52.2 16.4 --rgbcolor 255 255 149
  
  This can be accomplished by adding a repeat specifier to the option
  specification. Repeat specifiers are very similar to the C<{...}>
  repeat specifiers that can be used with regular expression patterns.
  For example, the above command line would be handled as follows:
  
      GetOptions('coordinates=f{2}' => \@coor, 'rgbcolor=i{3}' => \@color);
  
  The destination for the option must be an array or array reference.
  
  It is also possible to specify the minimal and maximal number of
  arguments an option takes. C<foo=s{2,4}> indicates an option that
  takes at least two and at most 4 arguments. C<foo=s{1,}> indicates one
  or more values; C<foo:s{,}> indicates zero or more option values.
  
  =head2 Options with hash values
  
  If the option destination is a reference to a hash, the option will
  take, as value, strings of the form I<key>C<=>I<value>. The value will
  be stored with the specified key in the hash.
  
      GetOptions ("define=s" => \%defines);
  
  Alternatively you can use:
  
      GetOptions ("define=s%" => \$defines);
  
  When used with command line options:
  
      --define os=linux --define vendor=redhat
  
  the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
  with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
  also possible to specify that only integer or floating point numbers
  are acceptable values. The keys are always taken to be strings.
  
  =head2 User-defined subroutines to handle options
  
  Ultimate control over what should be done when (actually: each time)
  an option is encountered on the command line can be achieved by
  designating a reference to a subroutine (or an anonymous subroutine)
  as the option destination. When GetOptions() encounters the option, it
  will call the subroutine with two or three arguments. The first
  argument is the name of the option. (Actually, it is an object that
  stringifies to the name of the option.) For a scalar or array destination,
  the second argument is the value to be stored. For a hash destination,
  the second argument is the key to the hash, and the third argument
  the value to be stored. It is up to the subroutine to store the value,
  or do whatever it thinks is appropriate.
  
  A trivial application of this mechanism is to implement options that
  are related to each other. For example:
  
      my $verbose = '';	# option variable with default value (false)
      GetOptions ('verbose' => \$verbose,
  	        'quiet'   => sub { $verbose = 0 });
  
  Here C<--verbose> and C<--quiet> control the same variable
  C<$verbose>, but with opposite values.
  
  If the subroutine needs to signal an error, it should call die() with
  the desired error message as its argument. GetOptions() will catch the
  die(), issue the error message, and record that an error result must
  be returned upon completion.
  
  If the text of the error message starts with an exclamation mark C<!>
  it is interpreted specially by GetOptions(). There is currently one
  special command implemented: C<die("!FINISH")> will cause GetOptions()
  to stop processing options, as if it encountered a double dash C<-->.
  
  In version 2.37 the first argument to the callback function was
  changed from string to object. This was done to make room for
  extensions and more detailed control. The object stringifies to the
  option name so this change should not introduce compatibility
  problems.
  
  Here is an example of how to access the option name and value from within
  a subroutine:
  
      GetOptions ('opt=i' => \&handler);
      sub handler {
          my ($opt_name, $opt_value) = @_;
          print("Option name is $opt_name and value is $opt_value\n");
      }
  
  =head2 Options with multiple names
  
  Often it is user friendly to supply alternate mnemonic names for
  options. For example C<--height> could be an alternate name for
  C<--length>. Alternate names can be included in the option
  specification, separated by vertical bar C<|> characters. To implement
  the above example:
  
      GetOptions ('length|height=f' => \$length);
  
  The first name is called the I<primary> name, the other names are
  called I<aliases>. When using a hash to store options, the key will
  always be the primary name.
  
  Multiple alternate names are possible.
  
  =head2 Case and abbreviations
  
  Without additional configuration, GetOptions() will ignore the case of
  option names, and allow the options to be abbreviated to uniqueness.
  
      GetOptions ('length|height=f' => \$length, "head" => \$head);
  
  This call will allow C<--l> and C<--L> for the length option, but
  requires a least C<--hea> and C<--hei> for the head and height options.
  
  =head2 Summary of Option Specifications
  
  Each option specifier consists of two parts: the name specification
  and the argument specification.
  
  The name specification contains the name of the option, optionally
  followed by a list of alternative names separated by vertical bar
  characters.
  
      length	      option name is "length"
      length|size|l     name is "length", aliases are "size" and "l"
  
  The argument specification is optional. If omitted, the option is
  considered boolean, a value of 1 will be assigned when the option is
  used on the command line.
  
  The argument specification can be
  
  =over 4
  
  =item !
  
  The option does not take an argument and may be negated by prefixing
  it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
  1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
  0 will be assigned). If the option has aliases, this applies to the
  aliases as well.
  
  Using negation on a single letter option when bundling is in effect is
  pointless and will result in a warning.
  
  =item +
  
  The option does not take an argument and will be incremented by 1
  every time it appears on the command line. E.g. C<"more+">, when used
  with C<--more --more --more>, will increment the value three times,
  resulting in a value of 3 (provided it was 0 or undefined at first).
  
  The C<+> specifier is ignored if the option destination is not a scalar.
  
  =item = I<type> [ I<desttype> ] [ I<repeat> ]
  
  The option requires an argument of the given type. Supported types
  are:
  
  =over 4
  
  =item s
  
  String. An arbitrary sequence of characters. It is valid for the
  argument to start with C<-> or C<-->.
  
  =item i
  
  Integer. An optional leading plus or minus sign, followed by a
  sequence of digits.
  
  =item o
  
  Extended integer, Perl style. This can be either an optional leading
  plus or minus sign, followed by a sequence of digits, or an octal
  string (a zero, optionally followed by '0', '1', .. '7'), or a
  hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
  insensitive), or a binary string (C<0b> followed by a series of '0'
  and '1').
  
  =item f
  
  Real number. For example C<3.14>, C<-6.23E24> and so on.
  
  =back
  
  The I<desttype> can be C<@> or C<%> to specify that the option is
  list or a hash valued. This is only needed when the destination for
  the option value is not otherwise specified. It should be omitted when
  not needed.
  
  The I<repeat> specifies the number of values this option takes per
  occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.
  
  I<min> denotes the minimal number of arguments. It defaults to 1 for
  options with C<=> and to 0 for options with C<:>, see below. Note that
  I<min> overrules the C<=> / C<:> semantics.
  
  I<max> denotes the maximum number of arguments. It must be at least
  I<min>. If I<max> is omitted, I<but the comma is not>, there is no
  upper bound to the number of argument values taken.
  
  =item : I<type> [ I<desttype> ]
  
  Like C<=>, but designates the argument as optional.
  If omitted, an empty string will be assigned to string values options,
  and the value zero to numeric options.
  
  Note that if a string argument starts with C<-> or C<-->, it will be
  considered an option on itself.
  
  =item : I<number> [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the I<number> will be assigned.
  
  =item : + [ I<desttype> ]
  
  Like C<:i>, but if the value is omitted, the current value for the
  option will be incremented.
  
  =back
  
  =head1 Advanced Possibilities
  
  =head2 Object oriented interface
  
  Getopt::Long can be used in an object oriented way as well:
  
      use Getopt::Long;
      $p = Getopt::Long::Parser->new;
      $p->configure(...configuration options...);
      if ($p->getoptions(...options descriptions...)) ...
      if ($p->getoptionsfromarray( \@array, ...options descriptions...)) ...
  
  Configuration options can be passed to the constructor:
  
      $p = new Getopt::Long::Parser
               config => [...configuration options...];
  
  =head2 Thread Safety
  
  Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
  I<not> thread safe when using the older (experimental and now
  obsolete) threads implementation that was added to Perl 5.005.
  
  =head2 Documentation and help texts
  
  Getopt::Long encourages the use of Pod::Usage to produce help
  messages. For example:
  
      use Getopt::Long;
      use Pod::Usage;
  
      my $man = 0;
      my $help = 0;
  
      GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
      pod2usage(1) if $help;
      pod2usage(-exitval => 0, -verbose => 2) if $man;
  
      __END__
  
      =head1 NAME
  
      sample - Using Getopt::Long and Pod::Usage
  
      =head1 SYNOPSIS
  
      sample [options] [file ...]
  
       Options:
         -help            brief help message
         -man             full documentation
  
      =head1 OPTIONS
  
      =over 8
  
      =item B<-help>
  
      Print a brief help message and exits.
  
      =item B<-man>
  
      Prints the manual page and exits.
  
      =back
  
      =head1 DESCRIPTION
  
      B<This program> will read the given input file(s) and do something
      useful with the contents thereof.
  
      =cut
  
  See L<Pod::Usage> for details.
  
  =head2 Parsing options from an arbitrary array
  
  By default, GetOptions parses the options that are present in the
  global array C<@ARGV>. A special entry C<GetOptionsFromArray> can be
  used to parse options from an arbitrary array.
  
      use Getopt::Long qw(GetOptionsFromArray);
      $ret = GetOptionsFromArray(\@myopts, ...);
  
  When used like this, options and their possible values are removed
  from C<@myopts>, the global C<@ARGV> is not touched at all.
  
  The following two calls behave identically:
  
      $ret = GetOptions( ... );
      $ret = GetOptionsFromArray(\@ARGV, ... );
  
  This also means that a first argument hash reference now becomes the
  second argument:
  
      $ret = GetOptions(\%opts, ... );
      $ret = GetOptionsFromArray(\@ARGV, \%opts, ... );
  
  =head2 Parsing options from an arbitrary string
  
  A special entry C<GetOptionsFromString> can be used to parse options
  from an arbitrary string.
  
      use Getopt::Long qw(GetOptionsFromString);
      $ret = GetOptionsFromString($string, ...);
  
  The contents of the string are split into arguments using a call to
  C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
  global C<@ARGV> is not touched.
  
  It is possible that, upon completion, not all arguments in the string
  have been processed. C<GetOptionsFromString> will, when called in list
  context, return both the return status and an array reference to any
  remaining arguments:
  
      ($ret, $args) = GetOptionsFromString($string, ... );
  
  If any arguments remain, and C<GetOptionsFromString> was not called in
  list context, a message will be given and C<GetOptionsFromString> will
  return failure.
  
  As with GetOptionsFromArray, a first argument hash reference now
  becomes the second argument.
  
  =head2 Storing options values in a hash
  
  Sometimes, for example when there are a lot of options, having a
  separate variable for each of them can be cumbersome. GetOptions()
  supports, as an alternative mechanism, storing options values in a
  hash.
  
  To obtain this, a reference to a hash must be passed I<as the first
  argument> to GetOptions(). For each option that is specified on the
  command line, the option value will be stored in the hash with the
  option name as key. Options that are not actually used on the command
  line will not be put in the hash, on other words,
  C<exists($h{option})> (or defined()) can be used to test if an option
  was used. The drawback is that warnings will be issued if the program
  runs under C<use strict> and uses C<$h{option}> without testing with
  exists() or defined() first.
  
      my %h = ();
      GetOptions (\%h, 'length=i');	# will store in $h{length}
  
  For options that take list or hash values, it is necessary to indicate
  this by appending an C<@> or C<%> sign after the type:
  
      GetOptions (\%h, 'colours=s@');	# will push to @{$h{colours}}
  
  To make things more complicated, the hash may contain references to
  the actual destinations, for example:
  
      my $len = 0;
      my %h = ('length' => \$len);
      GetOptions (\%h, 'length=i');	# will store in $len
  
  This example is fully equivalent with:
  
      my $len = 0;
      GetOptions ('length=i' => \$len);	# will store in $len
  
  Any mixture is possible. For example, the most frequently used options
  could be stored in variables while all other options get stored in the
  hash:
  
      my $verbose = 0;			# frequently referred
      my $debug = 0;			# frequently referred
      my %h = ('verbose' => \$verbose, 'debug' => \$debug);
      GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
      if ( $verbose ) { ... }
      if ( exists $h{filter} ) { ... option 'filter' was specified ... }
  
  =head2 Bundling
  
  With bundling it is possible to set several single-character options
  at once. For example if C<a>, C<v> and C<x> are all valid options,
  
      -vax
  
  will set all three.
  
  Getopt::Long supports three styles of bundling. To enable bundling, a
  call to Getopt::Long::Configure is required.
  
  The simplest style of bundling can be enabled with:
  
      Getopt::Long::Configure ("bundling");
  
  Configured this way, single-character options can be bundled but long
  options B<must> always start with a double dash C<--> to avoid
  ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
  options,
  
      -vax
  
  will set C<a>, C<v> and C<x>, but
  
      --vax
  
  will set C<vax>.
  
  The second style of bundling lifts this restriction. It can be enabled
  with:
  
      Getopt::Long::Configure ("bundling_override");
  
  Now, C<-vax> will set the option C<vax>.
  
  In all of the above cases, option values may be inserted in the
  bundle. For example:
  
      -h24w80
  
  is equivalent to
  
      -h 24 -w 80
  
  A third style of bundling allows only values to be bundled with
  options. It can be enabled with:
  
      Getopt::Long::Configure ("bundling_values");
  
  Now, C<-h24> will set the option C<h> to C<24>, but option bundles
  like C<-vxa> and C<-h24w80> are flagged as errors.
  
  Enabling C<bundling_values> will disable the other two styles of
  bundling.
  
  When configured for bundling, single-character options are matched
  case sensitive while long options are matched case insensitive. To
  have the single-character options matched case insensitive as well,
  use:
  
      Getopt::Long::Configure ("bundling", "ignorecase_always");
  
  It goes without saying that bundling can be quite confusing.
  
  =head2 The lonesome dash
  
  Normally, a lone dash C<-> on the command line will not be considered
  an option. Option processing will terminate (unless "permute" is
  configured) and the dash will be left in C<@ARGV>.
  
  It is possible to get special treatment for a lone dash. This can be
  achieved by adding an option specification with an empty name, for
  example:
  
      GetOptions ('' => \$stdio);
  
  A lone dash on the command line will now be a legal option, and using
  it will set variable C<$stdio>.
  
  =head2 Argument callback
  
  A special option 'name' C<< <> >> can be used to designate a subroutine
  to handle non-option arguments. When GetOptions() encounters an
  argument that does not look like an option, it will immediately call this
  subroutine and passes it one parameter: the argument name. Well, actually
  it is an object that stringifies to the argument name.
  
  For example:
  
      my $width = 80;
      sub process { ... }
      GetOptions ('width=i' => \$width, '<>' => \&process);
  
  When applied to the following command line:
  
      arg1 --width=72 arg2 --width=60 arg3
  
  This will call
  C<process("arg1")> while C<$width> is C<80>,
  C<process("arg2")> while C<$width> is C<72>, and
  C<process("arg3")> while C<$width> is C<60>.
  
  This feature requires configuration option B<permute>, see section
  L<Configuring Getopt::Long>.
  
  =head1 Configuring Getopt::Long
  
  Getopt::Long can be configured by calling subroutine
  Getopt::Long::Configure(). This subroutine takes a list of quoted
  strings, each specifying a configuration option to be enabled, e.g.
  C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
  matter. Multiple calls to Configure() are possible.
  
  Alternatively, as of version 2.24, the configuration options may be
  passed together with the C<use> statement:
  
      use Getopt::Long qw(:config no_ignore_case bundling);
  
  The following options are available:
  
  =over 12
  
  =item default
  
  This option causes all configuration options to be reset to their
  default values.
  
  =item posix_default
  
  This option causes all configuration options to be reset to their
  default values as if the environment variable POSIXLY_CORRECT had
  been set.
  
  =item auto_abbrev
  
  Allow option names to be abbreviated to uniqueness.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
  
  =item getopt_compat
  
  Allow C<+> to start options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.
  
  =item gnu_compat
  
  C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
  do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
  C<--opt=> will give option C<opt> and empty value.
  This is the way GNU getopt_long() does it.
  
  Note that C<--opt value> is still accepted, even though GNU
  getopt_long() doesn't.
  
  =item gnu_getopt
  
  This is a short way of setting C<gnu_compat> C<bundling> C<permute>
  C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
  reasonably compatible with GNU getopt_long().
  
  =item require_order
  
  Whether command line arguments are allowed to be mixed with options.
  Default is disabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
  
  See also C<permute>, which is the opposite of C<require_order>.
  
  =item permute
  
  Whether command line arguments are allowed to be mixed with options.
  Default is enabled unless environment variable
  POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
  Note that C<permute> is the opposite of C<require_order>.
  
  If C<permute> is enabled, this means that
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo --bar arg1 arg2 arg3
  
  If an argument callback routine is specified, C<@ARGV> will always be
  empty upon successful return of GetOptions() since all options have been
  processed. The only exception is when C<--> is used:
  
      --foo arg1 --bar arg2 -- arg3
  
  This will call the callback routine for arg1 and arg2, and then
  terminate GetOptions() leaving C<"arg3"> in C<@ARGV>.
  
  If C<require_order> is enabled, options processing
  terminates when the first non-option is encountered.
  
      --foo arg1 --bar arg2 arg3
  
  is equivalent to
  
      --foo -- arg1 --bar arg2 arg3
  
  If C<pass_through> is also enabled, options processing will terminate
  at the first unrecognized option, or non-option, whichever comes
  first.
  
  =item bundling (default: disabled)
  
  Enabling this option will allow single-character options to be
  bundled. To distinguish bundles from long option names, long options
  I<must> be introduced with C<--> and bundles with C<->.
  
  Note that, if you have options C<a>, C<l> and C<all>, and
  auto_abbrev enabled, possible arguments and option settings are:
  
      using argument               sets option(s)
      ------------------------------------------
      -a, --a                      a
      -l, --l                      l
      -al, -la, -ala, -all,...     a, l
      --al, --all                  all
  
  The surprising part is that C<--a> sets option C<a> (due to auto
  completion), not C<all>.
  
  Note: disabling C<bundling> also disables C<bundling_override>.
  
  =item bundling_override (default: disabled)
  
  If C<bundling_override> is enabled, bundling is enabled as with
  C<bundling> but now long option names override option bundles.
  
  Note: disabling C<bundling_override> also disables C<bundling>.
  
  B<Note:> Using option bundling can easily lead to unexpected results,
  especially when mixing long options and bundles. Caveat emptor.
  
  =item ignore_case  (default: enabled)
  
  If enabled, case is ignored when matching option names. If, however,
  bundling is enabled as well, single character options will be treated
  case-sensitive.
  
  With C<ignore_case>, option specifications for options that only
  differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
  duplicates.
  
  Note: disabling C<ignore_case> also disables C<ignore_case_always>.
  
  =item ignore_case_always (default: disabled)
  
  When bundling is in effect, case is ignored on single-character
  options also.
  
  Note: disabling C<ignore_case_always> also disables C<ignore_case>.
  
  =item auto_version (default:disabled)
  
  Automatically provide support for the B<--version> option if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a standard version message that includes the
  program name, its version (if $main::VERSION is defined), and the
  versions of Getopt::Long and Perl. The message will be written to
  standard output and processing will terminate.
  
  C<auto_version> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item auto_help (default:disabled)
  
  Automatically provide support for the B<--help> and B<-?> options if
  the application did not specify a handler for this option itself.
  
  Getopt::Long will provide a help message using module L<Pod::Usage>. The
  message, derived from the SYNOPSIS POD section, will be written to
  standard output and processing will terminate.
  
  C<auto_help> will be enabled if the calling program explicitly
  specified a version number higher than 2.32 in the C<use> or
  C<require> statement.
  
  =item pass_through (default: disabled)
  
  With C<pass_through> anything that is unknown, ambiguous or supplied with
  an invalid option will not be flagged as an error. Instead the unknown
  option(s) will be passed to the catchall C<< <> >> if present, otherwise
  through to C<@ARGV>. This makes it possible to write wrapper scripts that
  process only part of the user supplied command line arguments, and pass the
  remaining options to some other program.
  
  If C<require_order> is enabled, options processing will terminate at the
  first unrecognized option, or non-option, whichever comes first and all
  remaining arguments are passed to C<@ARGV> instead of the catchall
  C<< <> >> if present.  However, if C<permute> is enabled instead, results
  can become confusing.
  
  Note that the options terminator (default C<-->), if present, will
  also be passed through in C<@ARGV>.
  
  =item prefix
  
  The string that starts options. If a constant string is not
  sufficient, see C<prefix_pattern>.
  
  =item prefix_pattern
  
  A Perl pattern that identifies the strings that introduce options.
  Default is C<--|-|\+> unless environment variable
  POSIXLY_CORRECT has been set, in which case it is C<--|->.
  
  =item long_prefix_pattern
  
  A Perl pattern that allows the disambiguation of long and short
  prefixes. Default is C<-->.
  
  Typically you only need to set this if you are using nonstandard
  prefixes and want some or all of them to have the same semantics as
  '--' does under normal circumstances.
  
  For example, setting prefix_pattern to C<--|-|\+|\/> and
  long_prefix_pattern to C<--|\/> would add Win32 style argument
  handling.
  
  =item debug (default: disabled)
  
  Enable debugging output.
  
  =back
  
  =head1 Exportable Methods
  
  =over
  
  =item VersionMessage
  
  This subroutine provides a standard version message. Its argument can be:
  
  =over 4
  
  =item *
  
  A string containing the text of a message to print I<before> printing
  the standard message.
  
  =item *
  
  A numeric value corresponding to the desired exit status.
  
  =item *
  
  A reference to a hash.
  
  =back
  
  If more than one argument is given then the entire argument list is
  assumed to be a hash.  If a hash is supplied (either as a reference or
  as a list) it should contain one or more elements with the following
  keys:
  
  =over 4
  
  =item C<-message>
  
  =item C<-msg>
  
  The text of a message to print immediately prior to printing the
  program's usage message.
  
  =item C<-exitval>
  
  The desired exit status to pass to the B<exit()> function.
  This should be an integer, or else the string "NOEXIT" to
  indicate that control should simply be returned without
  terminating the invoking process.
  
  =item C<-output>
  
  A reference to a filehandle, or the pathname of a file to which the
  usage message should be written. The default is C<\*STDERR> unless the
  exit value is less than 2 (in which case the default is C<\*STDOUT>).
  
  =back
  
  You cannot tie this routine directly to an option, e.g.:
  
      GetOptions("version" => \&VersionMessage);
  
  Use this instead:
  
      GetOptions("version" => sub { VersionMessage() });
  
  =item HelpMessage
  
  This subroutine produces a standard help message, derived from the
  program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
  arguments as VersionMessage(). In particular, you cannot tie it
  directly to an option, e.g.:
  
      GetOptions("help" => \&HelpMessage);
  
  Use this instead:
  
      GetOptions("help" => sub { HelpMessage() });
  
  =back
  
  =head1 Return values and Errors
  
  Configuration errors and errors in the option definitions are
  signalled using die() and will terminate the calling program unless
  the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
  }>, or die() was trapped using C<$SIG{__DIE__}>.
  
  GetOptions returns true to indicate success.
  It returns false when the function detected one or more errors during
  option parsing. These errors are signalled using warn() and can be
  trapped with C<$SIG{__WARN__}>.
  
  =head1 Legacy
  
  The earliest development of C<newgetopt.pl> started in 1990, with Perl
  version 4. As a result, its development, and the development of
  Getopt::Long, has gone through several stages. Since backward
  compatibility has always been extremely important, the current version
  of Getopt::Long still supports a lot of constructs that nowadays are
  no longer necessary or otherwise unwanted. This section describes
  briefly some of these 'features'.
  
  =head2 Default destinations
  
  When no destination is specified for an option, GetOptions will store
  the resultant value in a global variable named C<opt_>I<XXX>, where
  I<XXX> is the primary name of this option. When a program executes
  under C<use strict> (recommended), these variables must be
  pre-declared with our() or C<use vars>.
  
      our $opt_length = 0;
      GetOptions ('length=i');	# will store in $opt_length
  
  To yield a usable Perl variable, characters that are not part of the
  syntax for variables are translated to underscores. For example,
  C<--fpp-struct-return> will set the variable
  C<$opt_fpp_struct_return>. Note that this variable resides in the
  namespace of the calling program, not necessarily C<main>. For
  example:
  
      GetOptions ("size=i", "sizes=i@");
  
  with command line "-size 10 -sizes 24 -sizes 48" will perform the
  equivalent of the assignments
  
      $opt_size = 10;
      @opt_sizes = (24, 48);
  
  =head2 Alternative option starters
  
  A string of alternative option starter characters may be passed as the
  first argument (or the first argument after a leading hash reference
  argument).
  
      my $len = 0;
      GetOptions ('/', 'length=i' => $len);
  
  Now the command line may look like:
  
      /length 24 -- arg
  
  Note that to terminate options processing still requires a double dash
  C<-->.
  
  GetOptions() will not interpret a leading C<< "<>" >> as option starters
  if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
  option starters, use C<< "><" >>. Confusing? Well, B<using a starter
  argument is strongly deprecated> anyway.
  
  =head2 Configuration variables
  
  Previous versions of Getopt::Long used variables for the purpose of
  configuring. Although manipulating these variables still work, it is
  strongly encouraged to use the C<Configure> routine that was introduced
  in version 2.17. Besides, it is much easier.
  
  =head1 Tips and Techniques
  
  =head2 Pushing multiple values in a hash option
  
  Sometimes you want to combine the best of hashes and arrays. For
  example, the command line:
  
    --list add=first --list add=second --list add=third
  
  where each successive 'list add' option will push the value of add
  into array ref $list->{'add'}. The result would be like
  
    $list->{add} = [qw(first second third)];
  
  This can be accomplished with a destination routine:
  
    GetOptions('list=s%' =>
                 sub { push(@{$list{$_[1]}}, $_[2]) });
  
  =head1 Troubleshooting
  
  =head2 GetOptions does not return a false result when an option is not supplied
  
  That's why they're called 'options'.
  
  =head2 GetOptions does not split the command line correctly
  
  The command line is not split by GetOptions, but by the command line
  interpreter (CLI). On Unix, this is the shell. On Windows, it is
  COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
  
  It is important to know that these CLIs may behave different when the
  command line contains special characters, in particular quotes or
  backslashes. For example, with Unix shells you can use single quotes
  (C<'>) and double quotes (C<">) to group words together. The following
  alternatives are equivalent on Unix:
  
      "two words"
      'two words'
      two\ words
  
  In case of doubt, insert the following statement in front of your Perl
  program:
  
      print STDERR (join("|",@ARGV),"\n");
  
  to verify how your CLI passes the arguments to the program.
  
  =head2 Undefined subroutine &main::GetOptions called
  
  Are you running Windows, and did you write
  
      use GetOpt::Long;
  
  (note the capital 'O')?
  
  =head2 How do I put a "-?" option into a Getopt::Long?
  
  You can only obtain this using an alias, and Getopt::Long of at least
  version 2.13.
  
      use Getopt::Long;
      GetOptions ("help|?");    # -help and -? will both set $opt_help
  
  Other characters that can't appear in Perl identifiers are also supported
  as aliases with Getopt::Long of at least version 2.39.
  
  As of version 2.32 Getopt::Long provides auto-help, a quick and easy way
  to add the options --help and -? to your program, and handle them.
  
  See C<auto_help> in section L<Configuring Getopt::Long>.
  
  =head1 AUTHOR
  
  Johan Vromans <jvromans@squirrel.nl>
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  This program is Copyright 1990,2015 by Johan Vromans.
  This program is free software; you can redistribute it and/or
  modify it under the terms of the Perl Artistic License or the
  GNU General Public License as published by the Free Software
  Foundation; either version 2 of the License, or (at your option) any
  later version.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  If you do not have a copy of the GNU General Public License write to
  the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
  MA 02139, USA.
  
  =cut
  
GETOPT_LONG

$fatpacked{"HTTP/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINY';
  # vim: ts=4 sts=4 sw=4 et:
  package HTTP::Tiny;
  use strict;
  use warnings;
  # ABSTRACT: A small, simple, correct HTTP/1.1 client
  
  our $VERSION = '0.058';
  
  use Carp ();
  
  #pod =method new
  #pod
  #pod     $http = HTTP::Tiny->new( %attributes );
  #pod
  #pod This constructor returns a new HTTP::Tiny object.  Valid attributes include:
  #pod
  #pod =for :list
  #pod * C<agent> — A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If
  #pod   C<agent> — ends in a space character, the default user-agent string is
  #pod   appended.
  #pod * C<cookie_jar> — An instance of L<HTTP::CookieJar> — or equivalent class
  #pod   that supports the C<add> and C<cookie_header> methods
  #pod * C<default_headers> — A hashref of default headers to apply to requests
  #pod * C<local_address> — The local IP address to bind to
  #pod * C<keep_alive> — Whether to reuse the last connection (if for the same
  #pod   scheme, host and port) (defaults to 1)
  #pod * C<max_redirect> — Maximum number of redirects allowed (defaults to 5)
  #pod * C<max_size> — Maximum response size in bytes (only when not using a data
  #pod   callback).  If defined, responses larger than this will return an
  #pod   exception.
  #pod * C<http_proxy> — URL of a proxy server to use for HTTP connections
  #pod   (default is C<$ENV{http_proxy}> — if set)
  #pod * C<https_proxy> — URL of a proxy server to use for HTTPS connections
  #pod   (default is C<$ENV{https_proxy}> — if set)
  #pod * C<proxy> — URL of a generic proxy server for both HTTP and HTTPS
  #pod   connections (default is C<$ENV{all_proxy}> — if set)
  #pod * C<no_proxy> — List of domain suffixes that should not be proxied.  Must
  #pod   be a comma-separated string or an array reference. (default is
  #pod   C<$ENV{no_proxy}> —)
  #pod * C<timeout> — Request timeout in seconds (default is 60) If a socket open,
  #pod   read or write takes longer than the timeout, an exception is thrown.
  #pod * C<verify_SSL> — A boolean that indicates whether to validate the SSL
  #pod   certificate of an C<https> — connection (default is false)
  #pod * C<SSL_options> — A hashref of C<SSL_*> — options to pass through to
  #pod   L<IO::Socket::SSL>
  #pod
  #pod Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
  #pod prevent getting the corresponding proxies from the environment.
  #pod
  #pod Exceptions from C<max_size>, C<timeout> or other errors will result in a
  #pod pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
  #pod content field in the response will contain the text of the exception.
  #pod
  #pod The C<keep_alive> parameter enables a persistent connection, but only to a
  #pod single destination scheme, host and port.  Also, if any connection-relevant
  #pod attributes are modified, or if the process ID or thread ID change, the
  #pod persistent connection will be dropped.  If you want persistent connections
  #pod across multiple destinations, use multiple HTTP::Tiny objects.
  #pod
  #pod See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
  #pod
  #pod =cut
  
  my @attributes;
  BEGIN {
      @attributes = qw(
          cookie_jar default_headers http_proxy https_proxy keep_alive
          local_address max_redirect max_size proxy no_proxy
          SSL_options verify_SSL
      );
      my %persist_ok = map {; $_ => 1 } qw(
          cookie_jar default_headers max_redirect max_size
      );
      no strict 'refs';
      no warnings 'uninitialized';
      for my $accessor ( @attributes ) {
          *{$accessor} = sub {
              @_ > 1
                  ? do {
                      delete $_[0]->{handle} if !$persist_ok{$accessor} && $_[1] ne $_[0]->{$accessor};
                      $_[0]->{$accessor} = $_[1]
                  }
                  : $_[0]->{$accessor};
          };
      }
  }
  
  sub agent {
      my($self, $agent) = @_;
      if( @_ > 1 ){
          $self->{agent} =
              (defined $agent && $agent =~ / $/) ? $agent . $self->_agent : $agent;
      }
      return $self->{agent};
  }
  
  sub timeout {
      my ($self, $timeout) = @_;
      if ( @_ > 1 ) {
          $self->{timeout} = $timeout;
          if ($self->{handle}) {
              $self->{handle}->timeout($timeout);
          }
      }
      return $self->{timeout};
  }
  
  sub new {
      my($class, %args) = @_;
  
      my $self = {
          max_redirect => 5,
          timeout      => 60,
          keep_alive   => 1,
          verify_SSL   => $args{verify_SSL} || $args{verify_ssl} || 0, # no verification by default
          no_proxy     => $ENV{no_proxy},
      };
  
      bless $self, $class;
  
      $class->_validate_cookie_jar( $args{cookie_jar} ) if $args{cookie_jar};
  
      for my $key ( @attributes ) {
          $self->{$key} = $args{$key} if exists $args{$key}
      }
  
      $self->agent( exists $args{agent} ? $args{agent} : $class->_agent );
  
      $self->_set_proxies;
  
      return $self;
  }
  
  sub _set_proxies {
      my ($self) = @_;
  
      # get proxies from %ENV only if not provided; explicit undef will disable
      # getting proxies from the environment
  
      # generic proxy
      if (! exists $self->{proxy} ) {
          $self->{proxy} = $ENV{all_proxy} || $ENV{ALL_PROXY};
      }
  
      if ( defined $self->{proxy} ) {
          $self->_split_proxy( 'generic proxy' => $self->{proxy} ); # validate
      }
      else {
          delete $self->{proxy};
      }
  
      # http proxy
      if (! exists $self->{http_proxy} ) {
          # under CGI, bypass HTTP_PROXY as request sets it from Proxy header
          local $ENV{HTTP_PROXY} if $ENV{REQUEST_METHOD};
          $self->{http_proxy} = $ENV{http_proxy} || $ENV{HTTP_PROXY} || $self->{proxy};
      }
  
      if ( defined $self->{http_proxy} ) {
          $self->_split_proxy( http_proxy => $self->{http_proxy} ); # validate
          $self->{_has_proxy}{http} = 1;
      }
      else {
          delete $self->{http_proxy};
      }
  
      # https proxy
      if (! exists $self->{https_proxy} ) {
          $self->{https_proxy} = $ENV{https_proxy} || $ENV{HTTPS_PROXY} || $self->{proxy};
      }
  
      if ( $self->{https_proxy} ) {
          $self->_split_proxy( https_proxy => $self->{https_proxy} ); # validate
          $self->{_has_proxy}{https} = 1;
      }
      else {
          delete $self->{https_proxy};
      }
  
      # Split no_proxy to array reference if not provided as such
      unless ( ref $self->{no_proxy} eq 'ARRAY' ) {
          $self->{no_proxy} =
              (defined $self->{no_proxy}) ? [ split /\s*,\s*/, $self->{no_proxy} ] : [];
      }
  
      return;
  }
  
  #pod =method get|head|put|post|delete
  #pod
  #pod     $response = $http->get($url);
  #pod     $response = $http->get($url, \%options);
  #pod     $response = $http->head($url);
  #pod
  #pod These methods are shorthand for calling C<request()> for the given method.  The
  #pod URL must have unsafe characters escaped and international domain names encoded.
  #pod See C<request()> for valid options and a description of the response.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX.
  #pod
  #pod =cut
  
  for my $sub_name ( qw/get head put post delete/ ) {
      my $req_method = uc $sub_name;
      no strict 'refs';
      eval <<"HERE"; ## no critic
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  HERE
  }
  
  #pod =method post_form
  #pod
  #pod     $response = $http->post_form($url, $form_data);
  #pod     $response = $http->post_form($url, $form_data, \%options);
  #pod
  #pod This method executes a C<POST> request and sends the key/value pairs from a
  #pod form data hash or array reference to the given URL with a C<content-type> of
  #pod C<application/x-www-form-urlencoded>.  If data is provided as an array
  #pod reference, the order is preserved; if provided as a hash reference, the terms
  #pod are sorted on key and value for consistency.  See documentation for the
  #pod C<www_form_urlencode> method for details on the encoding.
  #pod
  #pod The URL must have unsafe characters escaped and international domain names
  #pod encoded.  See C<request()> for valid options and a description of the response.
  #pod Any C<content-type> header or content in the options hashref will be ignored.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX.
  #pod
  #pod =cut
  
  sub post_form {
      my ($self, $url, $data, $args) = @_;
      (@_ == 3 || @_ == 4 && ref $args eq 'HASH')
          or Carp::croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ . "\n");
  
      my $headers = {};
      while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
          $headers->{lc $key} = $value;
      }
      delete $args->{headers};
  
      return $self->request('POST', $url, {
              %$args,
              content => $self->www_form_urlencode($data),
              headers => {
                  %$headers,
                  'content-type' => 'application/x-www-form-urlencoded'
              },
          }
      );
  }
  
  #pod =method mirror
  #pod
  #pod     $response = $http->mirror($url, $file, \%options)
  #pod     if ( $response->{success} ) {
  #pod         print "$file is up to date\n";
  #pod     }
  #pod
  #pod Executes a C<GET> request for the URL and saves the response body to the file
  #pod name provided.  The URL must have unsafe characters escaped and international
  #pod domain names encoded.  If the file already exists, the request will include an
  #pod C<If-Modified-Since> header with the modification timestamp of the file.  You
  #pod may specify a different C<If-Modified-Since> header yourself in the C<<
  #pod $options->{headers} >> hash.
  #pod
  #pod The C<success> field of the response will be true if the status code is 2XX
  #pod or if the status code is 304 (unmodified).
  #pod
  #pod If the file was modified and the server response includes a properly
  #pod formatted C<Last-Modified> header, the file modification time will
  #pod be updated accordingly.
  #pod
  #pod =cut
  
  sub mirror {
      my ($self, $url, $file, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or Carp::croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ . "\n");
      if ( -e $file and my $mtime = (stat($file))[9] ) {
          $args->{headers}{'if-modified-since'} ||= $self->_http_date($mtime);
      }
      my $tempfile = $file . int(rand(2**31));
  
      require Fcntl;
      sysopen my $fh, $tempfile, Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()
         or Carp::croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);
      binmode $fh;
      $args->{data_callback} = sub { print {$fh} $_[0] };
      my $response = $self->request('GET', $url, $args);
      close $fh
          or Carp::croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);
  
      if ( $response->{success} ) {
          rename $tempfile, $file
              or Carp::croak(qq/Error replacing $file with $tempfile: $!\n/);
          my $lm = $response->{headers}{'last-modified'};
          if ( $lm and my $mtime = $self->_parse_http_date($lm) ) {
              utime $mtime, $mtime, $file;
          }
      }
      $response->{success} ||= $response->{status} eq '304';
      unlink $tempfile;
      return $response;
  }
  
  #pod =method request
  #pod
  #pod     $response = $http->request($method, $url);
  #pod     $response = $http->request($method, $url, \%options);
  #pod
  #pod Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
  #pod 'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
  #pod international domain names encoded.
  #pod
  #pod If the URL includes a "user:password" stanza, they will be used for Basic-style
  #pod authorization headers.  (Authorization headers will not be included in a
  #pod redirected request.) For example:
  #pod
  #pod     $http->request('GET', 'http://Aladdin:open sesame@example.com/');
  #pod
  #pod If the "user:password" stanza contains reserved characters, they must
  #pod be percent-escaped:
  #pod
  #pod     $http->request('GET', 'http://john%40example.com:password@example.com/');
  #pod
  #pod A hashref of options may be appended to modify the request.
  #pod
  #pod Valid options are:
  #pod
  #pod =for :list
  #pod * C<headers> —
  #pod     A hashref containing headers to include with the request.  If the value for
  #pod     a header is an array reference, the header will be output multiple times with
  #pod     each value in the array.  These headers over-write any default headers.
  #pod * C<content> —
  #pod     A scalar to include as the body of the request OR a code reference
  #pod     that will be called iteratively to produce the body of the request
  #pod * C<trailer_callback> —
  #pod     A code reference that will be called if it exists to provide a hashref
  #pod     of trailing headers (only used with chunked transfer-encoding)
  #pod * C<data_callback> —
  #pod     A code reference that will be called for each chunks of the response
  #pod     body received.
  #pod * C<peer> —
  #pod     Override host resolution and force all connections to go only to a
  #pod     specific peer address, regardless of the URL of the request.  This will
  #pod     include any redirections!  This options should be used with extreme
  #pod     caution (e.g. debugging or very special circumstances).
  #pod
  #pod The C<Host> header is generated from the URL in accordance with RFC 2616.  It
  #pod is a fatal error to specify C<Host> in the C<headers> option.  Other headers
  #pod may be ignored or overwritten if necessary for transport compliance.
  #pod
  #pod If the C<content> option is a code reference, it will be called iteratively
  #pod to provide the content body of the request.  It should return the empty
  #pod string or undef when the iterator is exhausted.
  #pod
  #pod If the C<content> option is the empty string, no C<content-type> or
  #pod C<content-length> headers will be generated.
  #pod
  #pod If the C<data_callback> option is provided, it will be called iteratively until
  #pod the entire response body is received.  The first argument will be a string
  #pod containing a chunk of the response body, the second argument will be the
  #pod in-progress response hash reference, as described below.  (This allows
  #pod customizing the action of the callback based on the C<status> or C<headers>
  #pod received prior to the content body.)
  #pod
  #pod The C<request> method returns a hashref containing the response.  The hashref
  #pod will have the following keys:
  #pod
  #pod =for :list
  #pod * C<success> —
  #pod     Boolean indicating whether the operation returned a 2XX status code
  #pod * C<url> —
  #pod     URL that provided the response. This is the URL of the request unless
  #pod     there were redirections, in which case it is the last URL queried
  #pod     in a redirection chain
  #pod * C<status> —
  #pod     The HTTP status code of the response
  #pod * C<reason> —
  #pod     The response phrase returned by the server
  #pod * C<content> —
  #pod     The body of the response.  If the response does not have any content
  #pod     or if a data callback is provided to consume the response body,
  #pod     this will be the empty string
  #pod * C<headers> —
  #pod     A hashref of header fields.  All header field names will be normalized
  #pod     to be lower case. If a header is repeated, the value will be an arrayref;
  #pod     it will otherwise be a scalar string containing the value
  #pod * C<redirects>
  #pod     If this field exists, it is an arrayref of response hash references from
  #pod     redirects in the same order that redirections occurred.  If it does
  #pod     not exist, then no redirections occurred.
  #pod
  #pod On an exception during the execution of the request, the C<status> field will
  #pod contain 599, and the C<content> field will contain the text of the exception.
  #pod
  #pod =cut
  
  my %idempotent = map { $_ => 1 } qw/GET HEAD PUT DELETE OPTIONS TRACE/;
  
  sub request {
      my ($self, $method, $url, $args) = @_;
      @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
        or Carp::croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ . "\n");
      $args ||= {}; # we keep some state in this during _request
  
      # RFC 2616 Section 8.1.4 mandates a single retry on broken socket
      my $response;
      for ( 0 .. 1 ) {
          $response = eval { $self->_request($method, $url, $args) };
          last unless $@ && $idempotent{$method}
              && $@ =~ m{^(?:Socket closed|Unexpected end)};
      }
  
      if (my $e = $@) {
          # maybe we got a response hash thrown from somewhere deep
          if ( ref $e eq 'HASH' && exists $e->{status} ) {
              return $e;
          }
  
          # otherwise, stringify it
          $e = "$e";
          $response = {
              url     => $url,
              success => q{},
              status  => 599,
              reason  => 'Internal Exception',
              content => $e,
              headers => {
                  'content-type'   => 'text/plain',
                  'content-length' => length $e,
              }
          };
      }
      return $response;
  }
  
  #pod =method www_form_urlencode
  #pod
  #pod     $params = $http->www_form_urlencode( $data );
  #pod     $response = $http->get("http://example.com/query?$params");
  #pod
  #pod This method converts the key/value pairs from a data hash or array reference
  #pod into a C<x-www-form-urlencoded> string.  The keys and values from the data
  #pod reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
  #pod array reference, the key will be repeated with each of the values of the array
  #pod reference.  If data is provided as a hash reference, the key/value pairs in the
  #pod resulting string will be sorted by key and value for consistent ordering.
  #pod
  #pod =cut
  
  sub www_form_urlencode {
      my ($self, $data) = @_;
      (@_ == 2 && ref $data)
          or Carp::croak(q/Usage: $http->www_form_urlencode(DATAREF)/ . "\n");
      (ref $data eq 'HASH' || ref $data eq 'ARRAY')
          or Carp::croak("form data must be a hash or array reference\n");
  
      my @params = ref $data eq 'HASH' ? %$data : @$data;
      @params % 2 == 0
          or Carp::croak("form data reference must have an even number of terms\n");
  
      my @terms;
      while( @params ) {
          my ($key, $value) = splice(@params, 0, 2);
          if ( ref $value eq 'ARRAY' ) {
              unshift @params, map { $key => $_ } @$value;
          }
          else {
              push @terms, join("=", map { $self->_uri_escape($_) } $key, $value);
          }
      }
  
      return join("&", (ref $data eq 'ARRAY') ? (@terms) : (sort @terms) );
  }
  
  #pod =method can_ssl
  #pod
  #pod     $ok         = HTTP::Tiny->can_ssl;
  #pod     ($ok, $why) = HTTP::Tiny->can_ssl;
  #pod     ($ok, $why) = $http->can_ssl;
  #pod
  #pod Indicates if SSL support is available.  When called as a class object, it
  #pod checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
  #pod When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
  #pod is set in C<SSL_options>, it checks that a CA file is available.
  #pod
  #pod In scalar context, returns a boolean indicating if SSL is available.
  #pod In list context, returns the boolean and a (possibly multi-line) string of
  #pod errors indicating why SSL isn't available.
  #pod
  #pod =cut
  
  sub can_ssl {
      my ($self) = @_;
  
      my($ok, $reason) = (1, '');
  
      # Need IO::Socket::SSL 1.42 for SSL_create_ctx_callback
      unless (eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)}) {
          $ok = 0;
          $reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/;
      }
  
      # Need Net::SSLeay 1.49 for MODE_AUTO_RETRY
      unless (eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)}) {
          $ok = 0;
          $reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/;
      }
  
      # If an object, check that SSL config lets us get a CA if necessary
      if ( ref($self) && ( $self->{verify_SSL} || $self->{SSL_options}{SSL_verify_mode} ) ) {
          my $handle = HTTP::Tiny::Handle->new(
              SSL_options => $self->{SSL_options},
              verify_SSL  => $self->{verify_SSL},
          );
          unless ( eval { $handle->_find_CA_file; 1 } ) {
              $ok = 0;
              $reason .= "$@";
          }
      }
  
      wantarray ? ($ok, $reason) : $ok;
  }
  
  #pod =method connected
  #pod
  #pod     $host = $http->connected;
  #pod     ($host, $port) = $http->connected;
  #pod
  #pod Indicates if a connection to a peer is being kept alive, per the C<keep_alive>
  #pod option.
  #pod
  #pod In scalar context, returns the peer host and port, joined with a colon, or
  #pod C<undef> (if no peer is connected).
  #pod In list context, returns the peer host and port or an empty list (if no peer
  #pod is connected).
  #pod
  #pod B<Note>: This method cannot reliably be used to discover whether the remote
  #pod host has closed its end of the socket.
  #pod
  #pod =cut
  
  sub connected {
      my ($self) = @_;
  
      # If a socket exists...
      if ($self->{handle} && $self->{handle}{fh}) {
          my $socket = $self->{handle}{fh};
  
          # ...and is connected, return the peer host and port.
          if ($socket->connected) {
              return wantarray
                  ? ($socket->peerhost, $socket->peerport)
                  : join(':', $socket->peerhost, $socket->peerport);
          }
      }
      return;
  }
  
  #--------------------------------------------------------------------------#
  # private methods
  #--------------------------------------------------------------------------#
  
  my %DefaultPort = (
      http => 80,
      https => 443,
  );
  
  sub _agent {
      my $class = ref($_[0]) || $_[0];
      (my $default_agent = $class) =~ s{::}{-}g;
      return $default_agent . "/" . $class->VERSION;
  }
  
  sub _request {
      my ($self, $method, $url, $args) = @_;
  
      my ($scheme, $host, $port, $path_query, $auth) = $self->_split_url($url);
  
      my $request = {
          method    => $method,
          scheme    => $scheme,
          host      => $host,
          port      => $port,
          host_port => ($port == $DefaultPort{$scheme} ? $host : "$host:$port"),
          uri       => $path_query,
          headers   => {},
      };
  
      my $peer = $args->{peer} || $host;
  
      # We remove the cached handle so it is not reused in the case of redirect.
      # If all is well, it will be recached at the end of _request.  We only
      # reuse for the same scheme, host and port
      my $handle = delete $self->{handle};
      if ( $handle ) {
          unless ( $handle->can_reuse( $scheme, $host, $port, $peer ) ) {
              $handle->close;
              undef $handle;
          }
      }
      $handle ||= $self->_open_handle( $request, $scheme, $host, $port, $peer );
  
      $self->_prepare_headers_and_cb($request, $args, $url, $auth);
      $handle->write_request($request);
  
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');
  
      $self->_update_cookie_jar( $url, $response ) if $self->{cookie_jar};
      my @redir_args = $self->_maybe_redirect($request, $response, $args);
  
      my $known_message_length;
      if ($method eq 'HEAD' || $response->{status} =~ /^[23]04/) {
          # response has no message body
          $known_message_length = 1;
      }
      else {
          # Ignore any data callbacks during redirection.
          my $cb_args = @redir_args ? +{} : $args;
          my $data_cb = $self->_prepare_data_cb($response, $cb_args);
          $known_message_length = $handle->read_body($data_cb, $response);
      }
  
      if ( $self->{keep_alive}
          && $known_message_length
          && $response->{protocol} eq 'HTTP/1.1'
          && ($response->{headers}{connection} || '') ne 'close'
      ) {
          $self->{handle} = $handle;
      }
      else {
          $handle->close;
      }
  
      $response->{success} = substr( $response->{status}, 0, 1 ) eq '2';
      $response->{url} = $url;
  
      # Push the current response onto the stack of redirects if redirecting.
      if (@redir_args) {
          push @{$args->{_redirects}}, $response;
          return $self->_request(@redir_args, $args);
      }
  
      # Copy the stack of redirects into the response before returning.
      $response->{redirects} = delete $args->{_redirects}
        if @{$args->{_redirects}};
      return $response;
  }
  
  sub _open_handle {
      my ($self, $request, $scheme, $host, $port, $peer) = @_;
  
      my $handle  = HTTP::Tiny::Handle->new(
          timeout         => $self->{timeout},
          SSL_options     => $self->{SSL_options},
          verify_SSL      => $self->{verify_SSL},
          local_address   => $self->{local_address},
          keep_alive      => $self->{keep_alive}
      );
  
      if ($self->{_has_proxy}{$scheme} && ! grep { $host =~ /\Q$_\E$/ } @{$self->{no_proxy}}) {
          return $self->_proxy_connect( $request, $handle );
      }
      else {
          return $handle->connect($scheme, $host, $port, $peer);
      }
  }
  
  sub _proxy_connect {
      my ($self, $request, $handle) = @_;
  
      my @proxy_vars;
      if ( $request->{scheme} eq 'https' ) {
          Carp::croak(qq{No https_proxy defined}) unless $self->{https_proxy};
          @proxy_vars = $self->_split_proxy( https_proxy => $self->{https_proxy} );
          if ( $proxy_vars[0] eq 'https' ) {
              Carp::croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}});
          }
      }
      else {
          Carp::croak(qq{No http_proxy defined}) unless $self->{http_proxy};
          @proxy_vars = $self->_split_proxy( http_proxy => $self->{http_proxy} );
      }
  
      my ($p_scheme, $p_host, $p_port, $p_auth) = @proxy_vars;
  
      if ( length $p_auth && ! defined $request->{headers}{'proxy-authorization'} ) {
          $self->_add_basic_auth_header( $request, 'proxy-authorization' => $p_auth );
      }
  
      $handle->connect($p_scheme, $p_host, $p_port, $p_host);
  
      if ($request->{scheme} eq 'https') {
          $self->_create_proxy_tunnel( $request, $handle );
      }
      else {
          # non-tunneled proxy requires absolute URI
          $request->{uri} = "$request->{scheme}://$request->{host_port}$request->{uri}";
      }
  
      return $handle;
  }
  
  sub _split_proxy {
      my ($self, $type, $proxy) = @_;
  
      my ($scheme, $host, $port, $path_query, $auth) = eval { $self->_split_url($proxy) };
  
      unless(
          defined($scheme) && length($scheme) && length($host) && length($port)
          && $path_query eq '/'
      ) {
          Carp::croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n});
      }
  
      return ($scheme, $host, $port, $auth);
  }
  
  sub _create_proxy_tunnel {
      my ($self, $request, $handle) = @_;
  
      $handle->_assert_ssl;
  
      my $agent = exists($request->{headers}{'user-agent'})
          ? $request->{headers}{'user-agent'} : $self->{agent};
  
      my $connect_request = {
          method    => 'CONNECT',
          uri       => "$request->{host}:$request->{port}",
          headers   => {
              host => "$request->{host}:$request->{port}",
              'user-agent' => $agent,
          }
      };
  
      if ( $request->{headers}{'proxy-authorization'} ) {
          $connect_request->{headers}{'proxy-authorization'} =
              delete $request->{headers}{'proxy-authorization'};
      }
  
      $handle->write_request($connect_request);
      my $response;
      do { $response = $handle->read_response_header }
          until (substr($response->{status},0,1) ne '1');
  
      # if CONNECT failed, throw the response so it will be
      # returned from the original request() method;
      unless (substr($response->{status},0,1) eq '2') {
          die $response;
      }
  
      # tunnel established, so start SSL handshake
      $handle->start_ssl( $request->{host} );
  
      return;
  }
  
  sub _prepare_headers_and_cb {
      my ($self, $request, $args, $url, $auth) = @_;
  
      for ($self->{default_headers}, $args->{headers}) {
          next unless defined;
          while (my ($k, $v) = each %$_) {
              $request->{headers}{lc $k} = $v;
              $request->{header_case}{lc $k} = $k;
          }
      }
  
      if (exists $request->{headers}{'host'}) {
          die(qq/The 'Host' header must not be provided as header option\n/);
      }
  
      $request->{headers}{'host'}         = $request->{host_port};
      $request->{headers}{'user-agent'} ||= $self->{agent};
      $request->{headers}{'connection'}   = "close"
          unless $self->{keep_alive};
  
      if ( defined $args->{content} ) {
          if (ref $args->{content} eq 'CODE') {
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'transfer-encoding'} = 'chunked'
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = $args->{content};
          }
          elsif ( length $args->{content} ) {
              my $content = $args->{content};
              if ( $] ge '5.008' ) {
                  utf8::downgrade($content, 1)
                      or die(qq/Wide character in request message body\n/);
              }
              $request->{headers}{'content-type'} ||= "application/octet-stream";
              $request->{headers}{'content-length'} = length $content
                unless $request->{headers}{'content-length'}
                    || $request->{headers}{'transfer-encoding'};
              $request->{cb} = sub { substr $content, 0, length $content, '' };
          }
          $request->{trailer_cb} = $args->{trailer_callback}
              if ref $args->{trailer_callback} eq 'CODE';
      }
  
      ### If we have a cookie jar, then maybe add relevant cookies
      if ( $self->{cookie_jar} ) {
          my $cookies = $self->cookie_jar->cookie_header( $url );
          $request->{headers}{cookie} = $cookies if length $cookies;
      }
  
      # if we have Basic auth parameters, add them
      if ( length $auth && ! defined $request->{headers}{authorization} ) {
          $self->_add_basic_auth_header( $request, 'authorization' => $auth );
      }
  
      return;
  }
  
  sub _add_basic_auth_header {
      my ($self, $request, $header, $auth) = @_;
      require MIME::Base64;
      $request->{headers}{$header} =
          "Basic " . MIME::Base64::encode_base64($auth, "");
      return;
  }
  
  sub _prepare_data_cb {
      my ($self, $response, $args) = @_;
      my $data_cb = $args->{data_callback};
      $response->{content} = '';
  
      if (!$data_cb || $response->{status} !~ /^2/) {
          if (defined $self->{max_size}) {
              $data_cb = sub {
                  $_[1]->{content} .= $_[0];
                  die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)
                    if length $_[1]->{content} > $self->{max_size};
              };
          }
          else {
              $data_cb = sub { $_[1]->{content} .= $_[0] };
          }
      }
      return $data_cb;
  }
  
  sub _update_cookie_jar {
      my ($self, $url, $response) = @_;
  
      my $cookies = $response->{headers}->{'set-cookie'};
      return unless defined $cookies;
  
      my @cookies = ref $cookies ? @$cookies : $cookies;
  
      $self->cookie_jar->add( $url, $_ ) for @cookies;
  
      return;
  }
  
  sub _validate_cookie_jar {
      my ($class, $jar) = @_;
  
      # duck typing
      for my $method ( qw/add cookie_header/ ) {
          Carp::croak(qq/Cookie jar must provide the '$method' method\n/)
              unless ref($jar) && ref($jar)->can($method);
      }
  
      return;
  }
  
  sub _maybe_redirect {
      my ($self, $request, $response, $args) = @_;
      my $headers = $response->{headers};
      my ($status, $method) = ($response->{status}, $request->{method});
      $args->{_redirects} ||= [];
  
      if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))
          and $headers->{location}
          and @{$args->{_redirects}} < $self->{max_redirect}
      ) {
          my $location = ($headers->{location} =~ /^\//)
              ? "$request->{scheme}://$request->{host_port}$headers->{location}"
              : $headers->{location} ;
          return (($status eq '303' ? 'GET' : $method), $location);
      }
      return;
  }
  
  sub _split_url {
      my $url = pop;
  
      # URI regex adapted from the URI module
      my ($scheme, $host, $path_query) = $url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)>
        or die(qq/Cannot parse URL: '$url'\n/);
  
      $scheme     = lc $scheme;
      $path_query = "/$path_query" unless $path_query =~ m<\A/>;
  
      my $auth = '';
      if ( (my $i = index $host, '@') != -1 ) {
          # user:pass@host
          $auth = substr $host, 0, $i, ''; # take up to the @ for auth
          substr $host, 0, 1, '';          # knock the @ off the host
  
          # userinfo might be percent escaped, so recover real auth info
          $auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
      }
      my $port = $host =~ s/:(\d*)\z// && length $1 ? $1
               : $scheme eq 'http'                  ? 80
               : $scheme eq 'https'                 ? 443
               : undef;
  
      return ($scheme, (length $host ? lc $host : "localhost") , $port, $path_query, $auth);
  }
  
  # Date conversions adapted from HTTP::Date
  my $DoW = "Sun|Mon|Tue|Wed|Thu|Fri|Sat";
  my $MoY = "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";
  sub _http_date {
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($_[1]);
      return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
          substr($DoW,$wday*4,3),
          $mday, substr($MoY,$mon*4,3), $year+1900,
          $hour, $min, $sec
      );
  }
  
  sub _parse_http_date {
      my ($self, $str) = @_;
      require Time::Local;
      my @tl_parts;
      if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/ ) {
          @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
      }
      elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/ ) {
          @tl_parts = ($5, $4, $3, $2, (index($MoY,$1)/4), $6);
      }
      return eval {
          my $t = @tl_parts ? Time::Local::timegm(@tl_parts) : -1;
          $t < 0 ? undef : $t;
      };
  }
  
  # URI escaping adapted from URI::Escape
  # c.f. http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
  # perl 5.6 ready UTF-8 encoding adapted from JSON::PP
  my %escapes = map { chr($_) => sprintf("%%%02X", $_) } 0..255;
  $escapes{' '}="+";
  my $unsafe_char = qr/[^A-Za-z0-9\-\._~]/;
  
  sub _uri_escape {
      my ($self, $str) = @_;
      if ( $] ge '5.008' ) {
          utf8::encode($str);
      }
      else {
          $str = pack("U*", unpack("C*", $str)) # UTF-8 encode a byte string
              if ( length $str == do { use bytes; length $str } );
          $str = pack("C*", unpack("C*", $str)); # clear UTF-8 flag
      }
      $str =~ s/($unsafe_char)/$escapes{$1}/ge;
      return $str;
  }
  
  package
      HTTP::Tiny::Handle; # hide from PAUSE/indexers
  use strict;
  use warnings;
  
  use Errno      qw[EINTR EPIPE];
  use IO::Socket qw[SOCK_STREAM];
  use Socket     qw[SOL_SOCKET SO_KEEPALIVE];
  
  # PERL_HTTP_TINY_IPV4_ONLY is a private environment variable to force old
  # behavior if someone is unable to boostrap CPAN from a new perl install; it is
  # not intended for general, per-client use and may be removed in the future
  my $SOCKET_CLASS =
      $ENV{PERL_HTTP_TINY_IPV4_ONLY} ? 'IO::Socket::INET' :
      eval { require IO::Socket::IP; IO::Socket::IP->VERSION(0.25) } ? 'IO::Socket::IP' :
      'IO::Socket::INET';
  
  sub BUFSIZE () { 32768 } ## no critic
  
  my $Printable = sub {
      local $_ = shift;
      s/\r/\\r/g;
      s/\n/\\n/g;
      s/\t/\\t/g;
      s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;
      $_;
  };
  
  my $Token = qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;
  my $Field_Content = qr/[[:print:]]+ (?: [\x20\x09]+ [[:print:]]+ )*/x;
  
  sub new {
      my ($class, %args) = @_;
      return bless {
          rbuf             => '',
          timeout          => 60,
          max_line_size    => 16384,
          max_header_lines => 64,
          verify_SSL       => 0,
          SSL_options      => {},
          %args
      }, $class;
  }
  
  sub timeout {
      my ($self, $timeout) = @_;
      if ( @_ > 1 ) {
          $self->{timeout} = $timeout;
          if ( $self->{fh} && $self->{fh}->can('timeout') ) {
              $self->{fh}->timeout($timeout);
          }
      }
      return $self->{timeout};
  }
  
  sub connect {
      @_ == 5 || die(q/Usage: $handle->connect(scheme, host, port, peer)/ . "\n");
      my ($self, $scheme, $host, $port, $peer) = @_;
  
      if ( $scheme eq 'https' ) {
          $self->_assert_ssl;
      }
      elsif ( $scheme ne 'http' ) {
        die(qq/Unsupported URL scheme '$scheme'\n/);
      }
      $self->{fh} = $SOCKET_CLASS->new(
          PeerHost  => $peer,
          PeerPort  => $port,
          $self->{local_address} ?
              ( LocalAddr => $self->{local_address} ) : (),
          Proto     => 'tcp',
          Type      => SOCK_STREAM,
          Timeout   => $self->{timeout},
      ) or die(qq/Could not connect to '$host:$port': $@\n/);
  
      binmode($self->{fh})
        or die(qq/Could not binmode() socket: '$!'\n/);
  
      if ( $self->{keep_alive} ) {
          unless ( defined( $self->{fh}->setsockopt( SOL_SOCKET, SO_KEEPALIVE, 1 ) ) ) {
              CORE::close($self->{fh});
              die(qq/Could not set SO_KEEPALIVE on socket: '$!'\n/);
          }
      }
  
      $self->start_ssl($host) if $scheme eq 'https';
  
      $self->{scheme} = $scheme;
      $self->{host} = $host;
      $self->{peer} = $peer;
      $self->{port} = $port;
      $self->{pid} = $$;
      $self->{tid} = _get_tid();
  
      return $self;
  }
  
  sub start_ssl {
      my ($self, $host) = @_;
  
      # As this might be used via CONNECT after an SSL session
      # to a proxy, we shut down any existing SSL before attempting
      # the handshake
      if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          unless ( $self->{fh}->stop_SSL ) {
              my $ssl_err = IO::Socket::SSL->errstr;
              die(qq/Error halting prior SSL connection: $ssl_err/);
          }
      }
  
      my $ssl_args = $self->_ssl_args($host);
      IO::Socket::SSL->start_SSL(
          $self->{fh},
          %$ssl_args,
          SSL_create_ctx_callback => sub {
              my $ctx = shift;
              Net::SSLeay::CTX_set_mode($ctx, Net::SSLeay::MODE_AUTO_RETRY());
          },
      );
  
      unless ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          my $ssl_err = IO::Socket::SSL->errstr;
          die(qq/SSL connection failed for $host: $ssl_err\n/);
      }
  }
  
  sub close {
      @_ == 1 || die(q/Usage: $handle->close()/ . "\n");
      my ($self) = @_;
      CORE::close($self->{fh})
        or die(qq/Could not close socket: '$!'\n/);
  }
  
  sub write {
      @_ == 2 || die(q/Usage: $handle->write(buf)/ . "\n");
      my ($self, $buf) = @_;
  
      if ( $] ge '5.008' ) {
          utf8::downgrade($buf, 1)
              or die(qq/Wide character in write()\n/);
      }
  
      my $len = length $buf;
      my $off = 0;
  
      local $SIG{PIPE} = 'IGNORE';
  
      while () {
          $self->can_write
            or die(qq/Timed out while waiting for socket to become ready for writing\n/);
          my $r = syswrite($self->{fh}, $buf, $len, $off);
          if (defined $r) {
              $len -= $r;
              $off += $r;
              last unless $len > 0;
          }
          elsif ($! == EPIPE) {
              die(qq/Socket closed by remote server: $!\n/);
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not write to SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not write to socket: '$!'\n/);
              }
  
          }
      }
      return $off;
  }
  
  sub read {
      @_ == 2 || @_ == 3 || die(q/Usage: $handle->read(len [, allow_partial])/ . "\n");
      my ($self, $len, $allow_partial) = @_;
  
      my $buf  = '';
      my $got = length $self->{rbuf};
  
      if ($got) {
          my $take = ($got < $len) ? $got : $len;
          $buf  = substr($self->{rbuf}, 0, $take, '');
          $len -= $take;
      }
  
      while ($len > 0) {
          $self->can_read
            or die(q/Timed out while waiting for socket to become ready for reading/ . "\n");
          my $r = sysread($self->{fh}, $buf, $len, length $buf);
          if (defined $r) {
              last unless $r;
              $len -= $r;
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not read from SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not read from socket: '$!'\n/);
              }
          }
      }
      if ($len && !$allow_partial) {
          die(qq/Unexpected end of stream\n/);
      }
      return $buf;
  }
  
  sub readline {
      @_ == 1 || die(q/Usage: $handle->readline()/ . "\n");
      my ($self) = @_;
  
      while () {
          if ($self->{rbuf} =~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x) {
              return $1;
          }
          if (length $self->{rbuf} >= $self->{max_line_size}) {
              die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/);
          }
          $self->can_read
            or die(qq/Timed out while waiting for socket to become ready for reading\n/);
          my $r = sysread($self->{fh}, $self->{rbuf}, BUFSIZE, length $self->{rbuf});
          if (defined $r) {
              last unless $r;
          }
          elsif ($! != EINTR) {
              if ($self->{fh}->can('errstr')){
                  my $err = $self->{fh}->errstr();
                  die (qq/Could not read from SSL socket: '$err'\n /);
              }
              else {
                  die(qq/Could not read from socket: '$!'\n/);
              }
          }
      }
      die(qq/Unexpected end of stream while looking for line\n/);
  }
  
  sub read_header_lines {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->read_header_lines([headers])/ . "\n");
      my ($self, $headers) = @_;
      $headers ||= {};
      my $lines   = 0;
      my $val;
  
      while () {
           my $line = $self->readline;
  
           if (++$lines >= $self->{max_header_lines}) {
               die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/);
           }
           elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x) {
               my ($field_name) = lc $1;
               if (exists $headers->{$field_name}) {
                   for ($headers->{$field_name}) {
                       $_ = [$_] unless ref $_ eq "ARRAY";
                       push @$_, $2;
                       $val = \$_->[-1];
                   }
               }
               else {
                   $val = \($headers->{$field_name} = $2);
               }
           }
           elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x) {
               $val
                 or die(qq/Unexpected header continuation line\n/);
               next unless length $1;
               $$val .= ' ' if length $$val;
               $$val .= $1;
           }
           elsif ($line =~ /\A \x0D?\x0A \z/x) {
              last;
           }
           else {
              die(q/Malformed header line: / . $Printable->($line) . "\n");
           }
      }
      return $headers;
  }
  
  sub write_request {
      @_ == 2 || die(q/Usage: $handle->write_request(request)/ . "\n");
      my($self, $request) = @_;
      $self->write_request_header(@{$request}{qw/method uri headers header_case/});
      $self->write_body($request) if $request->{cb};
      return;
  }
  
  # Standard request header names/case from HTTP/1.1 RFCs
  my @rfc_request_headers = qw(
    Accept Accept-Charset Accept-Encoding Accept-Language Authorization
    Cache-Control Connection Content-Length Expect From Host
    If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
    Max-Forwards Pragma Proxy-Authorization Range Referer TE Trailer
    Transfer-Encoding Upgrade User-Agent Via
  );
  
  my @other_request_headers = qw(
    Content-Encoding Content-MD5 Content-Type Cookie DNT Date Origin
    X-XSS-Protection
  );
  
  my %HeaderCase = map { lc($_) => $_ } @rfc_request_headers, @other_request_headers;
  
  # to avoid multiple small writes and hence nagle, you can pass the method line or anything else to
  # combine writes.
  sub write_header_lines {
      (@_ >= 2 && @_ <= 4 && ref $_[1] eq 'HASH') || die(q/Usage: $handle->write_header_lines(headers, [header_case, prefix])/ . "\n");
      my($self, $headers, $header_case, $prefix_data) = @_;
      $header_case ||= {};
  
      my $buf = (defined $prefix_data ? $prefix_data : '');
  
      # Per RFC, control fields should be listed first
      my %seen;
      for my $k ( qw/host cache-control expect max-forwards pragma range te/ ) {
          next unless exists $headers->{$k};
          $seen{$k}++;
          my $field_name = $HeaderCase{$k};
          my $v = $headers->{$k};
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              $_ = '' unless defined $_;
              $buf .= "$field_name: $_\x0D\x0A";
          }
      }
  
      # Other headers sent in arbitrary order
      while (my ($k, $v) = each %$headers) {
          my $field_name = lc $k;
          next if $seen{$field_name};
          if (exists $HeaderCase{$field_name}) {
              $field_name = $HeaderCase{$field_name};
          }
          else {
              if (exists $header_case->{$field_name}) {
                  $field_name = $header_case->{$field_name};
              }
              else {
                  $field_name =~ s/\b(\w)/\u$1/g;
              }
              $field_name =~ /\A $Token+ \z/xo
                or die(q/Invalid HTTP header field name: / . $Printable->($field_name) . "\n");
              $HeaderCase{lc $field_name} = $field_name;
          }
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              # unwrap a field value if pre-wrapped by user
              s/\x0D?\x0A\s+/ /g;
              die(qq/Invalid HTTP header field value ($field_name): / . $Printable->($_). "\n")
                unless $_ eq '' || /\A $Field_Content \z/xo;
              $_ = '' unless defined $_;
              $buf .= "$field_name: $_\x0D\x0A";
          }
      }
      $buf .= "\x0D\x0A";
      return $self->write($buf);
  }
  
  # return value indicates whether message length was defined; this is generally
  # true unless there was no content-length header and we just read until EOF.
  # Other message length errors are thrown as exceptions
  sub read_body {
      @_ == 3 || die(q/Usage: $handle->read_body(callback, response)/ . "\n");
      my ($self, $cb, $response) = @_;
      my $te = $response->{headers}{'transfer-encoding'} || '';
      my $chunked = grep { /chunked/i } ( ref $te eq 'ARRAY' ? @$te : $te ) ;
      return $chunked
          ? $self->read_chunked_body($cb, $response)
          : $self->read_content_body($cb, $response);
  }
  
  sub write_body {
      @_ == 2 || die(q/Usage: $handle->write_body(request)/ . "\n");
      my ($self, $request) = @_;
      if ($request->{headers}{'content-length'}) {
          return $self->write_content_body($request);
      }
      else {
          return $self->write_chunked_body($request);
      }
  }
  
  sub read_content_body {
      @_ == 3 || @_ == 4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ . "\n");
      my ($self, $cb, $response, $content_length) = @_;
      $content_length ||= $response->{headers}{'content-length'};
  
      if ( defined $content_length ) {
          my $len = $content_length;
          while ($len > 0) {
              my $read = ($len > BUFSIZE) ? BUFSIZE : $len;
              $cb->($self->read($read, 0), $response);
              $len -= $read;
          }
          return length($self->{rbuf}) == 0;
      }
  
      my $chunk;
      $cb->($chunk, $response) while length( $chunk = $self->read(BUFSIZE, 1) );
  
      return;
  }
  
  sub write_content_body {
      @_ == 2 || die(q/Usage: $handle->write_content_body(request)/ . "\n");
      my ($self, $request) = @_;
  
      my ($len, $content_length) = (0, $request->{headers}{'content-length'});
      while () {
          my $data = $request->{cb}->();
  
          defined $data && length $data
            or last;
  
          if ( $] ge '5.008' ) {
              utf8::downgrade($data, 1)
                  or die(qq/Wide character in write_content()\n/);
          }
  
          $len += $self->write($data);
      }
  
      $len == $content_length
        or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);
  
      return $len;
  }
  
  sub read_chunked_body {
      @_ == 3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ . "\n");
      my ($self, $cb, $response) = @_;
  
      while () {
          my $head = $self->readline;
  
          $head =~ /\A ([A-Fa-f0-9]+)/x
            or die(q/Malformed chunk head: / . $Printable->($head) . "\n");
  
          my $len = hex($1)
            or last;
  
          $self->read_content_body($cb, $response, $len);
  
          $self->read(2) eq "\x0D\x0A"
            or die(qq/Malformed chunk: missing CRLF after chunk data\n/);
      }
      $self->read_header_lines($response->{headers});
      return 1;
  }
  
  sub write_chunked_body {
      @_ == 2 || die(q/Usage: $handle->write_chunked_body(request)/ . "\n");
      my ($self, $request) = @_;
  
      my $len = 0;
      while () {
          my $data = $request->{cb}->();
  
          defined $data && length $data
            or last;
  
          if ( $] ge '5.008' ) {
              utf8::downgrade($data, 1)
                  or die(qq/Wide character in write_chunked_body()\n/);
          }
  
          $len += length $data;
  
          my $chunk  = sprintf '%X', length $data;
             $chunk .= "\x0D\x0A";
             $chunk .= $data;
             $chunk .= "\x0D\x0A";
  
          $self->write($chunk);
      }
      $self->write("0\x0D\x0A");
      $self->write_header_lines($request->{trailer_cb}->())
          if ref $request->{trailer_cb} eq 'CODE';
      return $len;
  }
  
  sub read_response_header {
      @_ == 1 || die(q/Usage: $handle->read_response_header()/ . "\n");
      my ($self) = @_;
  
      my $line = $self->readline;
  
      $line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x
        or die(q/Malformed Status-Line: / . $Printable->($line). "\n");
  
      my ($protocol, $version, $status, $reason) = ($1, $2, $3, $4);
  
      die (qq/Unsupported HTTP protocol: $protocol\n/)
          unless $version =~ /0*1\.0*[01]/;
  
      return {
          status       => $status,
          reason       => $reason,
          headers      => $self->read_header_lines,
          protocol     => $protocol,
      };
  }
  
  sub write_request_header {
      @_ == 5 || die(q/Usage: $handle->write_request_header(method, request_uri, headers, header_case)/ . "\n");
      my ($self, $method, $request_uri, $headers, $header_case) = @_;
  
      return $self->write_header_lines($headers, $header_case, "$method $request_uri HTTP/1.1\x0D\x0A");
  }
  
  sub _do_timeout {
      my ($self, $type, $timeout) = @_;
      $timeout = $self->{timeout}
          unless defined $timeout && $timeout >= 0;
  
      my $fd = fileno $self->{fh};
      defined $fd && $fd >= 0
        or die(qq/select(2): 'Bad file descriptor'\n/);
  
      my $initial = time;
      my $pending = $timeout;
      my $nfound;
  
      vec(my $fdset = '', $fd, 1) = 1;
  
      while () {
          $nfound = ($type eq 'read')
              ? select($fdset, undef, undef, $pending)
              : select(undef, $fdset, undef, $pending) ;
          if ($nfound == -1) {
              $! == EINTR
                or die(qq/select(2): '$!'\n/);
              redo if !$timeout || ($pending = $timeout - (time - $initial)) > 0;
              $nfound = 0;
          }
          last;
      }
      $! = 0;
      return $nfound;
  }
  
  sub can_read {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_read([timeout])/ . "\n");
      my $self = shift;
      if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
          return 1 if $self->{fh}->pending;
      }
      return $self->_do_timeout('read', @_)
  }
  
  sub can_write {
      @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_write([timeout])/ . "\n");
      my $self = shift;
      return $self->_do_timeout('write', @_)
  }
  
  sub _assert_ssl {
      my($ok, $reason) = HTTP::Tiny->can_ssl();
      die $reason unless $ok;
  }
  
  sub can_reuse {
      my ($self,$scheme,$host,$port,$peer) = @_;
      return 0 if
          $self->{pid} != $$
          || $self->{tid} != _get_tid()
          || length($self->{rbuf})
          || $scheme ne $self->{scheme}
          || $host ne $self->{host}
          || $port ne $self->{port}
          || $peer ne $self->{peer}
          || eval { $self->can_read(0) }
          || $@ ;
          return 1;
  }
  
  # Try to find a CA bundle to validate the SSL cert,
  # prefer Mozilla::CA or fallback to a system file
  sub _find_CA_file {
      my $self = shift();
  
      my $ca_file =
        defined( $self->{SSL_options}->{SSL_ca_file} )
        ? $self->{SSL_options}->{SSL_ca_file}
        : $ENV{SSL_CERT_FILE};
  
      if ( defined $ca_file ) {
          unless ( -r $ca_file ) {
              die qq/SSL_ca_file '$ca_file' not found or not readable\n/;
          }
          return $ca_file;
      }
  
      return Mozilla::CA::SSL_ca_file()
          if eval { require Mozilla::CA; 1 };
  
      # cert list copied from golang src/crypto/x509/root_unix.go
      foreach my $ca_bundle (
          "/etc/ssl/certs/ca-certificates.crt",     # Debian/Ubuntu/Gentoo etc.
          "/etc/pki/tls/certs/ca-bundle.crt",       # Fedora/RHEL
          "/etc/ssl/ca-bundle.pem",                 # OpenSUSE
          "/etc/openssl/certs/ca-certificates.crt", # NetBSD
          "/etc/ssl/cert.pem",                      # OpenBSD
          "/usr/local/share/certs/ca-root-nss.crt", # FreeBSD/DragonFly
          "/etc/pki/tls/cacert.pem",                # OpenELEC
          "/etc/certs/ca-certificates.crt",         # Solaris 11.2+
      ) {
          return $ca_bundle if -e $ca_bundle;
      }
  
      die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/
        . qq/Try installing Mozilla::CA from CPAN\n/;
  }
  
  # for thread safety, we need to know thread id if threads are loaded
  sub _get_tid {
      no warnings 'reserved'; # for 'threads'
      return threads->can("tid") ? threads->tid : 0;
  }
  
  sub _ssl_args {
      my ($self, $host) = @_;
  
      my %ssl_args;
  
      # This test reimplements IO::Socket::SSL::can_client_sni(), which wasn't
      # added until IO::Socket::SSL 1.84
      if ( Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x01000000 ) {
          $ssl_args{SSL_hostname} = $host,          # Sane SNI support
      }
  
      if ($self->{verify_SSL}) {
          $ssl_args{SSL_verifycn_scheme}  = 'http'; # enable CN validation
          $ssl_args{SSL_verifycn_name}    = $host;  # set validation hostname
          $ssl_args{SSL_verify_mode}      = 0x01;   # enable cert validation
          $ssl_args{SSL_ca_file}          = $self->_find_CA_file;
      }
      else {
          $ssl_args{SSL_verifycn_scheme}  = 'none'; # disable CN validation
          $ssl_args{SSL_verify_mode}      = 0x00;   # disable cert validation
      }
  
      # user options override settings from verify_SSL
      for my $k ( keys %{$self->{SSL_options}} ) {
          $ssl_args{$k} = $self->{SSL_options}{$k} if $k =~ m/^SSL_/;
      }
  
      return \%ssl_args;
  }
  
  1;
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  HTTP::Tiny - A small, simple, correct HTTP/1.1 client
  
  =head1 VERSION
  
  version 0.058
  
  =head1 SYNOPSIS
  
      use HTTP::Tiny;
  
      my $response = HTTP::Tiny->new->get('http://example.com/');
  
      die "Failed!\n" unless $response->{success};
  
      print "$response->{status} $response->{reason}\n";
  
      while (my ($k, $v) = each %{$response->{headers}}) {
          for (ref $v eq 'ARRAY' ? @$v : $v) {
              print "$k: $_\n";
          }
      }
  
      print $response->{content} if length $response->{content};
  
  =head1 DESCRIPTION
  
  This is a very simple HTTP/1.1 client, designed for doing simple
  requests without the overhead of a large framework like L<LWP::UserAgent>.
  
  It is more correct and more complete than L<HTTP::Lite>.  It supports
  proxies and redirection.  It also correctly resumes after EINTR.
  
  If L<IO::Socket::IP> 0.25 or later is installed, HTTP::Tiny will use it instead
  of L<IO::Socket::INET> for transparent support for both IPv4 and IPv6.
  
  Cookie support requires L<HTTP::CookieJar> or an equivalent class.
  
  =head1 METHODS
  
  =head2 new
  
      $http = HTTP::Tiny->new( %attributes );
  
  This constructor returns a new HTTP::Tiny object.  Valid attributes include:
  
  =over 4
  
  =item *
  
  C<agent> — A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If C<agent> — ends in a space character, the default user-agent string is appended.
  
  =item *
  
  C<cookie_jar> — An instance of L<HTTP::CookieJar> — or equivalent class that supports the C<add> and C<cookie_header> methods
  
  =item *
  
  C<default_headers> — A hashref of default headers to apply to requests
  
  =item *
  
  C<local_address> — The local IP address to bind to
  
  =item *
  
  C<keep_alive> — Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)
  
  =item *
  
  C<max_redirect> — Maximum number of redirects allowed (defaults to 5)
  
  =item *
  
  C<max_size> — Maximum response size in bytes (only when not using a data callback).  If defined, responses larger than this will return an exception.
  
  =item *
  
  C<http_proxy> — URL of a proxy server to use for HTTP connections (default is C<$ENV{http_proxy}> — if set)
  
  =item *
  
  C<https_proxy> — URL of a proxy server to use for HTTPS connections (default is C<$ENV{https_proxy}> — if set)
  
  =item *
  
  C<proxy> — URL of a generic proxy server for both HTTP and HTTPS connections (default is C<$ENV{all_proxy}> — if set)
  
  =item *
  
  C<no_proxy> — List of domain suffixes that should not be proxied.  Must be a comma-separated string or an array reference. (default is C<$ENV{no_proxy}> —)
  
  =item *
  
  C<timeout> — Request timeout in seconds (default is 60) If a socket open, read or write takes longer than the timeout, an exception is thrown.
  
  =item *
  
  C<verify_SSL> — A boolean that indicates whether to validate the SSL certificate of an C<https> — connection (default is false)
  
  =item *
  
  C<SSL_options> — A hashref of C<SSL_*> — options to pass through to L<IO::Socket::SSL>
  
  =back
  
  Passing an explicit C<undef> for C<proxy>, C<http_proxy> or C<https_proxy> will
  prevent getting the corresponding proxies from the environment.
  
  Exceptions from C<max_size>, C<timeout> or other errors will result in a
  pseudo-HTTP status code of 599 and a reason of "Internal Exception". The
  content field in the response will contain the text of the exception.
  
  The C<keep_alive> parameter enables a persistent connection, but only to a
  single destination scheme, host and port.  Also, if any connection-relevant
  attributes are modified, or if the process ID or thread ID change, the
  persistent connection will be dropped.  If you want persistent connections
  across multiple destinations, use multiple HTTP::Tiny objects.
  
  See L</SSL SUPPORT> for more on the C<verify_SSL> and C<SSL_options> attributes.
  
  =head2 get|head|put|post|delete
  
      $response = $http->get($url);
      $response = $http->get($url, \%options);
      $response = $http->head($url);
  
  These methods are shorthand for calling C<request()> for the given method.  The
  URL must have unsafe characters escaped and international domain names encoded.
  See C<request()> for valid options and a description of the response.
  
  The C<success> field of the response will be true if the status code is 2XX.
  
  =head2 post_form
  
      $response = $http->post_form($url, $form_data);
      $response = $http->post_form($url, $form_data, \%options);
  
  This method executes a C<POST> request and sends the key/value pairs from a
  form data hash or array reference to the given URL with a C<content-type> of
  C<application/x-www-form-urlencoded>.  If data is provided as an array
  reference, the order is preserved; if provided as a hash reference, the terms
  are sorted on key and value for consistency.  See documentation for the
  C<www_form_urlencode> method for details on the encoding.
  
  The URL must have unsafe characters escaped and international domain names
  encoded.  See C<request()> for valid options and a description of the response.
  Any C<content-type> header or content in the options hashref will be ignored.
  
  The C<success> field of the response will be true if the status code is 2XX.
  
  =head2 mirror
  
      $response = $http->mirror($url, $file, \%options)
      if ( $response->{success} ) {
          print "$file is up to date\n";
      }
  
  Executes a C<GET> request for the URL and saves the response body to the file
  name provided.  The URL must have unsafe characters escaped and international
  domain names encoded.  If the file already exists, the request will include an
  C<If-Modified-Since> header with the modification timestamp of the file.  You
  may specify a different C<If-Modified-Since> header yourself in the C<<
  $options->{headers} >> hash.
  
  The C<success> field of the response will be true if the status code is 2XX
  or if the status code is 304 (unmodified).
  
  If the file was modified and the server response includes a properly
  formatted C<Last-Modified> header, the file modification time will
  be updated accordingly.
  
  =head2 request
  
      $response = $http->request($method, $url);
      $response = $http->request($method, $url, \%options);
  
  Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST',
  'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and
  international domain names encoded.
  
  If the URL includes a "user:password" stanza, they will be used for Basic-style
  authorization headers.  (Authorization headers will not be included in a
  redirected request.) For example:
  
      $http->request('GET', 'http://Aladdin:open sesame@example.com/');
  
  If the "user:password" stanza contains reserved characters, they must
  be percent-escaped:
  
      $http->request('GET', 'http://john%40example.com:password@example.com/');
  
  A hashref of options may be appended to modify the request.
  
  Valid options are:
  
  =over 4
  
  =item *
  
  C<headers> — A hashref containing headers to include with the request.  If the value for a header is an array reference, the header will be output multiple times with each value in the array.  These headers over-write any default headers.
  
  =item *
  
  C<content> — A scalar to include as the body of the request OR a code reference that will be called iteratively to produce the body of the request
  
  =item *
  
  C<trailer_callback> — A code reference that will be called if it exists to provide a hashref of trailing headers (only used with chunked transfer-encoding)
  
  =item *
  
  C<data_callback> — A code reference that will be called for each chunks of the response body received.
  
  =item *
  
  C<peer> — Override host resolution and force all connections to go only to a specific peer address, regardless of the URL of the request.  This will include any redirections!  This options should be used with extreme caution (e.g. debugging or very special circumstances).
  
  =back
  
  The C<Host> header is generated from the URL in accordance with RFC 2616.  It
  is a fatal error to specify C<Host> in the C<headers> option.  Other headers
  may be ignored or overwritten if necessary for transport compliance.
  
  If the C<content> option is a code reference, it will be called iteratively
  to provide the content body of the request.  It should return the empty
  string or undef when the iterator is exhausted.
  
  If the C<content> option is the empty string, no C<content-type> or
  C<content-length> headers will be generated.
  
  If the C<data_callback> option is provided, it will be called iteratively until
  the entire response body is received.  The first argument will be a string
  containing a chunk of the response body, the second argument will be the
  in-progress response hash reference, as described below.  (This allows
  customizing the action of the callback based on the C<status> or C<headers>
  received prior to the content body.)
  
  The C<request> method returns a hashref containing the response.  The hashref
  will have the following keys:
  
  =over 4
  
  =item *
  
  C<success> — Boolean indicating whether the operation returned a 2XX status code
  
  =item *
  
  C<url> — URL that provided the response. This is the URL of the request unless there were redirections, in which case it is the last URL queried in a redirection chain
  
  =item *
  
  C<status> — The HTTP status code of the response
  
  =item *
  
  C<reason> — The response phrase returned by the server
  
  =item *
  
  C<content> — The body of the response.  If the response does not have any content or if a data callback is provided to consume the response body, this will be the empty string
  
  =item *
  
  C<headers> — A hashref of header fields.  All header field names will be normalized to be lower case. If a header is repeated, the value will be an arrayref; it will otherwise be a scalar string containing the value
  
  =item *
  
  C<redirects> If this field exists, it is an arrayref of response hash references from redirects in the same order that redirections occurred.  If it does not exist, then no redirections occurred.
  
  =back
  
  On an exception during the execution of the request, the C<status> field will
  contain 599, and the C<content> field will contain the text of the exception.
  
  =head2 www_form_urlencode
  
      $params = $http->www_form_urlencode( $data );
      $response = $http->get("http://example.com/query?$params");
  
  This method converts the key/value pairs from a data hash or array reference
  into a C<x-www-form-urlencoded> string.  The keys and values from the data
  reference will be UTF-8 encoded and escaped per RFC 3986.  If a value is an
  array reference, the key will be repeated with each of the values of the array
  reference.  If data is provided as a hash reference, the key/value pairs in the
  resulting string will be sorted by key and value for consistent ordering.
  
  =head2 can_ssl
  
      $ok         = HTTP::Tiny->can_ssl;
      ($ok, $why) = HTTP::Tiny->can_ssl;
      ($ok, $why) = $http->can_ssl;
  
  Indicates if SSL support is available.  When called as a class object, it
  checks for the correct version of L<Net::SSLeay> and L<IO::Socket::SSL>.
  When called as an object methods, if C<SSL_verify> is true or if C<SSL_verify_mode>
  is set in C<SSL_options>, it checks that a CA file is available.
  
  In scalar context, returns a boolean indicating if SSL is available.
  In list context, returns the boolean and a (possibly multi-line) string of
  errors indicating why SSL isn't available.
  
  =head2 connected
  
      $host = $http->connected;
      ($host, $port) = $http->connected;
  
  Indicates if a connection to a peer is being kept alive, per the C<keep_alive>
  option.
  
  In scalar context, returns the peer host and port, joined with a colon, or
  C<undef> (if no peer is connected).
  In list context, returns the peer host and port or an empty list (if no peer
  is connected).
  
  B<Note>: This method cannot reliably be used to discover whether the remote
  host has closed its end of the socket.
  
  =for Pod::Coverage SSL_options
  agent
  cookie_jar
  default_headers
  http_proxy
  https_proxy
  keep_alive
  local_address
  max_redirect
  max_size
  no_proxy
  proxy
  timeout
  verify_SSL
  
  =head1 SSL SUPPORT
  
  Direct C<https> connections are supported only if L<IO::Socket::SSL> 1.56 or
  greater and L<Net::SSLeay> 1.49 or greater are installed. An exception will be
  thrown if new enough versions of these modules are not installed or if the SSL
  encryption fails. You can also use C<HTTP::Tiny::can_ssl()> utility function
  that returns boolean to see if the required modules are installed.
  
  An C<https> connection may be made via an C<http> proxy that supports the CONNECT
  command (i.e. RFC 2817).  You may not proxy C<https> via a proxy that itself
  requires C<https> to communicate.
  
  SSL provides two distinct capabilities:
  
  =over 4
  
  =item *
  
  Encrypted communication channel
  
  =item *
  
  Verification of server identity
  
  =back
  
  B<By default, HTTP::Tiny does not verify server identity>.
  
  Server identity verification is controversial and potentially tricky because it
  depends on a (usually paid) third-party Certificate Authority (CA) trust model
  to validate a certificate as legitimate.  This discriminates against servers
  with self-signed certificates or certificates signed by free, community-driven
  CA's such as L<CAcert.org|http://cacert.org>.
  
  By default, HTTP::Tiny does not make any assumptions about your trust model,
  threat level or risk tolerance.  It just aims to give you an encrypted channel
  when you need one.
  
  Setting the C<verify_SSL> attribute to a true value will make HTTP::Tiny verify
  that an SSL connection has a valid SSL certificate corresponding to the host
  name of the connection and that the SSL certificate has been verified by a CA.
  Assuming you trust the CA, this will protect against a L<man-in-the-middle
  attack|http://en.wikipedia.org/wiki/Man-in-the-middle_attack>.  If you are
  concerned about security, you should enable this option.
  
  Certificate verification requires a file containing trusted CA certificates.
  
  If the environment variable C<SSL_CERT_FILE> is present, HTTP::Tiny
  will try to find a CA certificate file in that location.
  
  If the L<Mozilla::CA> module is installed, HTTP::Tiny will use the CA file
  included with it as a source of trusted CA's.  (This means you trust Mozilla,
  the author of Mozilla::CA, the CPAN mirror where you got Mozilla::CA, the
  toolchain used to install it, and your operating system security, right?)
  
  If that module is not available, then HTTP::Tiny will search several
  system-specific default locations for a CA certificate file:
  
  =over 4
  
  =item *
  
  /etc/ssl/certs/ca-certificates.crt
  
  =item *
  
  /etc/pki/tls/certs/ca-bundle.crt
  
  =item *
  
  /etc/ssl/ca-bundle.pem
  
  =back
  
  An exception will be raised if C<verify_SSL> is true and no CA certificate file
  is available.
  
  If you desire complete control over SSL connections, the C<SSL_options> attribute
  lets you provide a hash reference that will be passed through to
  C<IO::Socket::SSL::start_SSL()>, overriding any options set by HTTP::Tiny. For
  example, to provide your own trusted CA file:
  
      SSL_options => {
          SSL_ca_file => $file_path,
      }
  
  The C<SSL_options> attribute could also be used for such things as providing a
  client certificate for authentication to a server or controlling the choice of
  cipher used for the SSL connection. See L<IO::Socket::SSL> documentation for
  details.
  
  =head1 PROXY SUPPORT
  
  HTTP::Tiny can proxy both C<http> and C<https> requests.  Only Basic proxy
  authorization is supported and it must be provided as part of the proxy URL:
  C<http://user:pass@proxy.example.com/>.
  
  HTTP::Tiny supports the following proxy environment variables:
  
  =over 4
  
  =item *
  
  http_proxy or HTTP_PROXY
  
  =item *
  
  https_proxy or HTTPS_PROXY
  
  =item *
  
  all_proxy or ALL_PROXY
  
  =back
  
  If the C<REQUEST_METHOD> environment variable is set, then this might be a CGI
  process and C<HTTP_PROXY> would be set from the C<Proxy:> header, which is a
  security risk.  If C<REQUEST_METHOD> is set, C<HTTP_PROXY> (the upper case
  variant only) is ignored.
  
  Tunnelling C<https> over an C<http> proxy using the CONNECT method is
  supported.  If your proxy uses C<https> itself, you can not tunnel C<https>
  over it.
  
  Be warned that proxying an C<https> connection opens you to the risk of a
  man-in-the-middle attack by the proxy server.
  
  The C<no_proxy> environment variable is supported in the format of a
  comma-separated list of domain extensions proxy should not be used for.
  
  Proxy arguments passed to C<new> will override their corresponding
  environment variables.
  
  =head1 LIMITATIONS
  
  HTTP::Tiny is I<conditionally compliant> with the
  L<HTTP/1.1 specifications|http://www.w3.org/Protocols/>:
  
  =over 4
  
  =item *
  
  "Message Syntax and Routing" [RFC7230]
  
  =item *
  
  "Semantics and Content" [RFC7231]
  
  =item *
  
  "Conditional Requests" [RFC7232]
  
  =item *
  
  "Range Requests" [RFC7233]
  
  =item *
  
  "Caching" [RFC7234]
  
  =item *
  
  "Authentication" [RFC7235]
  
  =back
  
  It attempts to meet all "MUST" requirements of the specification, but does not
  implement all "SHOULD" requirements.  (Note: it was developed against the
  earlier RFC 2616 specification and may not yet meet the revised RFC 7230-7235
  spec.)
  
  Some particular limitations of note include:
  
  =over
  
  =item *
  
  HTTP::Tiny focuses on correct transport.  Users are responsible for ensuring
  that user-defined headers and content are compliant with the HTTP/1.1
  specification.
  
  =item *
  
  Users must ensure that URLs are properly escaped for unsafe characters and that
  international domain names are properly encoded to ASCII. See L<URI::Escape>,
  L<URI::_punycode> and L<Net::IDN::Encode>.
  
  =item *
  
  Redirection is very strict against the specification.  Redirection is only
  automatic for response codes 301, 302, 307 and 308 if the request method is
  'GET' or 'HEAD'.  Response code 303 is always converted into a 'GET'
  redirection, as mandated by the specification.  There is no automatic support
  for status 305 ("Use proxy") redirections.
  
  =item *
  
  There is no provision for delaying a request body using an C<Expect> header.
  Unexpected C<1XX> responses are silently ignored as per the specification.
  
  =item *
  
  Only 'chunked' C<Transfer-Encoding> is supported.
  
  =item *
  
  There is no support for a Request-URI of '*' for the 'OPTIONS' request.
  
  =item *
  
  Headers mentioned in the RFCs and some other, well-known headers are
  generated with their canonical case.  Other headers are sent in the
  case provided by the user.  Except for control headers (which are sent first),
  headers are sent in arbitrary order.
  
  =back
  
  Despite the limitations listed above, HTTP::Tiny is considered
  feature-complete.  New feature requests should be directed to
  L<HTTP::Tiny::UA>.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<HTTP::Tiny::UA> - Higher level UA features for HTTP::Tiny
  
  =item *
  
  L<HTTP::Thin> - HTTP::Tiny wrapper with L<HTTP::Request>/L<HTTP::Response> compatibility
  
  =item *
  
  L<HTTP::Tiny::Mech> - Wrap L<WWW::Mechanize> instance in HTTP::Tiny compatible interface
  
  =item *
  
  L<IO::Socket::IP> - Required for IPv6 support
  
  =item *
  
  L<IO::Socket::SSL> - Required for SSL support
  
  =item *
  
  L<LWP::UserAgent> - If HTTP::Tiny isn't enough for you, this is the "standard" way to do things
  
  =item *
  
  L<Mozilla::CA> - Required if you want to validate SSL certificates
  
  =item *
  
  L<Net::SSLeay> - Required for SSL support
  
  =back
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/chansen/p5-http-tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/chansen/p5-http-tiny>
  
    git clone https://github.com/chansen/p5-http-tiny.git
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Christian Hansen <chansen@cpan.org>
  
  =item *
  
  David Golden <dagolden@cpan.org>
  
  =back
  
  =head1 CONTRIBUTORS
  
  =for stopwords Alan Gardner Alessandro Ghedini A. Sinan Unur Brad Gilbert brian m. carlson Chris Nehren Weyl Claes Jakobsson Clinton Gormley David Golden Dean Pearce Edward Zborowski James Raspass Jeremy Mates Jess Robinson Lukas Eklund Martin J. Evans Martin-Louis Bright Mike Doherty Olaf Alders Olivier Mengué Petr Písař SkyMarshal Sören Kornetzki Syohei YOSHIDA Tatsuhiko Miyagawa Tom Hukins Tony Cook
  
  =over 4
  
  =item *
  
  Alan Gardner <gardner@pythian.com>
  
  =item *
  
  Alessandro Ghedini <al3xbio@gmail.com>
  
  =item *
  
  A. Sinan Unur <nanis@cpan.org>
  
  =item *
  
  Brad Gilbert <bgills@cpan.org>
  
  =item *
  
  brian m. carlson <sandals@crustytoothpaste.net>
  
  =item *
  
  Chris Nehren <apeiron@cpan.org>
  
  =item *
  
  Chris Weyl <cweyl@alumni.drew.edu>
  
  =item *
  
  Claes Jakobsson <claes@surfar.nu>
  
  =item *
  
  Clinton Gormley <clint@traveljury.com>
  
  =item *
  
  David Golden <xdg@xdg.me>
  
  =item *
  
  Dean Pearce <pearce@pythian.com>
  
  =item *
  
  Edward Zborowski <ed@rubensteintech.com>
  
  =item *
  
  James Raspass <jraspass@gmail.com>
  
  =item *
  
  Jeremy Mates <jmates@cpan.org>
  
  =item *
  
  Jess Robinson <castaway@desert-island.me.uk>
  
  =item *
  
  Lukas Eklund <leklund@gmail.com>
  
  =item *
  
  Martin J. Evans <mjegh@ntlworld.com>
  
  =item *
  
  Martin-Louis Bright <mlbright@gmail.com>
  
  =item *
  
  Mike Doherty <doherty@cpan.org>
  
  =item *
  
  Olaf Alders <olaf@wundersolutions.com>
  
  =item *
  
  Olivier Mengué <dolmen@cpan.org>
  
  =item *
  
  Petr Písař <ppisar@redhat.com>
  
  =item *
  
  SkyMarshal <skymarshal1729@gmail.com>
  
  =item *
  
  Sören Kornetzki <soeren.kornetzki@delti.com>
  
  =item *
  
  Syohei YOSHIDA <syohex@gmail.com>
  
  =item *
  
  Tatsuhiko Miyagawa <miyagawa@bulknews.net>
  
  =item *
  
  Tom Hukins <tom@eborcom.com>
  
  =item *
  
  Tony Cook <tony@develop-help.com>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2016 by Christian Hansen.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
HTTP_TINY

$fatpacked{"IO/Socket/IP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_IP';
  #  You may distribute under the terms of either the GNU General Public License
  #  or the Artistic License (the same terms as Perl itself)
  #
  #  (C) Paul Evans, 2010-2015 -- leonerd@leonerd.org.uk
  
  package IO::Socket::IP;
  # $VERSION needs to be set before  use base 'IO::Socket'
  #  - https://rt.cpan.org/Ticket/Display.html?id=92107
  BEGIN {
     $VERSION = '0.37';
  }
  
  use strict;
  use warnings;
  use base qw( IO::Socket );
  
  use Carp;
  
  use Socket 1.97 qw(
     getaddrinfo getnameinfo
     sockaddr_family
     AF_INET
     AI_PASSIVE
     IPPROTO_TCP IPPROTO_UDP
     IPPROTO_IPV6 IPV6_V6ONLY
     NI_DGRAM NI_NUMERICHOST NI_NUMERICSERV NIx_NOHOST NIx_NOSERV
     SO_REUSEADDR SO_REUSEPORT SO_BROADCAST SO_ERROR
     SOCK_DGRAM SOCK_STREAM
     SOL_SOCKET
  );
  my $AF_INET6 = eval { Socket::AF_INET6() }; # may not be defined
  my $AI_ADDRCONFIG = eval { Socket::AI_ADDRCONFIG() } || 0;
  use POSIX qw( dup2 );
  use Errno qw( EINVAL EINPROGRESS EISCONN ENOTCONN ETIMEDOUT EWOULDBLOCK );
  
  use constant HAVE_MSWIN32 => ( $^O eq "MSWin32" );
  
  # At least one OS (Android) is known not to have getprotobyname()
  use constant HAVE_GETPROTOBYNAME => defined eval { getprotobyname( "tcp" ) };
  
  my $IPv6_re = do {
     # translation of RFC 3986 3.2.2 ABNF to re
     my $IPv4address = do {
        my $dec_octet = q<(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])>;
        qq<$dec_octet(?: \\. $dec_octet){3}>;
     };
     my $IPv6address = do {
        my $h16  = qq<[0-9A-Fa-f]{1,4}>;
        my $ls32 = qq<(?: $h16 : $h16 | $IPv4address)>;
        qq<(?:
                                              (?: $h16 : ){6} $ls32
           |                               :: (?: $h16 : ){5} $ls32
           | (?:                   $h16 )? :: (?: $h16 : ){4} $ls32
           | (?: (?: $h16 : ){0,1} $h16 )? :: (?: $h16 : ){3} $ls32
           | (?: (?: $h16 : ){0,2} $h16 )? :: (?: $h16 : ){2} $ls32
           | (?: (?: $h16 : ){0,3} $h16 )? ::     $h16 :      $ls32
           | (?: (?: $h16 : ){0,4} $h16 )? ::                 $ls32
           | (?: (?: $h16 : ){0,5} $h16 )? ::                 $h16
           | (?: (?: $h16 : ){0,6} $h16 )? ::
        )>
     };
     qr<$IPv6address>xo;
  };
  
  =head1 NAME
  
  C<IO::Socket::IP> - Family-neutral IP socket supporting both IPv4 and IPv6
  
  =head1 SYNOPSIS
  
   use IO::Socket::IP;
  
   my $sock = IO::Socket::IP->new(
      PeerHost => "www.google.com",
      PeerPort => "http",
      Type     => SOCK_STREAM,
   ) or die "Cannot construct socket - $@";
  
   my $familyname = ( $sock->sockdomain == PF_INET6 ) ? "IPv6" :
                    ( $sock->sockdomain == PF_INET  ) ? "IPv4" :
                                                        "unknown";
  
   printf "Connected to google via %s\n", $familyname;
  
  =head1 DESCRIPTION
  
  This module provides a protocol-independent way to use IPv4 and IPv6 sockets,
  intended as a replacement for L<IO::Socket::INET>. Most constructor arguments
  and methods are provided in a backward-compatible way. For a list of known
  differences, see the C<IO::Socket::INET> INCOMPATIBILITES section below.
  
  It uses the C<getaddrinfo(3)> function to convert hostnames and service names
  or port numbers into sets of possible addresses to connect to or listen on.
  This allows it to work for IPv6 where the system supports it, while still
  falling back to IPv4-only on systems which don't.
  
  =head1 REPLACING C<IO::Socket> DEFAULT BEHAVIOUR
  
  By placing C<-register> in the import list, L<IO::Socket> uses
  C<IO::Socket::IP> rather than C<IO::Socket::INET> as the class that handles
  C<PF_INET>.  C<IO::Socket> will also use C<IO::Socket::IP> rather than
  C<IO::Socket::INET6> to handle C<PF_INET6>, provided that the C<AF_INET6>
  constant is available.
  
  Changing C<IO::Socket>'s default behaviour means that calling the
  C<IO::Socket> constructor with either C<PF_INET> or C<PF_INET6> as the
  C<Domain> parameter will yield an C<IO::Socket::IP> object.
  
   use IO::Socket::IP -register;
  
   my $sock = IO::Socket->new(
      Domain    => PF_INET6,
      LocalHost => "::1",
      Listen    => 1,
   ) or die "Cannot create socket - $@\n";
  
   print "Created a socket of type " . ref($sock) . "\n";
  
  Note that C<-register> is a global setting that applies to the entire program;
  it cannot be applied only for certain callers, removed, or limited by lexical
  scope.
  
  =cut
  
  sub import
  {
     my $pkg = shift;
     my @symbols;
  
     foreach ( @_ ) {
        if( $_ eq "-register" ) {
           IO::Socket::IP::_ForINET->register_domain( AF_INET );
           IO::Socket::IP::_ForINET6->register_domain( $AF_INET6 ) if defined $AF_INET6;
        }
        else {
           push @symbols, $_;
        }
     }
  
     @_ = ( $pkg, @symbols );
     goto &IO::Socket::import;
  }
  
  # Convenient capability test function
  {
     my $can_disable_v6only;
     sub CAN_DISABLE_V6ONLY
     {
        return $can_disable_v6only if defined $can_disable_v6only;
  
        socket my $testsock, Socket::PF_INET6(), SOCK_STREAM, 0 or
           die "Cannot socket(PF_INET6) - $!";
  
        if( setsockopt $testsock, IPPROTO_IPV6, IPV6_V6ONLY, 0 ) {
           return $can_disable_v6only = 1;
        }
        elsif( $! == EINVAL ) {
           return $can_disable_v6only = 0;
        }
        else {
           die "Cannot setsockopt() - $!";
        }
     }
  }
  
  =head1 CONSTRUCTORS
  
  =cut
  
  =head2 $sock = IO::Socket::IP->new( %args )
  
  Creates a new C<IO::Socket::IP> object, containing a newly created socket
  handle according to the named arguments passed. The recognised arguments are:
  
  =over 8
  
  =item PeerHost => STRING
  
  =item PeerService => STRING
  
  Hostname and service name for the peer to C<connect()> to. The service name
  may be given as a port number, as a decimal string.
  
  =item PeerAddr => STRING
  
  =item PeerPort => STRING
  
  For symmetry with the accessor methods and compatibility with
  C<IO::Socket::INET>, these are accepted as synonyms for C<PeerHost> and
  C<PeerService> respectively.
  
  =item PeerAddrInfo => ARRAY
  
  Alternate form of specifying the peer to C<connect()> to. This should be an
  array of the form returned by C<Socket::getaddrinfo>.
  
  This parameter takes precedence over the C<Peer*>, C<Family>, C<Type> and
  C<Proto> arguments.
  
  =item LocalHost => STRING
  
  =item LocalService => STRING
  
  Hostname and service name for the local address to C<bind()> to.
  
  =item LocalAddr => STRING
  
  =item LocalPort => STRING
  
  For symmetry with the accessor methods and compatibility with
  C<IO::Socket::INET>, these are accepted as synonyms for C<LocalHost> and
  C<LocalService> respectively.
  
  =item LocalAddrInfo => ARRAY
  
  Alternate form of specifying the local address to C<bind()> to. This should be
  an array of the form returned by C<Socket::getaddrinfo>.
  
  This parameter takes precedence over the C<Local*>, C<Family>, C<Type> and
  C<Proto> arguments.
  
  =item Family => INT
  
  The address family to pass to C<getaddrinfo> (e.g. C<AF_INET>, C<AF_INET6>).
  Normally this will be left undefined, and C<getaddrinfo> will search using any
  address family supported by the system.
  
  =item Type => INT
  
  The socket type to pass to C<getaddrinfo> (e.g. C<SOCK_STREAM>,
  C<SOCK_DGRAM>). Normally defined by the caller; if left undefined
  C<getaddrinfo> may attempt to infer the type from the service name.
  
  =item Proto => STRING or INT
  
  The IP protocol to use for the socket (e.g. C<'tcp'>, C<IPPROTO_TCP>,
  C<'udp'>,C<IPPROTO_UDP>). Normally this will be left undefined, and either
  C<getaddrinfo> or the kernel will choose an appropriate value. May be given
  either in string name or numeric form.
  
  =item GetAddrInfoFlags => INT
  
  More flags to pass to the C<getaddrinfo()> function. If not supplied, a
  default of C<AI_ADDRCONFIG> will be used.
  
  These flags will be combined with C<AI_PASSIVE> if the C<Listen> argument is
  given. For more information see the documentation about C<getaddrinfo()> in
  the L<Socket> module.
  
  =item Listen => INT
  
  If defined, puts the socket into listening mode where new connections can be
  accepted using the C<accept> method. The value given is used as the
  C<listen(2)> queue size.
  
  =item ReuseAddr => BOOL
  
  If true, set the C<SO_REUSEADDR> sockopt
  
  =item ReusePort => BOOL
  
  If true, set the C<SO_REUSEPORT> sockopt (not all OSes implement this sockopt)
  
  =item Broadcast => BOOL
  
  If true, set the C<SO_BROADCAST> sockopt
  
  =item V6Only => BOOL
  
  If defined, set the C<IPV6_V6ONLY> sockopt when creating C<PF_INET6> sockets
  to the given value. If true, a listening-mode socket will only listen on the
  C<AF_INET6> addresses; if false it will also accept connections from
  C<AF_INET> addresses.
  
  If not defined, the socket option will not be changed, and default value set
  by the operating system will apply. For repeatable behaviour across platforms
  it is recommended this value always be defined for listening-mode sockets.
  
  Note that not all platforms support disabling this option. Some, at least
  OpenBSD and MirBSD, will fail with C<EINVAL> if you attempt to disable it.
  To determine whether it is possible to disable, you may use the class method
  
   if( IO::Socket::IP->CAN_DISABLE_V6ONLY ) {
      ...
   }
   else {
      ...
   }
  
  If your platform does not support disabling this option but you still want to
  listen for both C<AF_INET> and C<AF_INET6> connections you will have to create
  two listening sockets, one bound to each protocol.
  
  =item MultiHomed
  
  This C<IO::Socket::INET>-style argument is ignored, except if it is defined
  but false. See the C<IO::Socket::INET> INCOMPATIBILITES section below.
  
  However, the behaviour it enables is always performed by C<IO::Socket::IP>.
  
  =item Blocking => BOOL
  
  If defined but false, the socket will be set to non-blocking mode. Otherwise
  it will default to blocking mode. See the NON-BLOCKING section below for more
  detail.
  
  =item Timeout => NUM
  
  If defined, gives a maximum time in seconds to block per C<connect()> call
  when in blocking mode. If missing, no timeout is applied other than that
  provided by the underlying operating system. When in non-blocking mode this
  parameter is ignored.
  
  Note that if the hostname resolves to multiple address candidates, the same
  timeout will apply to each connection attempt individually, rather than to the
  operation as a whole. Further note that the timeout does not apply to the
  initial hostname resolve operation, if connecting by hostname.
  
  This behviour is copied inspired by C<IO::Socket::INET>; for more fine grained
  control over connection timeouts, consider performing a nonblocking connect
  directly.
  
  =back
  
  If neither C<Type> nor C<Proto> hints are provided, a default of
  C<SOCK_STREAM> and C<IPPROTO_TCP> respectively will be set, to maintain
  compatibility with C<IO::Socket::INET>. Other named arguments that are not
  recognised are ignored.
  
  If neither C<Family> nor any hosts or addresses are passed, nor any
  C<*AddrInfo>, then the constructor has no information on which to decide a
  socket family to create. In this case, it performs a C<getaddinfo> call with
  the C<AI_ADDRCONFIG> flag, no host name, and a service name of C<"0">, and
  uses the family of the first returned result.
  
  If the constructor fails, it will set C<$@> to an appropriate error message;
  this may be from C<$!> or it may be some other string; not every failure
  necessarily has an associated C<errno> value.
  
  =head2 $sock = IO::Socket::IP->new( $peeraddr )
  
  As a special case, if the constructor is passed a single argument (as
  opposed to an even-sized list of key/value pairs), it is taken to be the value
  of the C<PeerAddr> parameter. This is parsed in the same way, according to the
  behaviour given in the C<PeerHost> AND C<LocalHost> PARSING section below.
  
  =cut
  
  sub new
  {
     my $class = shift;
     my %arg = (@_ == 1) ? (PeerHost => $_[0]) : @_;
     return $class->SUPER::new(%arg);
  }
  
  # IO::Socket may call this one; neaten up the arguments from IO::Socket::INET
  # before calling our real _configure method
  sub configure
  {
     my $self = shift;
     my ( $arg ) = @_;
  
     $arg->{PeerHost} = delete $arg->{PeerAddr}
        if exists $arg->{PeerAddr} && !exists $arg->{PeerHost};
  
     $arg->{PeerService} = delete $arg->{PeerPort}
        if exists $arg->{PeerPort} && !exists $arg->{PeerService};
  
     $arg->{LocalHost} = delete $arg->{LocalAddr}
        if exists $arg->{LocalAddr} && !exists $arg->{LocalHost};
  
     $arg->{LocalService} = delete $arg->{LocalPort}
        if exists $arg->{LocalPort} && !exists $arg->{LocalService};
  
     for my $type (qw(Peer Local)) {
        my $host    = $type . 'Host';
        my $service = $type . 'Service';
  
        if( defined $arg->{$host} ) {
           ( $arg->{$host}, my $s ) = $self->split_addr( $arg->{$host} );
           # IO::Socket::INET compat - *Host parsed port always takes precedence
           $arg->{$service} = $s if defined $s;
        }
     }
  
     $self->_io_socket_ip__configure( $arg );
  }
  
  # Avoid simply calling it _configure, as some subclasses of IO::Socket::INET on CPAN already take that
  sub _io_socket_ip__configure
  {
     my $self = shift;
     my ( $arg ) = @_;
  
     my %hints;
     my @localinfos;
     my @peerinfos;
  
     my $listenqueue = $arg->{Listen};
     if( defined $listenqueue and
         ( defined $arg->{PeerHost} || defined $arg->{PeerService} || defined $arg->{PeerAddrInfo} ) ) {
        croak "Cannot Listen with a peer address";
     }
  
     if( defined $arg->{GetAddrInfoFlags} ) {
        $hints{flags} = $arg->{GetAddrInfoFlags};
     }
     else {
        $hints{flags} = $AI_ADDRCONFIG;
     }
  
     if( defined( my $family = $arg->{Family} ) ) {
        $hints{family} = $family;
     }
  
     if( defined( my $type = $arg->{Type} ) ) {
        $hints{socktype} = $type;
     }
  
     if( defined( my $proto = $arg->{Proto} ) ) {
        unless( $proto =~ m/^\d+$/ ) {
           my $protonum = HAVE_GETPROTOBYNAME
              ? getprotobyname( $proto )
              : eval { Socket->${\"IPPROTO_\U$proto"}() };
           defined $protonum or croak "Unrecognised protocol $proto";
           $proto = $protonum;
        }
  
        $hints{protocol} = $proto;
     }
  
     # To maintain compatibility with IO::Socket::INET, imply a default of
     # SOCK_STREAM + IPPROTO_TCP if neither hint is given
     if( !defined $hints{socktype} and !defined $hints{protocol} ) {
        $hints{socktype} = SOCK_STREAM;
        $hints{protocol} = IPPROTO_TCP;
     }
  
     # Some OSes (NetBSD) don't seem to like just a protocol hint without a
     # socktype hint as well. We'll set a couple of common ones
     if( !defined $hints{socktype} and defined $hints{protocol} ) {
        $hints{socktype} = SOCK_STREAM if $hints{protocol} == IPPROTO_TCP;
        $hints{socktype} = SOCK_DGRAM  if $hints{protocol} == IPPROTO_UDP;
     }
  
     if( my $info = $arg->{LocalAddrInfo} ) {
        ref $info eq "ARRAY" or croak "Expected 'LocalAddrInfo' to be an ARRAY ref";
        @localinfos = @$info;
     }
     elsif( defined $arg->{LocalHost} or
            defined $arg->{LocalService} or
            HAVE_MSWIN32 and $arg->{Listen} ) {
        # Either may be undef
        my $host = $arg->{LocalHost};
        my $service = $arg->{LocalService};
  
        unless ( defined $host or defined $service ) {
           $service = 0;
        }
  
        local $1; # Placate a taint-related bug; [perl #67962]
        defined $service and $service =~ s/\((\d+)\)$// and
           my $fallback_port = $1;
  
        my %localhints = %hints;
        $localhints{flags} |= AI_PASSIVE;
        ( my $err, @localinfos ) = getaddrinfo( $host, $service, \%localhints );
  
        if( $err and defined $fallback_port ) {
           ( $err, @localinfos ) = getaddrinfo( $host, $fallback_port, \%localhints );
        }
  
        if( $err ) {
           $@ = "$err";
           $! = EINVAL;
           return;
        }
     }
  
     if( my $info = $arg->{PeerAddrInfo} ) {
        ref $info eq "ARRAY" or croak "Expected 'PeerAddrInfo' to be an ARRAY ref";
        @peerinfos = @$info;
     }
     elsif( defined $arg->{PeerHost} or defined $arg->{PeerService} ) {
        defined( my $host = $arg->{PeerHost} ) or
           croak "Expected 'PeerHost'";
        defined( my $service = $arg->{PeerService} ) or
           croak "Expected 'PeerService'";
  
        local $1; # Placate a taint-related bug; [perl #67962]
        defined $service and $service =~ s/\((\d+)\)$// and
           my $fallback_port = $1;
  
        ( my $err, @peerinfos ) = getaddrinfo( $host, $service, \%hints );
  
        if( $err and defined $fallback_port ) {
           ( $err, @peerinfos ) = getaddrinfo( $host, $fallback_port, \%hints );
        }
  
        if( $err ) {
           $@ = "$err";
           $! = EINVAL;
           return;
        }
     }
  
     my @sockopts_enabled;
     push @sockopts_enabled, SO_REUSEADDR if $arg->{ReuseAddr};
     push @sockopts_enabled, SO_REUSEPORT if $arg->{ReusePort};
     push @sockopts_enabled, SO_BROADCAST if $arg->{Broadcast};
  
     my $blocking = $arg->{Blocking};
     defined $blocking or $blocking = 1;
  
     my $v6only = $arg->{V6Only};
  
     # IO::Socket::INET defines this key. IO::Socket::IP always implements the
     # behaviour it requests, so we can ignore it, unless the caller is for some
     # reason asking to disable it.
     if( defined $arg->{MultiHomed} and !$arg->{MultiHomed} ) {
        croak "Cannot disable the MultiHomed parameter";
     }
  
     my @infos;
     foreach my $local ( @localinfos ? @localinfos : {} ) {
        foreach my $peer ( @peerinfos ? @peerinfos : {} ) {
           next if defined $local->{family}   and defined $peer->{family}   and
              $local->{family} != $peer->{family};
           next if defined $local->{socktype} and defined $peer->{socktype} and
              $local->{socktype} != $peer->{socktype};
           next if defined $local->{protocol} and defined $peer->{protocol} and
              $local->{protocol} != $peer->{protocol};
  
           my $family   = $local->{family}   || $peer->{family}   or next;
           my $socktype = $local->{socktype} || $peer->{socktype} or next;
           my $protocol = $local->{protocol} || $peer->{protocol} || 0;
  
           push @infos, {
              family    => $family,
              socktype  => $socktype,
              protocol  => $protocol,
              localaddr => $local->{addr},
              peeraddr  => $peer->{addr},
           };
        }
     }
  
     if( !@infos ) {
        # If there was a Family hint then create a plain unbound, unconnected socket
        if( defined $hints{family} ) {
           @infos = ( {
              family   => $hints{family},
              socktype => $hints{socktype},
              protocol => $hints{protocol},
           } );
        }
        # If there wasn't, use getaddrinfo()'s AI_ADDRCONFIG side-effect to guess a
        # suitable family first.
        else {
           ( my $err, @infos ) = getaddrinfo( "", "0", \%hints );
           if( $err ) {
              $@ = "$err";
              $! = EINVAL;
              return;
           }
  
           # We'll take all the @infos anyway, because some OSes (HPUX) are known to
           # ignore the AI_ADDRCONFIG hint and return AF_INET6 even if they don't
           # support them
        }
     }
  
     # In the nonblocking case, caller will be calling ->setup multiple times.
     # Store configuration in the object for the ->setup method
     # Yes, these are messy. Sorry, I can't help that...
  
     ${*$self}{io_socket_ip_infos} = \@infos;
  
     ${*$self}{io_socket_ip_idx} = -1;
  
     ${*$self}{io_socket_ip_sockopts} = \@sockopts_enabled;
     ${*$self}{io_socket_ip_v6only} = $v6only;
     ${*$self}{io_socket_ip_listenqueue} = $listenqueue;
     ${*$self}{io_socket_ip_blocking} = $blocking;
  
     ${*$self}{io_socket_ip_errors} = [ undef, undef, undef ];
  
     # ->setup is allowed to return false in nonblocking mode
     $self->setup or !$blocking or return undef;
  
     return $self;
  }
  
  sub setup
  {
     my $self = shift;
  
     while(1) {
        ${*$self}{io_socket_ip_idx}++;
        last if ${*$self}{io_socket_ip_idx} >= @{ ${*$self}{io_socket_ip_infos} };
  
        my $info = ${*$self}{io_socket_ip_infos}->[${*$self}{io_socket_ip_idx}];
  
        $self->socket( @{$info}{qw( family socktype protocol )} ) or
           ( ${*$self}{io_socket_ip_errors}[2] = $!, next );
  
        $self->blocking( 0 ) unless ${*$self}{io_socket_ip_blocking};
  
        foreach my $sockopt ( @{ ${*$self}{io_socket_ip_sockopts} } ) {
           $self->setsockopt( SOL_SOCKET, $sockopt, pack "i", 1 ) or ( $@ = "$!", return undef );
        }
  
        if( defined ${*$self}{io_socket_ip_v6only} and defined $AF_INET6 and $info->{family} == $AF_INET6 ) {
           my $v6only = ${*$self}{io_socket_ip_v6only};
           $self->setsockopt( IPPROTO_IPV6, IPV6_V6ONLY, pack "i", $v6only ) or ( $@ = "$!", return undef );
        }
  
        if( defined( my $addr = $info->{localaddr} ) ) {
           $self->bind( $addr ) or
              ( ${*$self}{io_socket_ip_errors}[1] = $!, next );
        }
  
        if( defined( my $listenqueue = ${*$self}{io_socket_ip_listenqueue} ) ) {
           $self->listen( $listenqueue ) or ( $@ = "$!", return undef );
        }
  
        if( defined( my $addr = $info->{peeraddr} ) ) {
           if( $self->connect( $addr ) ) {
              $! = 0;
              return 1;
           }
  
           if( $! == EINPROGRESS or $! == EWOULDBLOCK ) {
              ${*$self}{io_socket_ip_connect_in_progress} = 1;
              return 0;
           }
  
           # If connect failed but we have no system error there must be an error
           # at the application layer, like a bad certificate with
           # IO::Socket::SSL.
           # In this case don't continue IP based multi-homing because the problem
           # cannot be solved at the IP layer.
           return 0 if ! $!;
  
           ${*$self}{io_socket_ip_errors}[0] = $!;
           next;
        }
  
        return 1;
     }
  
     # Pick the most appropriate error, stringified
     $! = ( grep defined, @{ ${*$self}{io_socket_ip_errors}} )[0];
     $@ = "$!";
     return undef;
  }
  
  sub connect :method
  {
     my $self = shift;
  
     # It seems that IO::Socket hides EINPROGRESS errors, making them look like
     # a success. This is annoying here.
     # Instead of putting up with its frankly-irritating intentional breakage of
     # useful APIs I'm just going to end-run around it and call core's connect()
     # directly
  
     if( @_ ) {
        my ( $addr ) = @_;
  
        # Annoyingly IO::Socket's connect() is where the timeout logic is
        # implemented, so we'll have to reinvent it here
        my $timeout = ${*$self}{'io_socket_timeout'};
  
        return connect( $self, $addr ) unless defined $timeout;
  
        my $was_blocking = $self->blocking( 0 );
  
        my $err = defined connect( $self, $addr ) ? 0 : $!+0;
  
        if( !$err ) {
           # All happy
           $self->blocking( $was_blocking );
           return 1;
        }
        elsif( not( $err == EINPROGRESS or $err == EWOULDBLOCK ) ) {
           # Failed for some other reason
           return undef;
        }
        elsif( !$was_blocking ) {
           # We shouldn't block anyway
           return undef;
        }
  
        my $vec = ''; vec( $vec, $self->fileno, 1 ) = 1;
        if( !select( undef, $vec, $vec, $timeout ) ) {
           $! = ETIMEDOUT;
           return undef;
        }
  
        # Hoist the error by connect()ing a second time
        $err = $self->getsockopt( SOL_SOCKET, SO_ERROR );
        $err = 0 if $err == EISCONN; # Some OSes give EISCONN
  
        $self->blocking( $was_blocking );
  
        $! = $err, return undef if $err;
        return 1;
     }
  
     return 1 if !${*$self}{io_socket_ip_connect_in_progress};
  
     # See if a connect attempt has just failed with an error
     if( my $errno = $self->getsockopt( SOL_SOCKET, SO_ERROR ) ) {
        delete ${*$self}{io_socket_ip_connect_in_progress};
        ${*$self}{io_socket_ip_errors}[0] = $! = $errno;
        return $self->setup;
     }
  
     # No error, so either connect is still in progress, or has completed
     # successfully. We can tell by trying to connect() again; either it will
     # succeed or we'll get EISCONN (connected successfully), or EALREADY
     # (still in progress). This even works on MSWin32.
     my $addr = ${*$self}{io_socket_ip_infos}[${*$self}{io_socket_ip_idx}]{peeraddr};
  
     if( connect( $self, $addr ) or $! == EISCONN ) {
        delete ${*$self}{io_socket_ip_connect_in_progress};
        $! = 0;
        return 1;
     }
     else {
        $! = EINPROGRESS;
        return 0;
     }
  }
  
  sub connected
  {
     my $self = shift;
     return defined $self->fileno &&
            !${*$self}{io_socket_ip_connect_in_progress} &&
            defined getpeername( $self ); # ->peername caches, we need to detect disconnection
  }
  
  =head1 METHODS
  
  As well as the following methods, this class inherits all the methods in
  L<IO::Socket> and L<IO::Handle>.
  
  =cut
  
  sub _get_host_service
  {
     my $self = shift;
     my ( $addr, $flags, $xflags ) = @_;
  
     defined $addr or
        $! = ENOTCONN, return;
  
     $flags |= NI_DGRAM if $self->socktype == SOCK_DGRAM;
  
     my ( $err, $host, $service ) = getnameinfo( $addr, $flags, $xflags || 0 );
     croak "getnameinfo - $err" if $err;
  
     return ( $host, $service );
  }
  
  sub _unpack_sockaddr
  {
     my ( $addr ) = @_;
     my $family = sockaddr_family $addr;
  
     if( $family == AF_INET ) {
        return ( Socket::unpack_sockaddr_in( $addr ) )[1];
     }
     elsif( defined $AF_INET6 and $family == $AF_INET6 ) {
        return ( Socket::unpack_sockaddr_in6( $addr ) )[1];
     }
     else {
        croak "Unrecognised address family $family";
     }
  }
  
  =head2 ( $host, $service ) = $sock->sockhost_service( $numeric )
  
  Returns the hostname and service name of the local address (that is, the
  socket address given by the C<sockname> method).
  
  If C<$numeric> is true, these will be given in numeric form rather than being
  resolved into names.
  
  The following four convenience wrappers may be used to obtain one of the two
  values returned here. If both host and service names are required, this method
  is preferable to the following wrappers, because it will call
  C<getnameinfo(3)> only once.
  
  =cut
  
  sub sockhost_service
  {
     my $self = shift;
     my ( $numeric ) = @_;
  
     $self->_get_host_service( $self->sockname, $numeric ? NI_NUMERICHOST|NI_NUMERICSERV : 0 );
  }
  
  =head2 $addr = $sock->sockhost
  
  Return the numeric form of the local address as a textual representation
  
  =head2 $port = $sock->sockport
  
  Return the numeric form of the local port number
  
  =head2 $host = $sock->sockhostname
  
  Return the resolved name of the local address
  
  =head2 $service = $sock->sockservice
  
  Return the resolved name of the local port number
  
  =cut
  
  sub sockhost { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, NI_NUMERICHOST, NIx_NOSERV ) )[0] }
  sub sockport { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, NI_NUMERICSERV, NIx_NOHOST ) )[1] }
  
  sub sockhostname { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, 0, NIx_NOSERV ) )[0] }
  sub sockservice  { my $self = shift; scalar +( $self->_get_host_service( $self->sockname, 0, NIx_NOHOST ) )[1] }
  
  =head2 $addr = $sock->sockaddr
  
  Return the local address as a binary octet string
  
  =cut
  
  sub sockaddr { my $self = shift; _unpack_sockaddr $self->sockname }
  
  =head2 ( $host, $service ) = $sock->peerhost_service( $numeric )
  
  Returns the hostname and service name of the peer address (that is, the
  socket address given by the C<peername> method), similar to the
  C<sockhost_service> method.
  
  The following four convenience wrappers may be used to obtain one of the two
  values returned here. If both host and service names are required, this method
  is preferable to the following wrappers, because it will call
  C<getnameinfo(3)> only once.
  
  =cut
  
  sub peerhost_service
  {
     my $self = shift;
     my ( $numeric ) = @_;
  
     $self->_get_host_service( $self->peername, $numeric ? NI_NUMERICHOST|NI_NUMERICSERV : 0 );
  }
  
  =head2 $addr = $sock->peerhost
  
  Return the numeric form of the peer address as a textual representation
  
  =head2 $port = $sock->peerport
  
  Return the numeric form of the peer port number
  
  =head2 $host = $sock->peerhostname
  
  Return the resolved name of the peer address
  
  =head2 $service = $sock->peerservice
  
  Return the resolved name of the peer port number
  
  =cut
  
  sub peerhost { my $self = shift; scalar +( $self->_get_host_service( $self->peername, NI_NUMERICHOST, NIx_NOSERV ) )[0] }
  sub peerport { my $self = shift; scalar +( $self->_get_host_service( $self->peername, NI_NUMERICSERV, NIx_NOHOST ) )[1] }
  
  sub peerhostname { my $self = shift; scalar +( $self->_get_host_service( $self->peername, 0, NIx_NOSERV ) )[0] }
  sub peerservice  { my $self = shift; scalar +( $self->_get_host_service( $self->peername, 0, NIx_NOHOST ) )[1] }
  
  =head2 $addr = $peer->peeraddr
  
  Return the peer address as a binary octet string
  
  =cut
  
  sub peeraddr { my $self = shift; _unpack_sockaddr $self->peername }
  
  # This unbelievably dodgy hack works around the bug that IO::Socket doesn't do
  # it
  #    https://rt.cpan.org/Ticket/Display.html?id=61577
  sub accept
  {
     my $self = shift;
     my ( $new, $peer ) = $self->SUPER::accept( @_ ) or return;
  
     ${*$new}{$_} = ${*$self}{$_} for qw( io_socket_domain io_socket_type io_socket_proto );
  
     return wantarray ? ( $new, $peer )
                      : $new;
  }
  
  # This second unbelievably dodgy hack guarantees that $self->fileno doesn't
  # change, which is useful during nonblocking connect
  sub socket :method
  {
     my $self = shift;
     return $self->SUPER::socket(@_) if not defined $self->fileno;
  
     # I hate core prototypes sometimes...
     socket( my $tmph, $_[0], $_[1], $_[2] ) or return undef;
  
     dup2( $tmph->fileno, $self->fileno ) or die "Unable to dup2 $tmph onto $self - $!";
  }
  
  # Versions of IO::Socket before 1.35 may leave socktype undef if from, say, an
  #   ->fdopen call. In this case we'll apply a fix
  BEGIN {
     if( eval($IO::Socket::VERSION) < 1.35 ) {
        *socktype = sub {
           my $self = shift;
           my $type = $self->SUPER::socktype;
           if( !defined $type ) {
              $type = $self->sockopt( Socket::SO_TYPE() );
           }
           return $type;
        };
     }
  }
  
  =head2 $inet = $sock->as_inet
  
  Returns a new L<IO::Socket::INET> instance wrapping the same filehandle. This
  may be useful in cases where it is required, for backward-compatibility, to
  have a real object of C<IO::Socket::INET> type instead of C<IO::Socket::IP>.
  The new object will wrap the same underlying socket filehandle as the
  original, so care should be taken not to continue to use both objects
  concurrently. Ideally the original C<$sock> should be discarded after this
  method is called.
  
  This method checks that the socket domain is C<PF_INET> and will throw an
  exception if it isn't.
  
  =cut
  
  sub as_inet
  {
     my $self = shift;
     croak "Cannot downgrade a non-PF_INET socket to IO::Socket::INET" unless $self->sockdomain == AF_INET;
     return IO::Socket::INET->new_from_fd( $self->fileno, "r+" );
  }
  
  =head1 NON-BLOCKING
  
  If the constructor is passed a defined but false value for the C<Blocking>
  argument then the socket is put into non-blocking mode. When in non-blocking
  mode, the socket will not be set up by the time the constructor returns,
  because the underlying C<connect(2)> syscall would otherwise have to block.
  
  The non-blocking behaviour is an extension of the C<IO::Socket::INET> API,
  unique to C<IO::Socket::IP>, because the former does not support multi-homed
  non-blocking connect.
  
  When using non-blocking mode, the caller must repeatedly check for
  writeability on the filehandle (for instance using C<select> or C<IO::Poll>).
  Each time the filehandle is ready to write, the C<connect> method must be
  called, with no arguments. Note that some operating systems, most notably
  C<MSWin32> do not report a C<connect()> failure using write-ready; so you must
  also C<select()> for exceptional status.
  
  While C<connect> returns false, the value of C<$!> indicates whether it should
  be tried again (by being set to the value C<EINPROGRESS>, or C<EWOULDBLOCK> on
  MSWin32), or whether a permanent error has occurred (e.g. C<ECONNREFUSED>).
  
  Once the socket has been connected to the peer, C<connect> will return true
  and the socket will now be ready to use.
  
  Note that calls to the platform's underlying C<getaddrinfo(3)> function may
  block. If C<IO::Socket::IP> has to perform this lookup, the constructor will
  block even when in non-blocking mode.
  
  To avoid this blocking behaviour, the caller should pass in the result of such
  a lookup using the C<PeerAddrInfo> or C<LocalAddrInfo> arguments. This can be
  achieved by using L<Net::LibAsyncNS>, or the C<getaddrinfo(3)> function can be
  called in a child process.
  
   use IO::Socket::IP;
   use Errno qw( EINPROGRESS EWOULDBLOCK );
  
   my @peeraddrinfo = ... # Caller must obtain the getaddinfo result here
  
   my $socket = IO::Socket::IP->new(
      PeerAddrInfo => \@peeraddrinfo,
      Blocking     => 0,
   ) or die "Cannot construct socket - $@";
  
   while( !$socket->connect and ( $! == EINPROGRESS || $! == EWOULDBLOCK ) ) {
      my $wvec = '';
      vec( $wvec, fileno $socket, 1 ) = 1;
      my $evec = '';
      vec( $evec, fileno $socket, 1 ) = 1;
  
      select( undef, $wvec, $evec, undef ) or die "Cannot select - $!";
   }
  
   die "Cannot connect - $!" if $!;
  
   ...
  
  The example above uses C<select()>, but any similar mechanism should work
  analogously. C<IO::Socket::IP> takes care when creating new socket filehandles
  to preserve the actual file descriptor number, so such techniques as C<poll>
  or C<epoll> should be transparent to its reallocation of a different socket
  underneath, perhaps in order to switch protocol family between C<PF_INET> and
  C<PF_INET6>.
  
  For another example using C<IO::Poll> and C<Net::LibAsyncNS>, see the
  F<examples/nonblocking_libasyncns.pl> file in the module distribution.
  
  =cut
  
  =head1 C<PeerHost> AND C<LocalHost> PARSING
  
  To support the C<IO::Socket::INET> API, the host and port information may be
  passed in a single string rather than as two separate arguments.
  
  If either C<LocalHost> or C<PeerHost> (or their C<...Addr> synonyms) have any
  of the following special forms then special parsing is applied.
  
  The value of the C<...Host> argument will be split to give both the hostname
  and port (or service name):
  
   hostname.example.org:http    # Host name
   192.0.2.1:80                 # IPv4 address
   [2001:db8::1]:80             # IPv6 address
  
  In each case, the port or service name (e.g. C<80>) is passed as the
  C<LocalService> or C<PeerService> argument.
  
  Either of C<LocalService> or C<PeerService> (or their C<...Port> synonyms) can
  be either a service name, a decimal number, or a string containing both a
  service name and number, in a form such as
  
   http(80)
  
  In this case, the name (C<http>) will be tried first, but if the resolver does
  not understand it then the port number (C<80>) will be used instead.
  
  If the C<...Host> argument is in this special form and the corresponding
  C<...Service> or C<...Port> argument is also defined, the one parsed from
  the C<...Host> argument will take precedence and the other will be ignored.
  
  =head2 ( $host, $port ) = IO::Socket::IP->split_addr( $addr )
  
  Utility method that provides the parsing functionality described above.
  Returns a 2-element list, containing either the split hostname and port
  description if it could be parsed, or the given address and C<undef> if it was
  not recognised.
  
   IO::Socket::IP->split_addr( "hostname:http" )
                                # ( "hostname",  "http" )
  
   IO::Socket::IP->split_addr( "192.0.2.1:80" )
                                # ( "192.0.2.1", "80"   )
  
   IO::Socket::IP->split_addr( "[2001:db8::1]:80" )
                                # ( "2001:db8::1", "80" )
  
   IO::Socket::IP->split_addr( "something.else" )
                                # ( "something.else", undef )
  
  =cut
  
  sub split_addr
  {
     shift;
     my ( $addr ) = @_;
  
     local ( $1, $2 ); # Placate a taint-related bug; [perl #67962]
     if( $addr =~ m/\A\[($IPv6_re)\](?::([^\s:]*))?\z/ or
         $addr =~ m/\A([^\s:]*):([^\s:]*)\z/ ) {
        return ( $1, $2 ) if defined $2 and length $2;
        return ( $1, undef );
     }
  
     return ( $addr, undef );
  }
  
  =head2 $addr = IO::Socket::IP->join_addr( $host, $port )
  
  Utility method that performs the reverse of C<split_addr>, returning a string
  formed by joining the specified host address and port number. The host address
  will be wrapped in C<[]> brackets if required (because it is a raw IPv6
  numeric address).
  
  This can be especially useful when combined with the C<sockhost_service> or
  C<peerhost_service> methods.
  
   say "Connected to ", IO::Socket::IP->join_addr( $sock->peerhost_service );
  
  =cut
  
  sub join_addr
  {
     shift;
     my ( $host, $port ) = @_;
  
     $host = "[$host]" if $host =~ m/:/;
  
     return join ":", $host, $port if defined $port;
     return $host;
  }
  
  # Since IO::Socket->new( Domain => ... ) will delete the Domain parameter
  # before calling ->configure, we need to keep track of which it was
  
  package # hide from indexer
     IO::Socket::IP::_ForINET;
  use base qw( IO::Socket::IP );
  
  sub configure
  {
     # This is evil
     my $self = shift;
     my ( $arg ) = @_;
  
     bless $self, "IO::Socket::IP";
     $self->configure( { %$arg, Family => Socket::AF_INET() } );
  }
  
  package # hide from indexer
     IO::Socket::IP::_ForINET6;
  use base qw( IO::Socket::IP );
  
  sub configure
  {
     # This is evil
     my $self = shift;
     my ( $arg ) = @_;
  
     bless $self, "IO::Socket::IP";
     $self->configure( { %$arg, Family => Socket::AF_INET6() } );
  }
  
  =head1 C<IO::Socket::INET> INCOMPATIBILITES
  
  =over 4
  
  =item *
  
  The behaviour enabled by C<MultiHomed> is in fact implemented by
  C<IO::Socket::IP> as it is required to correctly support searching for a
  useable address from the results of the C<getaddrinfo(3)> call. The
  constructor will ignore the value of this argument, except if it is defined
  but false. An exception is thrown in this case, because that would request it
  disable the C<getaddrinfo(3)> search behaviour in the first place.
  
  =item *
  
  C<IO::Socket::IP> implements both the C<Blocking> and C<Timeout> parameters,
  but it implements the interaction of both in a different way.
  
  In C<::INET>, supplying a timeout overrides the non-blocking behaviour,
  meaning that the C<connect()> operation will still block despite that the
  caller asked for a non-blocking socket. This is not explicitly specified in
  its documentation, nor does this author believe that is a useful behaviour -
  it appears to come from a quirk of implementation.
  
  In C<::IP> therefore, the C<Blocking> parameter takes precedence - if a
  non-blocking socket is requested, no operation will block. The C<Timeout>
  parameter here simply defines the maximum time that a blocking C<connect()>
  call will wait, if it blocks at all.
  
  In order to specifically obtain the "blocking connect then non-blocking send
  and receive" behaviour of specifying this combination of options to C<::INET>
  when using C<::IP>, perform first a blocking connect, then afterwards turn the
  socket into nonblocking mode.
  
   my $sock = IO::Socket::IP->new(
      PeerHost => $peer,
      Timeout => 20,
   ) or die "Cannot connect - $@";
  
   $sock->blocking( 0 );
  
  This code will behave identically under both C<IO::Socket::INET> and
  C<IO::Socket::IP>.
  
  =back
  
  =cut
  
  =head1 TODO
  
  =over 4
  
  =item *
  
  Investigate whether C<POSIX::dup2> upsets BSD's C<kqueue> watchers, and if so,
  consider what possible workarounds might be applied.
  
  =back
  
  =head1 AUTHOR
  
  Paul Evans <leonerd@leonerd.org.uk>
  
  =cut
  
  0x55AA;
IO_SOCKET_IP

$fatpacked{"IO/Socket/SSL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_SSL';
  #vim: set sts=4 sw=4 ts=8 ai:
  #
  # IO::Socket::SSL:
  # provide an interface to SSL connections similar to IO::Socket modules
  #
  # Current Code Shepherd: Steffen Ullrich <sullr at cpan.org>
  # Code Shepherd before: Peter Behroozi, <behrooz at fas.harvard.edu>
  #
  # The original version of this module was written by
  # Marko Asplund, <marko.asplund at kronodoc.fi>, who drew from
  # Crypt::SSLeay (Net::SSL) by Gisle Aas.
  #
  
  package IO::Socket::SSL;
  
  our $VERSION = '2.066';
  
  use IO::Socket;
  use Net::SSLeay 1.46;
  use IO::Socket::SSL::PublicSuffix;
  use Exporter ();
  use Errno qw( EWOULDBLOCK EAGAIN ETIMEDOUT EINTR EPIPE );
  use Carp;
  use strict;
  
  my $use_threads;
  BEGIN {
      die "no support for weaken - please install Scalar::Util" if ! do {
  	local $SIG{__DIE__};
  	eval { require Scalar::Util; Scalar::Util->import("weaken"); 1 }
  	    || eval { require WeakRef; WeakRef->import("weaken"); 1 }
      };
      require Config;
      $use_threads = $Config::Config{usethreads};
  }
  
  
  # results from commonly used constant functions from Net::SSLeay for fast access
  my $Net_SSLeay_ERROR_WANT_READ   = Net::SSLeay::ERROR_WANT_READ();
  my $Net_SSLeay_ERROR_WANT_WRITE  = Net::SSLeay::ERROR_WANT_WRITE();
  my $Net_SSLeay_ERROR_SYSCALL     = Net::SSLeay::ERROR_SYSCALL();
  my $Net_SSLeay_VERIFY_NONE       = Net::SSLeay::VERIFY_NONE();
  my $Net_SSLeay_VERIFY_PEER       = Net::SSLeay::VERIFY_PEER();
  
  
  use constant SSL_VERIFY_NONE => &Net::SSLeay::VERIFY_NONE;
  use constant SSL_VERIFY_PEER => &Net::SSLeay::VERIFY_PEER;
  use constant SSL_VERIFY_FAIL_IF_NO_PEER_CERT => Net::SSLeay::VERIFY_FAIL_IF_NO_PEER_CERT();
  use constant SSL_VERIFY_CLIENT_ONCE => Net::SSLeay::VERIFY_CLIENT_ONCE();
  
  # from openssl/ssl.h; should be better in Net::SSLeay
  use constant SSL_SENT_SHUTDOWN => 1;
  use constant SSL_RECEIVED_SHUTDOWN => 2;
  
  use constant SSL_OCSP_NO_STAPLE   => 0b00001;
  use constant SSL_OCSP_MUST_STAPLE => 0b00010;
  use constant SSL_OCSP_FAIL_HARD   => 0b00100;
  use constant SSL_OCSP_FULL_CHAIN  => 0b01000;
  use constant SSL_OCSP_TRY_STAPLE  => 0b10000;
  
  # capabilities of underlying Net::SSLeay/openssl
  my $can_client_sni;  # do we support SNI on the client side
  my $can_server_sni;  # do we support SNI on the server side
  my $can_multi_cert;  # RSA and ECC certificate in same context
  my $can_npn;         # do we support NPN (obsolete)
  my $can_alpn;        # do we support ALPN
  my $can_ecdh;        # do we support ECDH key exchange
  my $set_groups_list; # SSL_CTX_set1_groups_list || SSL_CTX_set1_curves_list || undef
  my $can_ocsp;        # do we support OCSP
  my $can_ocsp_staple; # do we support OCSP stapling
  my $can_tckt_keycb;  # TLS ticket key callback
  my $can_pha;         # do we support PHA
  my $session_upref;   # SSL_SESSION_up_ref is implemented
  my %sess_cb;         # SSL_CTX_sess_set_(new|remove)_cb
  my $check_partial_chain; # use X509_V_FLAG_PARTIAL_CHAIN if available
  
  my $openssl_version;
  my $netssleay_version;
  
  BEGIN {
      $openssl_version = Net::SSLeay::OPENSSL_VERSION_NUMBER();
      $netssleay_version = do { no warnings; $Net::SSLeay::VERSION + 0.0; };
      $can_client_sni = $openssl_version >= 0x10000000;
      $can_server_sni = defined &Net::SSLeay::get_servername;
      $can_npn = defined &Net::SSLeay::P_next_proto_negotiated &&
  	! Net::SSLeay::constant("LIBRESSL_VERSION_NUMBER");
  	# LibreSSL 2.6.1 disabled NPN by keeping the relevant functions
  	# available but removed the actual functionality from these functions.
      $can_alpn = defined &Net::SSLeay::CTX_set_alpn_protos;
      $can_ecdh =
  	($openssl_version >= 0x1010000f) ? 'auto' :
  	defined(&Net::SSLeay::CTX_set_ecdh_auto) ? 'can_auto' :
  	(defined &Net::SSLeay::CTX_set_tmp_ecdh &&
  	    # There is a regression with elliptic curves on 1.0.1d with 64bit
  	    # http://rt.openssl.org/Ticket/Display.html?id=2975
  	    ( $openssl_version != 0x1000104f
  	    || length(pack("P",0)) == 4 )) ? 'tmp_ecdh' :
  	    '';
      $set_groups_list =
  	defined &Net::SSLeay::CTX_set1_groups_list ? \&Net::SSLeay::CTX_set1_groups_list :
  	defined &Net::SSLeay::CTX_set1_curves_list ? \&Net::SSLeay::CTX_set1_curves_list :
  	undef;
      $can_multi_cert = $can_ecdh
  	&& $openssl_version >= 0x10002000;
      $can_ocsp = defined &Net::SSLeay::OCSP_cert2ids
  	# OCSP got broken in 1.75..1.77
  	&& ($netssleay_version < 1.75 || $netssleay_version > 1.77);
      $can_ocsp_staple = $can_ocsp
  	&& defined &Net::SSLeay::set_tlsext_status_type;
      $can_tckt_keycb  = defined &Net::SSLeay::CTX_set_tlsext_ticket_getkey_cb
  	&& $netssleay_version >= 1.80;  
      $can_pha = defined &Net::SSLeay::CTX_set_post_handshake_auth;
  
      if (defined &Net::SSLeay::SESSION_up_ref) {
  	$session_upref = 1;
      }
  
      if ($session_upref
  	&& defined &Net::SSLeay::CTX_sess_set_new_cb
  	&& defined &Net::SSLeay::CTX_sess_set_remove_cb) {
  	%sess_cb = (
  	    new => \&Net::SSLeay::CTX_sess_set_new_cb,
  	    remove => \&Net::SSLeay::CTX_sess_set_remove_cb,
  	);
      }
  
      if (my $c = defined &Net::SSLeay::CTX_get0_param
  	&& eval { Net::SSLeay::X509_V_FLAG_PARTIAL_CHAIN() }) {
  	$check_partial_chain = sub {
  	    my $ctx = shift;
  	    my $param = Net::SSLeay::CTX_get0_param($ctx);
  	    Net::SSLeay::X509_VERIFY_PARAM_set_flags($param, $c);
  	};
      }
  }
  
  my $algo2digest = do {
      my %digest;
      sub {
  	my $digest_name = shift;
  	return $digest{$digest_name} ||= do {
  	    Net::SSLeay::SSLeay_add_ssl_algorithms();
  	    Net::SSLeay::EVP_get_digestbyname($digest_name)
  		or die "Digest algorithm $digest_name is not available";
  	};
      }
  };
  
  my $CTX_tlsv1_3_new;
  if ( defined &Net::SSLeay::CTX_set_min_proto_version
      and defined &Net::SSLeay::CTX_set_max_proto_version
      and my $tls13 = eval { Net::SSLeay::TLS1_3_VERSION() }
  ) {
      $CTX_tlsv1_3_new = sub {
  	my $ctx = Net::SSLeay::CTX_new();
  	return $ctx if Net::SSLeay::CTX_set_min_proto_version($ctx,$tls13)
  	    && Net::SSLeay::CTX_set_max_proto_version($ctx,$tls13);
  	Net::SSLeay::CTX_free($ctx);
  	return;
      };
  }
  
  
  # global defaults
  my %DEFAULT_SSL_ARGS = (
      SSL_check_crl => 0,
      SSL_version => 'SSLv23:!SSLv3:!SSLv2', # consider both SSL3.0 and SSL2.0 as broken
      SSL_verify_callback => undef,
      SSL_verifycn_scheme => undef,  # fallback cn verification
      SSL_verifycn_publicsuffix => undef,  # fallback default list verification
      #SSL_verifycn_name => undef,   # use from PeerAddr/PeerHost - do not override in set_args_filter_hack 'use_defaults'
      SSL_npn_protocols => undef,    # meaning depends whether on server or client side
      SSL_alpn_protocols => undef,   # list of protocols we'll accept/send, for example ['http/1.1','spdy/3.1']
  
      # https://wiki.mozilla.org/Security/Server_Side_TLS, 2019/03/05
      # "Old backward compatibility" for best compatibility
      # .. "Most ciphers that are not clearly broken and dangerous to use are supported"
      # slightly reordered to prefer AES since it is cheaper when hardware accelerated
      SSL_cipher_list => 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:DES-CBC3-SHA:HIGH:SEED:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!RSAPSK:!aDH:!aECDH:!EDH-DSS-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA:!SRP',
  );
  
  my %DEFAULT_SSL_CLIENT_ARGS = (
      %DEFAULT_SSL_ARGS,
      SSL_verify_mode => SSL_VERIFY_PEER,
  
      SSL_ca_file => undef,
      SSL_ca_path => undef,
  
      # older versions of F5 BIG-IP hang when getting SSL client hello >255 bytes
      # http://support.f5.com/kb/en-us/solutions/public/13000/000/sol13037.html
      # http://guest:guest@rt.openssl.org/Ticket/Display.html?id=2771
      # Ubuntu worked around this by disabling TLSv1_2 on the client side for
      # a while. Later a padding extension was added to OpenSSL to work around
      # broken F5 but then IronPort croaked because it did not understand this
      # extension so it was disabled again :(
      # Firefox, Chrome and IE11 use TLSv1_2 but use only a few ciphers, so
      # that packet stays small enough. We try the same here.
  
      SSL_cipher_list => join(" ",
  
  	# SSLabs report for Chrome 48/OSX. 
  	# This also includes the fewer ciphers Firefox uses.
  	'ECDHE-ECDSA-AES128-GCM-SHA256',
  	'ECDHE-RSA-AES128-GCM-SHA256',
  	'DHE-RSA-AES128-GCM-SHA256',
  	'ECDHE-ECDSA-CHACHA20-POLY1305',
  	'ECDHE-RSA-CHACHA20-POLY1305',
  	'ECDHE-ECDSA-AES256-SHA',
  	'ECDHE-RSA-AES256-SHA',
  	'DHE-RSA-AES256-SHA',
  	'ECDHE-ECDSA-AES128-SHA',
  	'ECDHE-RSA-AES128-SHA',
  	'DHE-RSA-AES128-SHA',
  	'AES128-GCM-SHA256',
  	'AES256-SHA',
  	'AES128-SHA',
  	'DES-CBC3-SHA',
  
  	# IE11/Edge has some more ciphers, notably SHA384 and DSS
  	# we don't offer the *-AES128-SHA256 and *-AES256-SHA384 non-GCM
  	# ciphers IE/Edge offers because they look like a large mismatch
  	# between a very strong HMAC and a comparably weak (but sufficient)
  	# encryption. Similar all browsers which do SHA384 can do ECDHE
  	# so skip the DHE*SHA384 ciphers.
  	'ECDHE-RSA-AES256-GCM-SHA384',
  	'ECDHE-ECDSA-AES256-GCM-SHA384',
  	# 'ECDHE-RSA-AES256-SHA384',
  	# 'ECDHE-ECDSA-AES256-SHA384',
  	# 'ECDHE-RSA-AES128-SHA256',
  	# 'ECDHE-ECDSA-AES128-SHA256',
  	# 'DHE-RSA-AES256-GCM-SHA384',
  	# 'AES256-GCM-SHA384',
  	'AES256-SHA256',
  	# 'AES128-SHA256',
  	'DHE-DSS-AES256-SHA256',
  	# 'DHE-DSS-AES128-SHA256',
  	'DHE-DSS-AES256-SHA',
  	'DHE-DSS-AES128-SHA',
  	'EDH-DSS-DES-CBC3-SHA',
  
  	# Just to make sure, that we don't accidentally add bad ciphers above.
  	# This includes dropping RC4 which is no longer supported by modern
  	# browsers and also excluded in the SSL libraries of Python and Ruby.
  	"!EXP !MEDIUM !LOW !eNULL !aNULL !RC4 !DES !MD5 !PSK !SRP"
      )
  );
  
  # set values inside _init to work with perlcc, RT#95452
  my %DEFAULT_SSL_SERVER_ARGS;
  
  # Initialization of OpenSSL internals
  # This will be called once during compilation - perlcc users might need to
  # call it again by hand, see RT#95452
  {
      sub init {
  	# library_init returns false if the library was already initialized.
  	# This way we can find out if the library needs to be re-initialized
  	# inside code compiled with perlcc
  	Net::SSLeay::library_init() or return; 
  
  	Net::SSLeay::load_error_strings();
  	Net::SSLeay::OpenSSL_add_all_digests();
  	Net::SSLeay::randomize();
  
  	%DEFAULT_SSL_SERVER_ARGS = (
  	    %DEFAULT_SSL_ARGS,
  	    SSL_verify_mode => SSL_VERIFY_NONE,
  	    SSL_honor_cipher_order => 1,  # trust server to know the best cipher
  	    SSL_dh => do {
  		my $bio = Net::SSLeay::BIO_new(Net::SSLeay::BIO_s_mem());
  		# generated with: openssl dhparam 2048
  		Net::SSLeay::BIO_write($bio,<<'DH');
  -----BEGIN DH PARAMETERS-----
  MIIBCAKCAQEAr8wskArj5+1VCVsnWt/RUR7tXkHJ7mGW7XxrLSPOaFyKyWf8lZht
  iSY2Lc4oa4Zw8wibGQ3faeQu/s8fvPq/aqTxYmyHPKCMoze77QJHtrYtJAosB9SY
  CN7s5Hexxb5/vQ4qlQuOkVrZDiZO9GC4KaH9mJYnCoAsXDhDft6JT0oRVSgtZQnU
  gWFKShIm+JVjN94kGs0TcBEesPTK2g8XVHK9H8AtSUb9BwW2qD/T5RmgNABysApO
  Ps2vlkxjAHjJcqc3O+OiImKik/X2rtBTZjpKmzN3WWTB0RJZCOWaLlDO81D01o1E
  aZecz3Np9KIYey900f+X7zC2bJxEHp95ywIBAg==
  -----END DH PARAMETERS-----
  DH
  		my $dh = Net::SSLeay::PEM_read_bio_DHparams($bio);
  		Net::SSLeay::BIO_free($bio);
  		$dh or die "no DH";
  		$dh;
  	    },
  	    (
  		$can_ecdh eq 'auto' ? () : # automatically enabled by openssl
  		$can_ecdh eq 'can_auto' ? (SSL_ecdh_curve => 'auto') :
  		$can_ecdh eq 'tmp_ecdh' ? ( SSL_ecdh_curve => 'prime256v1' ) :
  		(),
  	    )
  	);
      }
      # Call it once at compile time and try it at INIT.
      # This should catch all cases of including the module, e.g. 'use' (INIT) or
      # 'require' (compile time) and works also with perlcc
      {
  	no warnings;
  	INIT { init() }
  	init();
      }
  }
  
  # global defaults which can be changed using set_defaults
  # either key/value can be set or it can just be set to an external hash
  my $GLOBAL_SSL_ARGS = {};
  my $GLOBAL_SSL_CLIENT_ARGS = {};
  my $GLOBAL_SSL_SERVER_ARGS = {};
  
  # hack which is used to filter bad settings from used modules
  my $FILTER_SSL_ARGS = undef;
  
  # non-XS Versions of Scalar::Util will fail
  BEGIN{
      die "You need the XS Version of Scalar::Util for dualvar() support" if !do {
  	local $SIG{__DIE__}; local $SIG{__WARN__}; # be silent
  	eval { use Scalar::Util 'dualvar'; dualvar(0,''); 1 };
      };
  }
  
  # get constants for SSL_OP_NO_* now, instead calling the related functions
  # every time we setup a connection
  my %SSL_OP_NO;
  for(qw( SSLv2 SSLv3 TLSv1 TLSv1_1 TLSv11:TLSv1_1 TLSv1_2 TLSv12:TLSv1_2
          TLSv1_3 TLSv13:TLSv1_3 )) {
      my ($k,$op) = m{:} ? split(m{:},$_,2) : ($_,$_);
      my $sub = "Net::SSLeay::OP_NO_$op";
      local $SIG{__DIE__};
      $SSL_OP_NO{$k} = eval { no strict 'refs'; &$sub } || 0;
  }
  
  # Make SSL_CTX_clear_options accessible through SSL_CTX_ctrl unless it is
  # already implemented in Net::SSLeay
  if (!defined &Net::SSLeay::CTX_clear_options) {
      *Net::SSLeay::CTX_clear_options = sub {
  	my ($ctx,$opt) = @_;
  	# 77 = SSL_CTRL_CLEAR_OPTIONS
  	Net::SSLeay::CTX_ctrl($ctx,77,$opt,0);
      };
  }
  
  # Try to work around problems with alternative trust path by default, RT#104759
  my $DEFAULT_X509_STORE_flags = 0;
  {
      local $SIG{__DIE__};
      eval { $DEFAULT_X509_STORE_flags |= Net::SSLeay::X509_V_FLAG_TRUSTED_FIRST() };
  }
  
  our $DEBUG;
  use vars qw(@ISA $SSL_ERROR @EXPORT);
  
  {
      # These constants will be used in $! at return from SSL_connect,
      # SSL_accept, _generic_(read|write), thus notifying the caller
      # the usual way of problems. Like with EWOULDBLOCK, EINPROGRESS..
      # these are especially important for non-blocking sockets
  
      my $x = $Net_SSLeay_ERROR_WANT_READ;
      use constant SSL_WANT_READ  => dualvar( \$x, 'SSL wants a read first' );
      my $y = $Net_SSLeay_ERROR_WANT_WRITE;
      use constant SSL_WANT_WRITE => dualvar( \$y, 'SSL wants a write first' );
  
      @EXPORT = qw(
  	SSL_WANT_READ SSL_WANT_WRITE SSL_VERIFY_NONE SSL_VERIFY_PEER
  	SSL_VERIFY_FAIL_IF_NO_PEER_CERT SSL_VERIFY_CLIENT_ONCE
  	SSL_OCSP_NO_STAPLE SSL_OCSP_TRY_STAPLE SSL_OCSP_MUST_STAPLE
  	SSL_OCSP_FAIL_HARD SSL_OCSP_FULL_CHAIN
  	$SSL_ERROR GEN_DNS GEN_IPADD
      );
  }
  
  my @caller_force_inet4; # in case inet4 gets forced we store here who forced it
  
  my $IOCLASS;
  my $family_key; # 'Domain'||'Family'
  BEGIN {
      # declare @ISA depending of the installed socket class
  
      # try to load inet_pton from Socket or Socket6 and make sure it is usable
      local $SIG{__DIE__}; local $SIG{__WARN__}; # be silent
      my $ip6 = eval {
  	require Socket;
  	Socket->VERSION(1.95);
  	Socket::inet_pton( AF_INET6(),'::1') && AF_INET6() or die;
  	Socket->import( qw/inet_pton NI_NUMERICHOST NI_NUMERICSERV/ );
  	# behavior different to Socket6::getnameinfo - wrap
  	*_getnameinfo = sub { 
  	    my ($err,$host,$port) = Socket::getnameinfo(@_) or return; 
  	    return if $err;
  	    return ($host,$port);
  	};
  	'Socket';
      } || eval {
  	require Socket6;
  	Socket6::inet_pton( AF_INET6(),'::1') && AF_INET6() or die;
  	Socket6->import( qw/inet_pton NI_NUMERICHOST NI_NUMERICSERV/ );
  	# behavior different to Socket::getnameinfo - wrap
  	*_getnameinfo = sub { return Socket6::getnameinfo(@_); };
  	'Socket6';
      } || undef;
  
      # try IO::Socket::IP or IO::Socket::INET6 for IPv6 support
      $family_key = 'Domain'; # traditional
      if ($ip6) {
  	# if we have IO::Socket::IP >= 0.31 we will use this in preference
  	# because it can handle both IPv4 and IPv6
  	if ( eval { 
  	    require IO::Socket::IP; 
  	    IO::Socket::IP->VERSION(0.31)
  	}) {
  	    @ISA = qw(IO::Socket::IP);
  	    constant->import( CAN_IPV6 => "IO::Socket::IP" );
  	    $family_key = 'Family';
  	    $IOCLASS = "IO::Socket::IP";
  
  	# if we have IO::Socket::INET6 we will use this not IO::Socket::INET
  	# because it can handle both IPv4 and IPv6
  	# require at least 2.62 because of several problems before that version
  	} elsif( eval { require IO::Socket::INET6; IO::Socket::INET6->VERSION(2.62) } ) {
  	    @ISA = qw(IO::Socket::INET6);
  	    constant->import( CAN_IPV6 => "IO::Socket::INET6" );
  	    $IOCLASS = "IO::Socket::INET6";
  	} else {
  	    $ip6 = ''
  	}
      }
  
      # fall back to IO::Socket::INET for IPv4 only
      if (!$ip6) {
  	@ISA = qw(IO::Socket::INET);
  	$IOCLASS = "IO::Socket::INET";
  	constant->import(CAN_IPV6 => '');
  	if (!defined $ip6) {
  	    constant->import(NI_NUMERICHOST => 1);
  	    constant->import(NI_NUMERICSERV => 2);
  	}
      }
  
      #Make $DEBUG another name for $Net::SSLeay::trace
      *DEBUG = \$Net::SSLeay::trace;
  
      #Compatibility
      *ERROR = \$SSL_ERROR;
  }
  
  
  sub DEBUG {
      $DEBUG or return;
      my (undef,$file,$line,$sub) = caller(1);
      if ($sub =~m{^IO::Socket::SSL::(?:error|(_internal_error))$}) {
  	(undef,$file,$line) = caller(2) if $1;
      } else {
  	(undef,$file,$line) = caller;
      }
      my $msg = shift;
      $file = '...'.substr( $file,-17 ) if length($file)>20;
      $msg = sprintf $msg,@_ if @_;
      print STDERR "DEBUG: $file:$line: $msg\n";
  }
  
  BEGIN {
      # import some constants from Net::SSLeay or use hard-coded defaults
      # if Net::SSLeay isn't recent enough to provide the constants
      my %const = (
  	NID_CommonName => 13,
  	GEN_DNS => 2,
  	GEN_IPADD => 7,
      );
      while ( my ($name,$value) = each %const ) {
  	no strict 'refs';
  	*{$name} = UNIVERSAL::can( 'Net::SSLeay', $name ) || sub { $value };
      }
  
      *idn_to_ascii = \&IO::Socket::SSL::PublicSuffix::idn_to_ascii;
      *idn_to_unicode = \&IO::Socket::SSL::PublicSuffix::idn_to_unicode;
  }
  
  my $OPENSSL_LIST_SEPARATOR = $^O =~m{^(?:(dos|os2|mswin32|netware)|vms)$}i
      ? $1 ? ';' : ',' : ':';
  my $CHECK_SSL_PATH = sub {
      my %args = (@_ == 1) ? ('',@_) : @_;
      for my $type (keys %args) {
  	my $path = $args{$type};
  	if (!$type) {
  	    delete $args{$type};
  	    $type = (ref($path) || -d $path) ? 'SSL_ca_path' : 'SSL_ca_file';
  	    $args{$type} = $path;
  	}
  
  	next if ref($path) eq 'SCALAR' && ! $$path;
  	if ($type eq 'SSL_ca_file') {
  	    die "SSL_ca_file $path can't be used: $!"
  		if ! open(my $fh,'<',$path);
  	} elsif ($type eq 'SSL_ca_path') {
  	    $path = [ split($OPENSSL_LIST_SEPARATOR,$path) ] if !ref($path);
  	    my @err;
  	    for my $d (ref($path) ? @$path : $path) {
  		if (! -d $d) {
  		    push @err, "SSL_ca_path $d does not exist";
  		} elsif (! opendir(my $dh,$d)) {
  		    push @err, "SSL_ca_path $d is not accessible: $!"
  		} else {
  		    @err = ();
  		    last
  		}
  	    }
  	    die "@err" if @err;
  	}
      }
      return %args;
  };
  
  
  {
      my %default_ca;
      my $ca_detected; # 0: never detect, undef: need to (re)detect
      my $openssldir;
  
      sub default_ca {
  	if (@_) {
  	    # user defined default CA or reset
  	    if ( @_ > 1 ) {
  		%default_ca = @_;
  		$ca_detected  = 0;
  	    } elsif ( my $path = shift ) {
  		%default_ca = $CHECK_SSL_PATH->($path);
  		$ca_detected  = 0;
  	    } else {
  		$ca_detected = undef;
  	    }
  	}
  	return %default_ca if defined $ca_detected;
  
  	# SSLEAY_DIR was 5 up to OpenSSL 1.1, then switched to 4 and got
  	# renamed to OPENSSL_DIR. Unfortunately it is not exported as constant
  	# by Net::SSLeay so we use the fixed number.
  	$openssldir ||=
  	    Net::SSLeay::SSLeay_version(5) =~m{^OPENSSLDIR: "(.+)"$} ? $1 :
  	    Net::SSLeay::SSLeay_version(4) =~m{^OPENSSLDIR: "(.+)"$} ? $1 :
  	    'cannot-determine-openssldir-from-ssleay-version';
  
  	# (re)detect according to openssl crypto/cryptlib.h
  	my $dir = $ENV{SSL_CERT_DIR}
  	    || ( $^O =~m{vms}i ? "SSLCERTS:":"$openssldir/certs" );
  	if ( opendir(my $dh,$dir)) {
  	    FILES: for my $f (  grep { m{^[a-f\d]{8}(\.\d+)?$} } readdir($dh) ) {
  		open( my $fh,'<',"$dir/$f") or next;
  		while (my $line = <$fh>) {
  		    $line =~m{^-+BEGIN (X509 |TRUSTED |)CERTIFICATE-} or next;
  		    $default_ca{SSL_ca_path} = $dir;
  		    last FILES;
  		}
  	    }
  	}
  	my $file = $ENV{SSL_CERT_FILE}
  	    || ( $^O =~m{vms}i ? "SSLCERTS:cert.pem":"$openssldir/cert.pem" );
  	if ( open(my $fh,'<',$file)) {
  	    while (my $line = <$fh>) {
  		$line =~m{^-+BEGIN (X509 |TRUSTED |)CERTIFICATE-} or next;
  		$default_ca{SSL_ca_file} = $file;
  		last;
  	    }
  	}
  
  	$default_ca{SSL_ca_file} = Mozilla::CA::SSL_ca_file() if ! %default_ca && do {
  		local $SIG{__DIE__};
  		eval { require Mozilla::CA; 1 };
  	    };
  
  	$ca_detected = 1;
  	return %default_ca;
      }
  }
  
  
  # Export some stuff
  # inet4|inet6|debug will be handled by myself, everything
  # else will be handled the Exporter way
  sub import {
      my $class = shift;
  
      my @export;
      foreach (@_) {
  	if ( /^inet4$/i ) {
  	    # explicitly fall back to inet4
  	    @ISA = 'IO::Socket::INET';
  	    @caller_force_inet4 = caller(); # save for warnings for 'inet6' case
  	} elsif ( /^inet6$/i ) {
  	    # check if we have already ipv6 as base
  	    if ( ! UNIVERSAL::isa( $class, 'IO::Socket::INET6')
  		and ! UNIVERSAL::isa( $class, 'IO::Socket::IP' )) {
  		# either we don't support it or we disabled it by explicitly
  		# loading it with 'inet4'. In this case re-enable but warn
  		# because this is probably an error
  		if ( CAN_IPV6 ) {
  		    @ISA = ( CAN_IPV6 );
  		    warn "IPv6 support re-enabled in __PACKAGE__, got disabled in file $caller_force_inet4[1] line $caller_force_inet4[2]";
  		} else {
  		    die "INET6 is not supported, install IO::Socket::IP";
  		}
  	    }
  	} elsif ( /^:?debug(\d+)/ ) {
  	    $DEBUG=$1;
  	} else {
  	    push @export,$_
  	}
      }
  
      @_ = ( $class,@export );
      goto &Exporter::import;
  }
  
  my %SSL_OBJECT;
  my %CREATED_IN_THIS_THREAD;
  sub CLONE { %CREATED_IN_THIS_THREAD = (); }
  
  # all keys used internally, these should be cleaned up at end
  my @all_my_keys = qw(
      _SSL_arguments
      _SSL_certificate
      _SSL_ctx
      _SSL_fileno
      _SSL_in_DESTROY
      _SSL_ioclass_downgrade
      _SSL_ioclass_upgraded
      _SSL_last_err
      _SSL_object
      _SSL_ocsp_verify
      _SSL_opened
      _SSL_opening
      _SSL_servername
  );
  
  
  # we have callbacks associated with contexts, but have no way to access the
  # current SSL object from these callbacks. To work around this
  # CURRENT_SSL_OBJECT will be set before calling Net::SSLeay::{connect,accept}
  # and reset afterwards, so we have access to it inside _internal_error.
  my $CURRENT_SSL_OBJECT;
  
  # You might be expecting to find a new() subroutine here, but that is
  # not how IO::Socket::INET works.  All configuration gets performed in
  # the calls to configure() and either connect() or accept().
  
  #Call to configure occurs when a new socket is made using
  #IO::Socket::INET.  Returns false (empty list) on failure.
  sub configure {
      my ($self, $arg_hash) = @_;
      return _invalid_object() unless($self);
  
      # force initial blocking
      # otherwise IO::Socket::SSL->new might return undef if the
      # socket is nonblocking and it fails to connect immediately
      # for real nonblocking behavior one should create a nonblocking
      # socket and later call connect explicitly
      my $blocking = delete $arg_hash->{Blocking};
  
      # because Net::HTTPS simple redefines blocking() to {} (e.g.
      # return undef) and IO::Socket::INET does not like this we
      # set Blocking only explicitly if it was set
      $arg_hash->{Blocking} = 1 if defined ($blocking);
  
      $self->configure_SSL($arg_hash) || return;
  
      if ($arg_hash->{$family_key} ||= $arg_hash->{Domain} || $arg_hash->{Family}) {
  	# Hack to work around the problem that IO::Socket::IP defaults to
  	# AI_ADDRCONFIG which creates problems if we have only the loopback
  	# interface. If we already know the family this flag is more harmful
  	# then useful.
  	$arg_hash->{GetAddrInfoFlags} = 0 if $IOCLASS eq 'IO::Socket::IP'
  		&& ! defined $arg_hash->{GetAddrInfoFlags};
      }
      return $self->_internal_error("@ISA configuration failed",0)
  	if ! $self->SUPER::configure($arg_hash);
  
      $self->blocking(0) if defined $blocking && !$blocking;
      return $self;
  }
  
  sub configure_SSL {
      my ($self, $arg_hash) = @_;
  
      $arg_hash->{Proto} ||= 'tcp';
      my $is_server = $arg_hash->{SSL_server};
      if ( ! defined $is_server ) {
  	$is_server = $arg_hash->{SSL_server} = $arg_hash->{Listen} || 0;
      }
  
      # add user defined defaults, maybe after filtering
      $FILTER_SSL_ARGS->($is_server,$arg_hash) if $FILTER_SSL_ARGS;
  
      delete @{*$self}{@all_my_keys};
      ${*$self}{_SSL_opened} = $is_server;
      ${*$self}{_SSL_arguments} = $arg_hash;
  
      # this adds defaults to $arg_hash as a side effect!
      ${*$self}{'_SSL_ctx'} = IO::Socket::SSL::SSL_Context->new($arg_hash)
  	or return;
  
      return $self;
  }
  
  
  sub _skip_rw_error {
      my ($self,$ssl,$rv) = @_;
      my $err = Net::SSLeay::get_error($ssl,$rv);
      if ( $err == $Net_SSLeay_ERROR_WANT_READ) {
  	$SSL_ERROR = SSL_WANT_READ;
      } elsif ( $err == $Net_SSLeay_ERROR_WANT_WRITE) {
  	$SSL_ERROR = SSL_WANT_WRITE;
      } else {
  	return $err;
      }
      $! ||= EWOULDBLOCK;
      ${*$self}{_SSL_last_err} = [$SSL_ERROR,4] if ref($self);
      Net::SSLeay::ERR_clear_error();
      return 0;
  }
  
  
  # Call to connect occurs when a new client socket is made using IO::Socket::*
  sub connect {
      my $self = shift || return _invalid_object();
      return $self if ${*$self}{'_SSL_opened'};  # already connected
  
      if ( ! ${*$self}{'_SSL_opening'} ) {
  	# call SUPER::connect if the underlying socket is not connected
  	# if this fails this might not be an error (e.g. if $! = EINPROGRESS
  	# and socket is nonblocking this is normal), so keep any error
  	# handling to the client
  	$DEBUG>=2 && DEBUG('socket not yet connected' );
  	$self->SUPER::connect(@_) || return;
  	$DEBUG>=2 && DEBUG('socket connected' );
  
  	# IO::Socket works around systems, which return EISCONN or similar
  	# on non-blocking re-connect by returning true, even if $! is set
  	# but it does not clear $!, so do it here
  	$! = undef;
  
  	# don't continue with connect_SSL if SSL_startHandshake is set to 0
  	my $sh = ${*$self}{_SSL_arguments}{SSL_startHandshake};
  	return $self if defined $sh && ! $sh;
      }
      return $self->connect_SSL;
  }
  
  
  sub connect_SSL {
      my $self = shift;
      my $args = @_>1 ? {@_}: $_[0]||{};
      return $self if ${*$self}{'_SSL_opened'};  # already connected
  
      my ($ssl,$ctx);
      if ( ! ${*$self}{'_SSL_opening'} ) {
  	# start ssl connection
  	$DEBUG>=2 && DEBUG('ssl handshake not started' );
  	${*$self}{'_SSL_opening'} = 1;
  	my $arg_hash = ${*$self}{'_SSL_arguments'};
  
  	my $fileno = ${*$self}{'_SSL_fileno'} = fileno($self);
  	return $self->_internal_error("Socket has no fileno",9)
  	    if ! defined $fileno;
  
  	$ctx = ${*$self}{'_SSL_ctx'};  # Reference to real context
  	$ssl = ${*$self}{'_SSL_object'} = Net::SSLeay::new($ctx->{context})
  	    || return $self->error("SSL structure creation failed");
  	$CREATED_IN_THIS_THREAD{$ssl} = 1 if $use_threads;
  	$SSL_OBJECT{$ssl} = [$self,0];
  	weaken($SSL_OBJECT{$ssl}[0]);
  
  	if ($ctx->{session_cache}) {
  	    $arg_hash->{SSL_session_key} ||= do {
  		my $host = $arg_hash->{PeerAddr} || $arg_hash->{PeerHost}
  		    || $self->_update_peer;
  		my $port = $arg_hash->{PeerPort} || $arg_hash->{PeerService};
  		$port ? "$host:$port" : $host;
  	    }
  	}
  
  	Net::SSLeay::set_fd($ssl, $fileno)
  	    || return $self->error("SSL filehandle association failed");
  
  	if ( $can_client_sni ) {
  	    my $host;
  	    if ( exists $arg_hash->{SSL_hostname} ) {
  		# explicitly given
  		# can be set to undef/'' to not use extension
  		$host = $arg_hash->{SSL_hostname}
  	    } elsif ( $host = $arg_hash->{PeerAddr} || $arg_hash->{PeerHost} ) {
  		# implicitly given
  		$host =~s{:[a-zA-Z0-9_\-]+$}{};
  		# should be hostname, not IPv4/6
  		$host = undef if $host !~m{[a-z_]}i or $host =~m{:};
  	    }
  	    # define SSL_CTRL_SET_TLSEXT_HOSTNAME 55
  	    # define TLSEXT_NAMETYPE_host_name 0
  	    if ($host) {
  		$DEBUG>=2 && DEBUG("using SNI with hostname $host");
  		Net::SSLeay::ctrl($ssl,55,0,$host);
  	    } else {
  		$DEBUG>=2 && DEBUG("not using SNI because hostname is unknown");
  	    }
  	} elsif ( $arg_hash->{SSL_hostname} ) {
  	    return $self->_internal_error(
  		"Client side SNI not supported for this openssl",9);
  	} else {
  	    $DEBUG>=2 && DEBUG("not using SNI because openssl is too old");
  	}
  
  	$arg_hash->{PeerAddr} || $arg_hash->{PeerHost} || $self->_update_peer;
  	if ( $ctx->{verify_name_ref} ) {
  	    # need target name for update
  	    my $host = $arg_hash->{SSL_verifycn_name}
  		|| $arg_hash->{SSL_hostname};
  	    if ( ! defined $host ) {
  		if ( $host = $arg_hash->{PeerAddr} || $arg_hash->{PeerHost} ) {
  		    $host =~s{:[a-zA-Z0-9_\-]+$}{};
  		}
  	    }
  	    ${$ctx->{verify_name_ref}} = $host;
  	}
  
  	my $ocsp = $ctx->{ocsp_mode};
  	if ( $ocsp & SSL_OCSP_NO_STAPLE ) {
  	    # don't try stapling
  	} elsif ( ! $can_ocsp_staple ) {
  	    croak("OCSP stapling not support") if $ocsp & SSL_OCSP_MUST_STAPLE;
  	} elsif ( $ocsp & (SSL_OCSP_TRY_STAPLE|SSL_OCSP_MUST_STAPLE)) {
  	    # staple by default if verification enabled
  	    ${*$self}{_SSL_ocsp_verify} = undef;
  	    Net::SSLeay::set_tlsext_status_type($ssl,
  		Net::SSLeay::TLSEXT_STATUSTYPE_ocsp());
  	    $DEBUG>=2 && DEBUG("request OCSP stapling");
  	}
  
  	if ($ctx->{session_cache} and my $session =
  	    $ctx->{session_cache}->get_session($arg_hash->{SSL_session_key})
  	) {
  	    Net::SSLeay::set_session($ssl, $session);
  	}
      }
  
      $ssl ||= ${*$self}{'_SSL_object'};
  
      $SSL_ERROR = $! = undef;
      my $timeout = exists $args->{Timeout}
  	? $args->{Timeout}
  	: ${*$self}{io_socket_timeout}; # from IO::Socket
      if ( defined($timeout) && $timeout>0 && $self->blocking(0) ) {
  	$DEBUG>=2 && DEBUG( "set socket to non-blocking to enforce timeout=$timeout" );
  	# timeout was given and socket was blocking
  	# enforce timeout with now non-blocking socket
      } else {
  	# timeout does not apply because invalid or socket non-blocking
  	$timeout = undef;
      }
  
      my $start = defined($timeout) && time();
      {
  	$SSL_ERROR = undef;
  	$CURRENT_SSL_OBJECT = $self;
  	$DEBUG>=3 && DEBUG("call Net::SSLeay::connect" );
  	my $rv = Net::SSLeay::connect($ssl);
  	$CURRENT_SSL_OBJECT = undef;
  	$DEBUG>=3 && DEBUG("done Net::SSLeay::connect -> $rv" );
  	if ( $rv < 0 ) {
  	    if ( my $err = $self->_skip_rw_error( $ssl,$rv )) {
  		$self->error("SSL connect attempt failed");
  		delete ${*$self}{'_SSL_opening'};
  		${*$self}{'_SSL_opened'} = -1;
  		$DEBUG>=1 && DEBUG( "fatal SSL error: $SSL_ERROR" );
  		return $self->fatal_ssl_error();
  	    }
  
  	    $DEBUG>=2 && DEBUG('ssl handshake in progress' );
  	    # connect failed because handshake needs to be completed
  	    # if socket was non-blocking or no timeout was given return with this error
  	    return if ! defined($timeout);
  
  	    # wait until socket is readable or writable
  	    my $rv;
  	    if ( $timeout>0 ) {
  		my $vec = '';
  		vec($vec,$self->fileno,1) = 1;
  		$DEBUG>=2 && DEBUG( "waiting for fd to become ready: $SSL_ERROR" );
  		$rv =
  		    $SSL_ERROR == SSL_WANT_READ ? select( $vec,undef,undef,$timeout) :
  		    $SSL_ERROR == SSL_WANT_WRITE ? select( undef,$vec,undef,$timeout) :
  		    undef;
  	    } else {
  		$DEBUG>=2 && DEBUG("handshake failed because no more time" );
  		$! = ETIMEDOUT
  	    }
  	    if ( ! $rv ) {
  		$DEBUG>=2 && DEBUG("handshake failed because socket did not became ready" );
  		# failed because of timeout, return
  		$! ||= ETIMEDOUT;
  		delete ${*$self}{'_SSL_opening'};
  		${*$self}{'_SSL_opened'} = -1;
  		$self->blocking(1); # was blocking before
  		return
  	    }
  
  	    # socket is ready, try non-blocking connect again after recomputing timeout
  	    $DEBUG>=2 && DEBUG("socket ready, retrying connect" );
  	    my $now = time();
  	    $timeout -= $now - $start;
  	    $start = $now;
  	    redo;
  
  	} elsif ( $rv == 0 ) {
  	    delete ${*$self}{'_SSL_opening'};
  	    $DEBUG>=2 && DEBUG("connection failed - connect returned 0" );
  	    $self->error("SSL connect attempt failed because of handshake problems" );
  	    ${*$self}{'_SSL_opened'} = -1;
  	    return $self->fatal_ssl_error();
  	}
      }
  
      $DEBUG>=2 && DEBUG('ssl handshake done' );
      # ssl connect successful
      delete ${*$self}{'_SSL_opening'};
      ${*$self}{'_SSL_opened'}=1;
      if (defined($timeout)) {
  	$self->blocking(1); # reset back to blocking
  	$! = undef; # reset errors from non-blocking
      }
  
      $ctx ||= ${*$self}{'_SSL_ctx'};
  
      if ( my $ocsp_result = ${*$self}{_SSL_ocsp_verify} ) {
  	# got result from OCSP stapling
  	if ( $ocsp_result->[0] > 0 ) {
  	    $DEBUG>=3 && DEBUG("got OCSP success with stapling");
  	    # successful validated
  	} elsif ( $ocsp_result->[0] < 0 ) {
  	    # Permanent problem with validation because certificate
  	    # is either self-signed or the issuer cannot be found.
  	    # Ignore here, because this will cause other errors too.
  	    $DEBUG>=3 && DEBUG("got OCSP failure with stapling: %s",
  		$ocsp_result->[1]);
  	} else {
  	    # definitely revoked
  	    $DEBUG>=3 && DEBUG("got OCSP revocation with stapling: %s",
  		$ocsp_result->[1]);
  	    $self->_internal_error($ocsp_result->[1],5);
  	    return $self->fatal_ssl_error();
  	}
      } elsif ( $ctx->{ocsp_mode} & SSL_OCSP_MUST_STAPLE ) {
  	$self->_internal_error("did not receive the required stapled OCSP response",5);
  	return $self->fatal_ssl_error();
      }
  
      if (!%sess_cb and $ctx->{session_cache}
  	and my $session = Net::SSLeay::get1_session($ssl)) {
  	$ctx->{session_cache}->add_session(
  	    ${*$self}{_SSL_arguments}{SSL_session_key},
  	    $session
  	);
      }
  
      tie *{$self}, "IO::Socket::SSL::SSL_HANDLE", $self;
  
      return $self;
  }
  
  # called if PeerAddr is not set in ${*$self}{'_SSL_arguments'}
  # this can be the case if start_SSL is called with a normal IO::Socket::INET
  # so that PeerAddr|PeerPort are not set from args
  # returns PeerAddr
  sub _update_peer {
      my $self = shift;
      my $arg_hash = ${*$self}{'_SSL_arguments'};
      eval {
  	my $sockaddr = getpeername( $self );
  	my $af = sockaddr_family($sockaddr);
  	if( CAN_IPV6 && $af == AF_INET6 ) {
  	    my (undef, $host, $port) = _getnameinfo($sockaddr,
  		NI_NUMERICHOST | NI_NUMERICSERV);
  	    $arg_hash->{PeerPort} = $port;
  	    $arg_hash->{PeerAddr} = $host;
  	} else {
  	    my ($port,$addr) = sockaddr_in( $sockaddr);
  	    $arg_hash->{PeerPort} = $port;
  	    $arg_hash->{PeerAddr} = inet_ntoa( $addr );
  	}
      }
  }
  
  #Call to accept occurs when a new client connects to a server using
  #IO::Socket::SSL
  sub accept {
      my $self = shift || return _invalid_object();
      my $class = shift || 'IO::Socket::SSL';
  
      my $socket = ${*$self}{'_SSL_opening'};
      if ( ! $socket ) {
  	# underlying socket not done
  	$DEBUG>=2 && DEBUG('no socket yet' );
  	$socket = $self->SUPER::accept($class) || return;
  	$DEBUG>=2 && DEBUG('accept created normal socket '.$socket );
  
  	# don't continue with accept_SSL if SSL_startHandshake is set to 0
  	my $sh = ${*$self}{_SSL_arguments}{SSL_startHandshake};
  	if (defined $sh && ! $sh) {
  	    ${*$socket}{_SSL_ctx} = ${*$self}{_SSL_ctx};
  	    ${*$socket}{_SSL_arguments} = {
  		%{${*$self}{_SSL_arguments}},
  		SSL_server => 0,
  	    };
  	    $DEBUG>=2 && DEBUG('will not start SSL handshake yet');
  	    return wantarray ? ($socket, getpeername($socket) ) : $socket
  	}
      }
  
      $self->accept_SSL($socket) || return;
      $DEBUG>=2 && DEBUG('accept_SSL ok' );
  
      return wantarray ? ($socket, getpeername($socket) ) : $socket;
  }
  
  sub accept_SSL {
      my $self = shift;
      my $socket = ( @_ && UNIVERSAL::isa( $_[0], 'IO::Handle' )) ? shift : $self;
      my $args = @_>1 ? {@_}: $_[0]||{};
  
      my $ssl;
      if ( ! ${*$self}{'_SSL_opening'} ) {
  	$DEBUG>=2 && DEBUG('starting sslifying' );
  	${*$self}{'_SSL_opening'} = $socket;
  	if ($socket != $self) {
  	    ${*$socket}{_SSL_ctx} = ${*$self}{_SSL_ctx};
  	    ${*$socket}{_SSL_arguments} = {
  		%{${*$self}{_SSL_arguments}},
  		SSL_server => 0
  	    };
  	}
  
  	my $fileno = ${*$socket}{'_SSL_fileno'} = fileno($socket);
  	return $socket->_internal_error("Socket has no fileno",9)
  	    if ! defined $fileno;
  
  	$ssl = ${*$socket}{_SSL_object} =
  	    Net::SSLeay::new(${*$socket}{_SSL_ctx}{context})
  	    || return $socket->error("SSL structure creation failed");
  	$CREATED_IN_THIS_THREAD{$ssl} = 1 if $use_threads;
  	$SSL_OBJECT{$ssl} = [$socket,1];
  	weaken($SSL_OBJECT{$ssl}[0]);
  
  	Net::SSLeay::set_fd($ssl, $fileno)
  	    || return $socket->error("SSL filehandle association failed");
      }
  
      $ssl ||= ${*$socket}{'_SSL_object'};
  
      $SSL_ERROR = $! = undef;
      #$DEBUG>=2 && DEBUG('calling ssleay::accept' );
  
      my $timeout = exists $args->{Timeout}
  	? $args->{Timeout}
  	: ${*$self}{io_socket_timeout}; # from IO::Socket
      if ( defined($timeout) && $timeout>0 && $socket->blocking(0) ) {
  	# timeout was given and socket was blocking
  	# enforce timeout with now non-blocking socket
      } else {
  	# timeout does not apply because invalid or socket non-blocking
  	$timeout = undef;
      }
  
      my $start = defined($timeout) && time();
      {
  	$SSL_ERROR = undef;
  	$CURRENT_SSL_OBJECT = $self;
  	my $rv = Net::SSLeay::accept($ssl);
  	$CURRENT_SSL_OBJECT = undef;
  	$DEBUG>=3 && DEBUG( "Net::SSLeay::accept -> $rv" );
  	if ( $rv < 0 ) {
  	    if ( my $err = $socket->_skip_rw_error( $ssl,$rv )) {
  		$socket->error("SSL accept attempt failed");
  		delete ${*$self}{'_SSL_opening'};
  		${*$socket}{'_SSL_opened'} = -1;
  		return $socket->fatal_ssl_error();
  	    }
  
  	    # accept failed because handshake needs to be completed
  	    # if socket was non-blocking or no timeout was given return with this error
  	    return if ! defined($timeout);
  
  	    # wait until socket is readable or writable
  	    my $rv;
  	    if ( $timeout>0 ) {
  		my $vec = '';
  		vec($vec,$socket->fileno,1) = 1;
  		$rv =
  		    $SSL_ERROR == SSL_WANT_READ  ? select( $vec,undef,undef,$timeout) :
  		    $SSL_ERROR == SSL_WANT_WRITE ? select( undef,$vec,undef,$timeout) :
  		    undef;
  	    } else {
  		$! = ETIMEDOUT
  	    }
  	    if ( ! $rv ) {
  		# failed because of timeout, return
  		$! ||= ETIMEDOUT;
  		delete ${*$self}{'_SSL_opening'};
  		${*$socket}{'_SSL_opened'} = -1;
  		$socket->blocking(1); # was blocking before
  		return
  	    }
  
  	    # socket is ready, try non-blocking accept again after recomputing timeout
  	    my $now = time();
  	    $timeout -= $now - $start;
  	    $start = $now;
  	    redo;
  
  	} elsif ( $rv == 0 ) {
  	    $socket->error("SSL accept attempt failed because of handshake problems" );
  	    delete ${*$self}{'_SSL_opening'};
  	    ${*$socket}{'_SSL_opened'} = -1;
  	    return $socket->fatal_ssl_error();
  	}
      }
  
      $DEBUG>=2 && DEBUG('handshake done, socket ready' );
      # socket opened
      delete ${*$self}{'_SSL_opening'};
      ${*$socket}{'_SSL_opened'} = 1;
      if (defined($timeout)) {
  	$socket->blocking(1); # reset back to blocking
  	$! = undef; # reset errors from non-blocking
      }
  
      tie *{$socket}, "IO::Socket::SSL::SSL_HANDLE", $socket;
  
      return $socket;
  }
  
  
  ####### I/O subroutines ########################
  
  sub _generic_read {
      my ($self, $read_func, undef, $length, $offset) = @_;
      my $ssl =  ${*$self}{_SSL_object} || return;
      my $buffer=\$_[2];
  
      $SSL_ERROR = $! = undef;
      my ($data,$rwerr) = $read_func->($ssl, $length);
      while ( ! defined($data)) {
  	if ( my $err = $self->_skip_rw_error( $ssl, defined($rwerr) ? $rwerr:-1 )) {
  	    if ($err == $Net_SSLeay_ERROR_SYSCALL) {
  		# OpenSSL 1.1.0c+ : EOF can now result in SSL_read returning -1
  		if (not $!) {
  		    # SSL_ERROR_SYSCALL but not errno -> treat as EOF
  		    $data = '';
  		    last;
  		}
  	    }
  	    $self->error("SSL read error");
  	}
  	return;
      }
  
      $length = length($data);
      $$buffer = '' if !defined $$buffer;
      $offset ||= 0;
      if ($offset>length($$buffer)) {
  	$$buffer.="\0" x ($offset-length($$buffer));  #mimic behavior of read
      }
  
      substr($$buffer, $offset, length($$buffer), $data);
      return $length;
  }
  
  sub read {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_read($self,
  	$self->blocking ? \&Net::SSLeay::ssl_read_all : \&Net::SSLeay::read,
  	@_
      );
  
      # fall back to plain read if we are not required to use SSL yet
      return $self->SUPER::read(@_);
  }
  
  # contrary to the behavior of read sysread can read partial data
  sub sysread {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_read( $self,
  	\&Net::SSLeay::read, @_ );
  
      # fall back to plain sysread if we are not required to use SSL yet
      my $rv = $self->SUPER::sysread(@_);
      return $rv;
  }
  
  sub peek {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_read( $self,
  	\&Net::SSLeay::peek, @_ );
  
      # fall back to plain peek if we are not required to use SSL yet
      # emulate peek with recv(...,MS_PEEK) - peek(buf,len,offset)
      return if ! defined recv($self,my $buf,$_[1],MSG_PEEK);
      $_[0] = $_[2] ? substr($_[0],0,$_[2]).$buf : $buf;
      return length($buf);
  }
  
  
  sub _generic_write {
      my ($self, $write_all, undef, $length, $offset) = @_;
  
      my $ssl =  ${*$self}{_SSL_object} || return;
      my $buffer = \$_[2];
  
      my $buf_len = length($$buffer);
      $length ||= $buf_len;
      $offset ||= 0;
      return $self->_internal_error("Invalid offset for SSL write",9)
  	if $offset>$buf_len;
      return 0 if ($offset == $buf_len);
  
      $SSL_ERROR = $! = undef;
      my $written;
      if ( $write_all ) {
  	my $data = $length < $buf_len-$offset ? substr($$buffer, $offset, $length) : $$buffer;
  	($written, my $errs) = Net::SSLeay::ssl_write_all($ssl, $data);
  	# ssl_write_all returns number of bytes written
  	$written = undef if ! $written && $errs;
      } else {
  	$written = Net::SSLeay::write_partial( $ssl,$offset,$length,$$buffer );
  	# write_partial does SSL_write which returns -1 on error
  	$written = undef if $written < 0;
      }
      if ( !defined($written) ) {
  	if ( my $err = $self->_skip_rw_error( $ssl,-1 )) {
  	    # if $! is not set with ERROR_SYSCALL then report as EPIPE
  	    $! ||= EPIPE if $err == $Net_SSLeay_ERROR_SYSCALL;
  	    $self->error("SSL write error ($err)");
  	}
  	return;
      }
  
      return $written;
  }
  
  # if socket is blocking write() should return only on error or
  # if all data are written
  sub write {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_write( $self,
  	scalar($self->blocking),@_ );
  
      # fall back to plain write if we are not required to use SSL yet
      return $self->SUPER::write(@_);
  }
  
  # contrary to write syswrite() returns already if only
  # a part of the data is written
  sub syswrite {
      my $self = shift;
      ${*$self}{_SSL_object} && return _generic_write($self,0,@_);
  
      # fall back to plain syswrite if we are not required to use SSL yet
      return $self->SUPER::syswrite(@_);
  }
  
  sub print {
      my $self = shift;
      my $string = join(($, or ''), @_, ($\ or ''));
      return $self->write( $string );
  }
  
  sub printf {
      my ($self,$format) = (shift,shift);
      return $self->write(sprintf($format, @_));
  }
  
  sub getc {
      my ($self, $buffer) = (shift, undef);
      return $buffer if $self->read($buffer, 1, 0);
  }
  
  sub readline {
      my $self = shift;
      ${*$self}{_SSL_object} or return $self->SUPER::getline;
  
      if ( not defined $/ or wantarray) {
  	# read all and split
  
  	my $buf = '';
  	while (1) {
  	    my $rv = $self->sysread($buf,2**16,length($buf));
  	    if ( ! defined $rv ) {
  		next if $! == EINTR;       # retry
  		last if $! == EWOULDBLOCK || $! == EAGAIN; # use everything so far
  		return;                    # return error
  	    } elsif ( ! $rv ) {
  		last
  	    }
  	}
  
  	if ( ! defined $/ ) {
  	    return $buf
  	} elsif ( ref($/)) {
  	    my $size = ${$/};
  	    die "bad value in ref \$/: $size" unless $size>0;
  	    return $buf=~m{\G(.{1,$size})}g;
  	} elsif ( $/ eq '' ) {
  	    return $buf =~m{\G(.*\n\n+|.+)}g;
  	} else {
  	    return $buf =~m{\G(.*$/|.+)}g;
  	}
      }
  
      # read only one line
      if ( ref($/) ) {
  	my $size = ${$/};
  	# read record of $size bytes
  	die "bad value in ref \$/: $size" unless $size>0;
  	my $buf = '';
  	while ( $size>length($buf)) {
  	    my $rv = $self->sysread($buf,$size-length($buf),length($buf));
  	    if ( ! defined $rv ) {
  		next if $! == EINTR;       # retry
  		last if $! == EWOULDBLOCK || $! == EAGAIN; # use everything so far
  		return;                    # return error
  	    } elsif ( ! $rv ) {
  		last
  	    }
  	}
  	return $buf;
      }
  
      my ($delim0,$delim1) = $/ eq '' ? ("\n\n","\n"):($/,'');
  
      # find first occurrence of $delim0 followed by as much as possible $delim1
      my $buf = '';
      my $eod = 0;  # pointer into $buf after $delim0 $delim1*
      my $ssl = $self->_get_ssl_object or return;
      while (1) {
  
  	# wait until we have more data or eof
  	my $poke = Net::SSLeay::peek($ssl,1);
  	if ( ! defined $poke or $poke eq '' ) {
  	    next if $! == EINTR;
  	}
  
  	my $skip = 0;
  
  	# peek into available data w/o reading
  	my $pending = Net::SSLeay::pending($ssl);
  	if ( $pending and
  	    ( my $pb = Net::SSLeay::peek( $ssl,$pending )) ne '' ) {
  	    $buf .= $pb
  	} else {
  	    return $buf eq '' ? ():$buf;
  	}
  	if ( !$eod ) {
  	    my $pos = index( $buf,$delim0 );
  	    if ( $pos<0 ) {
  		$skip = $pending
  	    } else {
  		$eod = $pos + length($delim0); # pos after delim0
  	    }
  	}
  
  	if ( $eod ) {
  	    if ( $delim1 ne '' ) {
  		# delim0 found, check for as much delim1 as possible
  		while ( index( $buf,$delim1,$eod ) == $eod ) {
  		    $eod+= length($delim1);
  		}
  	    }
  	    $skip = $pending - ( length($buf) - $eod );
  	}
  
  	# remove data from $self which I already have in buf
  	while ( $skip>0 ) {
  	    if ($self->sysread(my $p,$skip,0)) {
  		$skip -= length($p);
  		next;
  	    }
  	    $! == EINTR or last;
  	}
  
  	if ( $eod and ( $delim1 eq '' or $eod < length($buf))) {
  	    # delim0 found and there can be no more delim1 pending
  	    last
  	}
      }
      return substr($buf,0,$eod);
  }
  
  sub close {
      my $self = shift || return _invalid_object();
      my $close_args = (ref($_[0]) eq 'HASH') ? $_[0] : {@_};
  
      return if ! $self->stop_SSL(
  	SSL_fast_shutdown => 1,
  	%$close_args,
  	_SSL_ioclass_downgrade => 0,
      );
  
      if ( ! $close_args->{_SSL_in_DESTROY} ) {
  	untie( *$self );
  	undef ${*$self}{_SSL_fileno};
  	return $self->SUPER::close;
      }
      return 1;
  }
  
  sub is_SSL {
      my $self = pop;
      return ${*$self}{_SSL_object} && 1
  }
  
  sub stop_SSL {
      my $self = shift || return _invalid_object();
      my $stop_args = (ref($_[0]) eq 'HASH') ? $_[0] : {@_};
      $stop_args->{SSL_no_shutdown} = 1 if ! ${*$self}{_SSL_opened};
  
      if (my $ssl = ${*$self}{'_SSL_object'}) {
  	if ( ! $stop_args->{SSL_no_shutdown} ) {
  	    my $status = Net::SSLeay::get_shutdown($ssl);
  
  	    my $timeout =
  		not($self->blocking) ? undef :
  		exists $stop_args->{Timeout} ? $stop_args->{Timeout} :
  		${*$self}{io_socket_timeout}; # from IO::Socket
  	    if ($timeout) {
  		$self->blocking(0);
  		$timeout += time();
  	    }
  
  	    while (1) {
  		if ( $status & SSL_SENT_SHUTDOWN and
  		    # don't care for received if fast shutdown
  		    $status & SSL_RECEIVED_SHUTDOWN
  			|| $stop_args->{SSL_fast_shutdown}) {
  		    # shutdown complete
  		    last;
  		}
  		if ((${*$self}{'_SSL_opened'}||0) <= 0) {
  		    # not really open, thus don't expect shutdown to return
  		    # something meaningful
  		    last;
  		}
  
  		# initiate or complete shutdown
  		local $SIG{PIPE} = 'IGNORE';
  		my $rv = Net::SSLeay::shutdown($ssl);
  		if ( $rv < 0 ) {
  		    # non-blocking socket?
  		    if ( ! $timeout ) {
  			$self->_skip_rw_error( $ssl,$rv );
  			# need to try again
  			return;
  		    }
  
  		    # don't use _skip_rw_error so that existing error does
  		    # not get cleared
  		    my $wait = $timeout - time();
  		    last if $wait<=0;
  		    vec(my $vec = '',fileno($self),1) = 1;
  		    my $err = Net::SSLeay::get_error($ssl,$rv);
  		    if ( $err == $Net_SSLeay_ERROR_WANT_READ) {
  			select($vec,undef,undef,$wait)
  		    } elsif ( $err == $Net_SSLeay_ERROR_WANT_READ) {
  			select(undef,$vec,undef,$wait)
  		    } else {
  			last;
  		    }
  		}
  
  		$status |= SSL_SENT_SHUTDOWN;
  		$status |= SSL_RECEIVED_SHUTDOWN if $rv>0;
  	    }
  	    $self->blocking(1) if $timeout;
  	}
  
  	# destroy allocated objects for SSL and untie
  	# do not destroy CTX unless explicitly specified
  	Net::SSLeay::free($ssl);
  	if (my $cert = delete ${*$self}{'_SSL_certificate'}) {
  	    Net::SSLeay::X509_free($cert);
  	}
  	delete ${*$self}{_SSL_object};
  	${*$self}{'_SSL_opened'} = 0;
  	delete $SSL_OBJECT{$ssl};
  	delete $CREATED_IN_THIS_THREAD{$ssl};
  	untie(*$self);
      }
  
      if ($stop_args->{'SSL_ctx_free'}) {
  	my $ctx = delete ${*$self}{'_SSL_ctx'};
  	$ctx && $ctx->DESTROY();
      }
  
  
      if ( ! $stop_args->{_SSL_in_DESTROY} ) {
  
  	my $downgrade = $stop_args->{_SSL_ioclass_downgrade};
  	if ( $downgrade || ! defined $downgrade ) {
  	    # rebless to original class from start_SSL
  	    if ( my $orig_class = delete ${*$self}{'_SSL_ioclass_upgraded'} ) {
  		bless $self,$orig_class;
  		# FIXME: if original class was tied too we need to restore the tie
  		# remove all _SSL related from *$self
  		my @sslkeys = grep { m{^_?SSL_} } keys %{*$self};
  		delete @{*$self}{@sslkeys} if @sslkeys;
  	    }
  	}
      }
      return 1;
  }
  
  
  sub fileno {
      my $self = shift;
      my $fn = ${*$self}{'_SSL_fileno'};
  	return defined($fn) ? $fn : $self->SUPER::fileno();
  }
  
  
  ####### IO::Socket::SSL specific functions #######
  # _get_ssl_object is for internal use ONLY!
  sub _get_ssl_object {
      my $self = shift;
      return ${*$self}{'_SSL_object'} ||
  	IO::Socket::SSL->_internal_error("Undefined SSL object",9);
  }
  
  # _get_ctx_object is for internal use ONLY!
  sub _get_ctx_object {
      my $self = shift;
      my $ctx_object = ${*$self}{_SSL_ctx};
      return $ctx_object && $ctx_object->{context};
  }
  
  # default error for undefined arguments
  sub _invalid_object {
      return IO::Socket::SSL->_internal_error("Undefined IO::Socket::SSL object",9);
  }
  
  
  sub pending {
      my $ssl = shift()->_get_ssl_object || return;
      return Net::SSLeay::pending($ssl);
  }
  
  sub start_SSL {
      my ($class,$socket) = (shift,shift);
      return $class->_internal_error("Not a socket",9) if ! ref($socket);
      my $arg_hash = @_ == 1 ? $_[0] : {@_};
      my %to = exists $arg_hash->{Timeout} ? ( Timeout => delete $arg_hash->{Timeout} ) :();
      my $original_class = ref($socket);
      if ( ! $original_class ) {
  	$socket = ($original_class = $ISA[0])->new_from_fd($socket,'<+')
  	    or return $class->_internal_error(
  	    "creating $original_class from file handle failed",9);
      }
      my $original_fileno = (UNIVERSAL::can($socket, "fileno"))
  	? $socket->fileno : CORE::fileno($socket);
      return $class->_internal_error("Socket has no fileno",9)
  	if ! defined $original_fileno;
  
      bless $socket, $class;
      $socket->configure_SSL($arg_hash) or bless($socket, $original_class) && return;
  
      ${*$socket}{'_SSL_fileno'} = $original_fileno;
      ${*$socket}{'_SSL_ioclass_upgraded'} = $original_class
  	if $class ne $original_class;
  
      my $start_handshake = $arg_hash->{SSL_startHandshake};
      if ( ! defined($start_handshake) || $start_handshake ) {
  	# if we have no callback force blocking mode
  	$DEBUG>=2 && DEBUG( "start handshake" );
  	my $was_blocking = $socket->blocking(1);
  	my $result = ${*$socket}{'_SSL_arguments'}{SSL_server}
  	    ? $socket->accept_SSL(%to)
  	    : $socket->connect_SSL(%to);
  	if ( $result ) {
  	    $socket->blocking(0) if ! $was_blocking;
  	    return $socket;
  	} else {
  	    # upgrade to SSL failed, downgrade socket to original class
  	    if ( $original_class ) {
  		bless($socket,$original_class);
  		$socket->blocking(0) if ! $was_blocking
  		    && $socket->can('blocking');
  	    }
  	    return;
  	}
      } else {
  	$DEBUG>=2 && DEBUG( "don't start handshake: $socket" );
  	return $socket; # just return upgraded socket
      }
  
  }
  
  sub new_from_fd {
      my ($class, $fd) = (shift,shift);
      # Check for accidental inclusion of MODE in the argument list
      if (length($_[0]) < 4) {
  	(my $mode = $_[0]) =~ tr/+<>//d;
  	shift unless length($mode);
      }
      my $handle = $ISA[0]->new_from_fd($fd, '+<')
  	|| return($class->error("Could not create socket from file descriptor."));
  
      # Annoying workaround for Perl 5.6.1 and below:
      $handle = $ISA[0]->new_from_fd($handle, '+<');
  
      return $class->start_SSL($handle, @_);
  }
  
  
  sub dump_peer_certificate {
      my $ssl = shift()->_get_ssl_object || return;
      return Net::SSLeay::dump_peer_certificate($ssl);
  }
  
  if ( defined &Net::SSLeay::get_peer_cert_chain
      && $netssleay_version >= 1.58 ) {
      *peer_certificates = sub {
  	my $self = shift;
  	my $ssl = $self->_get_ssl_object || return;
  	my @chain = Net::SSLeay::get_peer_cert_chain($ssl);
  	@chain = () if @chain && !$self->peer_certificate; # work around #96013
  	if ( ${*$self}{_SSL_arguments}{SSL_server} ) {
  	    # in the client case the chain contains the peer certificate,
  	    # in the server case not
  	    # this one has an increased reference counter, the other not
  	    if ( my $peer = Net::SSLeay::get_peer_certificate($ssl)) {
  		Net::SSLeay::X509_free($peer);
  		unshift @chain, $peer;
  	    }
  	}
  	return @chain;
  
      }
  } else {
      *peer_certificates = sub {
  	die "peer_certificates needs Net::SSLeay>=1.58";
      }
  }
  
  {
      my %dispatcher = (
  	issuer =>  sub { Net::SSLeay::X509_NAME_oneline( Net::SSLeay::X509_get_issuer_name( shift )) },
  	subject => sub { Net::SSLeay::X509_NAME_oneline( Net::SSLeay::X509_get_subject_name( shift )) },
  	commonName => sub {
  	    my $cn = Net::SSLeay::X509_NAME_get_text_by_NID(
  		Net::SSLeay::X509_get_subject_name( shift ), NID_CommonName);
  	    $cn;
  	},
  	subjectAltNames => sub { Net::SSLeay::X509_get_subjectAltNames( shift ) },
      );
  
      # alternative names
      $dispatcher{authority} = $dispatcher{issuer};
      $dispatcher{owner}     = $dispatcher{subject};
      $dispatcher{cn}        = $dispatcher{commonName};
  
      sub peer_certificate {
  	my ($self,$field,$reload) = @_;
  	my $ssl = $self->_get_ssl_object or return;
  
  	Net::SSLeay::X509_free(delete ${*$self}{_SSL_certificate})
  	    if $reload && ${*$self}{_SSL_certificate};
  	my $cert = ${*$self}{_SSL_certificate}
  	    ||= Net::SSLeay::get_peer_certificate($ssl)
  	    or return $self->error("Could not retrieve peer certificate");
  
  	if ($field) {
  	    my $sub = $dispatcher{$field} or croak
  		"invalid argument for peer_certificate, valid are: ".join( " ",keys %dispatcher ).
  		"\nMaybe you need to upgrade your Net::SSLeay";
  	    return $sub->($cert);
  	} else {
  	    return $cert
  	}
      }
  
      sub sock_certificate {
  	my ($self,$field) = @_;
  	my $ssl = $self->_get_ssl_object || return;
  	my $cert = Net::SSLeay::get_certificate( $ssl ) || return;
  	if ($field) {
  	    my $sub = $dispatcher{$field} or croak
  		"invalid argument for sock_certificate, valid are: ".join( " ",keys %dispatcher ).
  		"\nMaybe you need to upgrade your Net::SSLeay";
  	    return $sub->($cert);
  	} else {
  	    return $cert
  	}
      }
  
  
      # known schemes, possible attributes are:
      #  - wildcards_in_alt (0, 'full_label', 'anywhere')
      #  - wildcards_in_cn (0, 'full_label', 'anywhere')
      #  - check_cn (0, 'always', 'when_only')
      # unfortunately there are a lot of different schemes used, see RFC 6125 for a
      # summary, which references all of the following except RFC4217/ftp
  
      my %scheme = (
  	none => {}, # do not check
  	# default set is a superset of all the others and thus worse than a more
  	# specific set, but much better than not verifying name at all
  	default => {
  	    wildcards_in_cn  => 'anywhere',
  	    wildcards_in_alt => 'anywhere',
  	    check_cn         => 'always',
  	    ip_in_cn         => 1,
  	},
      );
  
      for(qw(
  	rfc2818
  	rfc3920 xmpp
  	rfc4217 ftp
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 'anywhere',
  	    wildcards_in_alt => 'anywhere',
  	    check_cn         => 'when_only',
  	}
      }
  
      for(qw(www http)) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 'anywhere',
  	    wildcards_in_alt => 'anywhere',
  	    check_cn         => 'when_only',
  	    ip_in_cn         => 4,
  	}
      }
  
      for(qw(
  	rfc4513 ldap
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 0,
  	    wildcards_in_alt => 'full_label',
  	    check_cn         => 'always',
  	};
      }
  
      for(qw(
  	rfc2595 smtp
  	rfc4642 imap pop3 acap
  	rfc5539 nntp
  	rfc5538 netconf
  	rfc5425 syslog
  	rfc5953 snmp
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 'full_label',
  	    wildcards_in_alt => 'full_label',
  	    check_cn         => 'always'
  	};
      }
      for(qw(
  	rfc5971 gist
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 'full_label',
  	    wildcards_in_alt => 'full_label',
  	    check_cn         => 'when_only',
  	};
      }
  
      for(qw(
  	rfc5922 sip
      )) {
  	$scheme{$_} = {
  	    wildcards_in_cn  => 0,
  	    wildcards_in_alt => 0,
  	    check_cn         => 'always',
  	};
      }
  
  
      # function to verify the hostname
      #
      # as every application protocol has its own rules to do this
      # we provide some default rules as well as a user-defined
      # callback
  
      sub verify_hostname_of_cert {
  	my $identity = shift;
  	my $cert = shift;
  	my $scheme = shift || 'default';
  	my $publicsuffix = shift;
  	if ( ! ref($scheme) ) {
  	    $DEBUG>=3 && DEBUG( "scheme=$scheme cert=$cert" );
  	    $scheme = $scheme{$scheme} || croak("scheme $scheme not defined");
  	}
  
  	return 1 if ! %$scheme; # 'none'
  	$identity =~s{\.+$}{}; # ignore absolutism
  
  	# get data from certificate
  	my $commonName = $dispatcher{cn}->($cert);
  	my @altNames = $dispatcher{subjectAltNames}->($cert);
  	$DEBUG>=3 && DEBUG("identity=$identity cn=$commonName alt=@altNames" );
  
  	if ( my $sub = $scheme->{callback} ) {
  	    # use custom callback
  	    return $sub->($identity,$commonName,@altNames);
  	}
  
  	# is the given hostname an IP address? Then we have to convert to network byte order [RFC791][RFC2460]
  
  	my $ipn;
  	if ( CAN_IPV6 and $identity =~m{:} ) {
  	    # no IPv4 or hostname have ':'  in it, try IPv6.
  	    $identity =~m{[^\da-fA-F:\.]} and return; # invalid characters in name
  	    $ipn = inet_pton(AF_INET6,$identity) or return; # invalid name
  	} elsif ( my @ip = $identity =~m{^(\d+)(?:\.(\d+)\.(\d+)\.(\d+)|[\d\.]*)$} ) {
  	    # check for invalid IP/hostname
  	    return if 4 != @ip or 4 != grep { defined($_) && $_<256 } @ip; 
  	    $ipn = pack("CCCC",@ip);
  	} else {
  	    # assume hostname, check for umlauts etc
  	    if ( $identity =~m{[^a-zA-Z0-9_.\-]} ) {
  		$identity =~m{\0} and return; # $identity has \\0 byte
  		$identity = idn_to_ascii($identity)
  		    or return; # conversation to IDNA failed
  		$identity =~m{[^a-zA-Z0-9_.\-]}
  		    and return; # still junk inside
  	    }
  	}
  
  	# do the actual verification
  	my $check_name = sub {
  	    my ($name,$identity,$wtyp,$publicsuffix) = @_;
  	    $name =~s{\.+$}{}; # ignore absolutism
  	    $name eq '' and return;
  	    $wtyp ||= '';
  	    my $pattern;
  	    ### IMPORTANT!
  	    # We accept only a single wildcard and only for a single part of the FQDN
  	    # e.g. *.example.org does match www.example.org but not bla.www.example.org
  	    # The RFCs are in this regard unspecific but we don't want to have to
  	    # deal with certificates like *.com, *.co.uk or even *
  	    # see also http://nils.toedtmann.net/pub/subjectAltName.txt .
  	    # Also, we fall back to full_label matches if the identity is an IDNA
  	    # name, see RFC6125 and the discussion at
  	    # http://bugs.python.org/issue17997#msg194950
  	    if ( $wtyp eq 'anywhere' and $name =~m{^([a-zA-Z0-9_\-]*)\*(.+)} ) {
  		return if $1 ne '' and substr($identity,0,4) eq 'xn--'; # IDNA
  		$pattern = qr{^\Q$1\E[a-zA-Z0-9_\-]+\Q$2\E$}i;
  	    } elsif ( $wtyp =~ m{^(?:full_label|leftmost)$}
  		and $name =~m{^\*(\..+)$} ) {
  		$pattern = qr{^[a-zA-Z0-9_\-]+\Q$1\E$}i;
  	    } else {
  		return lc($identity) eq lc($name);
  	    }
  	    if ( $identity =~ $pattern ) {
  		$publicsuffix = IO::Socket::SSL::PublicSuffix->default
  		    if ! defined $publicsuffix;
  		return 1 if $publicsuffix eq '';
  		my @labels = split( m{\.+}, $identity );
  		my $tld = $publicsuffix->public_suffix(\@labels,+1);
  		return 1 if @labels > ( $tld ? 0+@$tld : 1 );
  	    }
  	    return;
  	};
  
  
  	my $alt_dnsNames = 0;
  	while (@altNames) {
  	    my ($type, $name) = splice (@altNames, 0, 2);
  	    if ( $ipn and $type == GEN_IPADD ) {
  		# exact match needed for IP
  		# $name is already packed format (inet_xton)
  		return 1 if $ipn eq $name;
  
  	    } elsif ( ! $ipn and $type == GEN_DNS ) {
  		$name =~s/\s+$//; $name =~s/^\s+//;
  		$alt_dnsNames++;
  		$check_name->($name,$identity,$scheme->{wildcards_in_alt},$publicsuffix)
  		    and return 1;
  	    }
  	}
  
  	if ( $scheme->{check_cn} eq 'always' or
  	    $scheme->{check_cn} eq 'when_only' and !$alt_dnsNames ) {
  	    if ( ! $ipn ) {
  		$check_name->($commonName,$identity,$scheme->{wildcards_in_cn},$publicsuffix)
  		    and return 1;
  	    } elsif ( $scheme->{ip_in_cn} ) {
  		if ( $identity eq $commonName ) {
  		    return 1 if
  			$scheme->{ip_in_cn} == 4 ? length($ipn) == 4 :
  			$scheme->{ip_in_cn} == 6 ? length($ipn) == 8 :
  			1;
  		}
  	    }
  	}
  
  	return 0; # no match
      }
  }
  
  sub verify_hostname {
      my $self = shift;
      my $host = shift;
      my $cert = $self->peer_certificate;
      return verify_hostname_of_cert( $host,$cert,@_ );
  }
  
  
  sub get_servername {
      my $self = shift;
      return ${*$self}{_SSL_servername} ||= do {
  	my $ssl = $self->_get_ssl_object or return;
  	Net::SSLeay::get_servername($ssl);
      };
  }
  
  sub get_fingerprint_bin {
      my ($self,$algo,$cert,$key_only) = @_;
      $cert ||= $self->peer_certificate;
      return $key_only 
  	? Net::SSLeay::X509_pubkey_digest($cert, $algo2digest->($algo || 'sha256'))
  	: Net::SSLeay::X509_digest($cert, $algo2digest->($algo || 'sha256'));
  }
  
  sub get_fingerprint {
      my ($self,$algo,$cert,$key_only) = @_;
      $algo ||= 'sha256';
      my $fp = get_fingerprint_bin($self,$algo,$cert,$key_only) or return;
      return $algo.'$'.($key_only ? 'pub$':'').unpack('H*',$fp);
  }
  
  sub get_cipher {
      my $ssl = shift()->_get_ssl_object || return;
      return Net::SSLeay::get_cipher($ssl);
  }
  
  sub get_sslversion {
      my $ssl = shift()->_get_ssl_object || return;
      my $version = Net::SSLeay::version($ssl) or return;
      return
  	$version == 0x0304 ? 'TLSv1_3' :
  	$version == 0x0303 ? 'TLSv1_2' :
  	$version == 0x0302 ? 'TLSv1_1' :
  	$version == 0x0301 ? 'TLSv1'   :
  	$version == 0x0300 ? 'SSLv3'   :
  	$version == 0x0002 ? 'SSLv2'   :
  	$version == 0xfeff ? 'DTLS1'   :
  	undef;
  }
  
  sub get_sslversion_int {
      my $ssl = shift()->_get_ssl_object || return;
      return Net::SSLeay::version($ssl);
  }
  
  sub get_session_reused {
      return Net::SSLeay::session_reused(
  	shift()->_get_ssl_object || return);
  }
  
  if ($can_ocsp) {
      no warnings 'once';
      *ocsp_resolver = sub {
  	my $self = shift;
  	my $ssl = $self->_get_ssl_object || return;
  	my $ctx = ${*$self}{_SSL_ctx};
  	return IO::Socket::SSL::OCSP_Resolver->new(
  	    $ssl,
  	    $ctx->{ocsp_cache} ||= IO::Socket::SSL::OCSP_Cache->new,
  	    $ctx->{ocsp_mode} & SSL_OCSP_FAIL_HARD,
  	    @_ ? \@_ :
  		$ctx->{ocsp_mode} & SSL_OCSP_FULL_CHAIN ? [ $self->peer_certificates ]:
  		[ $self->peer_certificate ]
  	);
      };
  }
  
  sub errstr {
      my $self = shift;
      my $oe = ref($self) && ${*$self}{_SSL_last_err};
      return $oe ? $oe->[0] : $SSL_ERROR || '';
  }
  
  sub fatal_ssl_error {
      my $self = shift;
      my $error_trap = ${*$self}{'_SSL_arguments'}->{'SSL_error_trap'};
      $@ = $self->errstr;
      if (defined $error_trap and ref($error_trap) eq 'CODE') {
  	$error_trap->($self, $self->errstr()."\n".$self->get_ssleay_error());
      } elsif ( ${*$self}{'_SSL_ioclass_upgraded'}
  	|| ${*$self}{_SSL_arguments}{SSL_keepSocketOnError}) {
  	# downgrade only
  	$DEBUG>=3 && DEBUG('downgrading SSL only, not closing socket' );
  	$self->stop_SSL;
      } else {
  	# kill socket
  	$self->close
      }
      return;
  }
  
  sub get_ssleay_error {
      #Net::SSLeay will print out the errors itself unless we explicitly
      #undefine $Net::SSLeay::trace while running print_errs()
      local $Net::SSLeay::trace;
      return Net::SSLeay::print_errs('SSL error: ') || '';
  }
  
  # internal errors, e.g. unsupported features, hostname check failed etc
  # _SSL_last_err contains severity so that on error chains we can decide if one
  # error should replace the previous one or if this is just a less specific
  # follow-up error, e.g. configuration failed because certificate failed because
  # hostname check went wrong:
  # 0 - fallback errors
  # 4 - errors bubbled up from OpenSSL (sub error, r/w error)
  # 5 - hostname or OCSP verification failed
  # 9 - fatal problems, e.g. missing feature, no fileno...
  # _SSL_last_err and SSL_ERROR are only replaced if the error has a higher
  # severity than the previous one
  
  sub _internal_error {
      my ($self, $error, $severity) = @_;
      $error = dualvar( -1, $error );
      $self = $CURRENT_SSL_OBJECT if !ref($self) && $CURRENT_SSL_OBJECT;
      if (ref($self)) {
  	my $oe = ${*$self}{_SSL_last_err};
  	if (!$oe || $oe->[1] <= $severity) {
  	    ${*$self}{_SSL_last_err} = [$error,$severity];
  	    $SSL_ERROR = $error;
  	    $DEBUG && DEBUG("local error: $error");
  	} else {
  	    $DEBUG && DEBUG("ignoring less severe local error '$error', keep '$oe->[0]'");
  	}
      } else {
  	$SSL_ERROR = $error;
  	$DEBUG && DEBUG("global error: $error");
      }
      return;
  }
  
  # OpenSSL errors
  sub error {
      my ($self, $error) = @_;
      my @err;
      while ( my $err = Net::SSLeay::ERR_get_error()) {
  	push @err, Net::SSLeay::ERR_error_string($err);
  	$DEBUG>=2 && DEBUG( $error."\n".$self->get_ssleay_error());
      }
      $error .= ' '.join(' ',@err) if @err;
      return $self->_internal_error($error,4) if $error;
      return;
  }
  
  sub can_client_sni { return $can_client_sni }
  sub can_server_sni { return $can_server_sni }
  sub can_multi_cert { return $can_multi_cert }
  sub can_npn        { return $can_npn }
  sub can_alpn       { return $can_alpn }
  sub can_ecdh       { return $can_ecdh }
  sub can_ipv6       { return CAN_IPV6 }
  sub can_ocsp       { return $can_ocsp }
  sub can_ticket_keycb { return $can_tckt_keycb }
  sub can_pha        { return $can_pha }
  sub can_partial_chain { return $check_partial_chain && 1 }
  
  sub DESTROY {
      my $self = shift or return;
      if (my $ssl = ${*$self}{_SSL_object}) {
  	delete $SSL_OBJECT{$ssl};
  	if (!$use_threads or delete $CREATED_IN_THIS_THREAD{$ssl}) {
  	    $self->close(_SSL_in_DESTROY => 1, SSL_no_shutdown => 1)
  		if ${*$self}{'_SSL_opened'};
  	}
      }
      delete @{*$self}{@all_my_keys};
  }
  
  
  #######Extra Backwards Compatibility Functionality#######
  sub socket_to_SSL { IO::Socket::SSL->start_SSL(@_); }
  sub socketToSSL { IO::Socket::SSL->start_SSL(@_); }
  sub kill_socket { shift->close }
  
  sub issuer_name { return(shift()->peer_certificate("issuer")) }
  sub subject_name { return(shift()->peer_certificate("subject")) }
  sub get_peer_certificate { return shift() }
  
  sub context_init {
      return($GLOBAL_SSL_ARGS = (ref($_[0]) eq 'HASH') ? $_[0] : {@_});
  }
  
  sub set_default_context {
      $GLOBAL_SSL_ARGS->{'SSL_reuse_ctx'} = shift;
  }
  
  sub set_default_session_cache {
      $GLOBAL_SSL_ARGS->{SSL_session_cache} = shift;
  }
  
  
  {
      my $set_defaults = sub {
  	my $args = shift;
  	for(my $i=0;$i<@$args;$i+=2 ) {
  	    my ($k,$v) = @{$args}[$i,$i+1];
  	    if ( $k =~m{^SSL_} ) {
  		$_->{$k} = $v for(@_);
  	    } elsif ( $k =~m{^(name|scheme)$} ) {
  		$_->{"SSL_verifycn_$k"} = $v for (@_);
  	    } elsif ( $k =~m{^(callback|mode)$} ) {
  		$_->{"SSL_verify_$k"} = $v for(@_);
  	    } else {
  		$_->{"SSL_$k"} = $v for(@_);
  	    }
  	}
      };
      sub set_defaults {
  	my %args = @_;
  	$set_defaults->(\@_,
  	    $GLOBAL_SSL_ARGS,
  	    $GLOBAL_SSL_CLIENT_ARGS,
  	    $GLOBAL_SSL_SERVER_ARGS
  	);
      }
      { # deprecated API
  	no warnings;
  	*set_ctx_defaults = \&set_defaults;
      }
      sub set_client_defaults {
  	my %args = @_;
  	$set_defaults->(\@_, $GLOBAL_SSL_CLIENT_ARGS );
      }
      sub set_server_defaults {
  	my %args = @_;
  	$set_defaults->(\@_, $GLOBAL_SSL_SERVER_ARGS );
      }
  }
  
  sub set_args_filter_hack {
      my $sub = shift;
      if ( ref $sub ) {
  	$FILTER_SSL_ARGS = $sub;
      } elsif ( $sub eq 'use_defaults' ) {
  	# override args with defaults
  	$FILTER_SSL_ARGS = sub {
  	    my ($is_server,$args) = @_;
  	    %$args = ( %$args, $is_server
  		? ( %DEFAULT_SSL_SERVER_ARGS, %$GLOBAL_SSL_SERVER_ARGS )
  		: ( %DEFAULT_SSL_CLIENT_ARGS, %$GLOBAL_SSL_CLIENT_ARGS )
  	    );
  	}
      }
  }
  
  sub next_proto_negotiated {
      my $self = shift;
      return $self->_internal_error("NPN not supported in Net::SSLeay",9) if ! $can_npn;
      my $ssl = $self->_get_ssl_object || return;
      return Net::SSLeay::P_next_proto_negotiated($ssl);
  }
  
  sub alpn_selected {
      my $self = shift;
      return $self->_internal_error("ALPN not supported in Net::SSLeay",9) if ! $can_alpn;
      my $ssl = $self->_get_ssl_object || return;
      return Net::SSLeay::P_alpn_selected($ssl);
  }
  
  sub opened {
      my $self = shift;
      return IO::Handle::opened($self) && ${*$self}{'_SSL_opened'};
  }
  
  sub opening {
      my $self = shift;
      return ${*$self}{'_SSL_opening'};
  }
  
  sub want_read  { shift->errstr == SSL_WANT_READ }
  sub want_write { shift->errstr == SSL_WANT_WRITE }
  
  
  #Redundant IO::Handle functionality
  sub getline { return(scalar shift->readline()) }
  sub getlines {
      return(shift->readline()) if wantarray();
      croak("Use of getlines() not allowed in scalar context");
  }
  
  #Useless IO::Handle functionality
  sub truncate { croak("Use of truncate() not allowed with SSL") }
  sub stat     { croak("Use of stat() not allowed with SSL" ) }
  sub setbuf   { croak("Use of setbuf() not allowed with SSL" ) }
  sub setvbuf  { croak("Use of setvbuf() not allowed with SSL" ) }
  sub fdopen   { croak("Use of fdopen() not allowed with SSL" ) }
  
  #Unsupported socket functionality
  sub ungetc { croak("Use of ungetc() not implemented in IO::Socket::SSL") }
  sub send   { croak("Use of send() not implemented in IO::Socket::SSL; use print/printf/syswrite instead") }
  sub recv   { croak("Use of recv() not implemented in IO::Socket::SSL; use read/sysread instead") }
  
  package IO::Socket::SSL::SSL_HANDLE;
  use strict;
  use Errno 'EBADF';
  *weaken = *IO::Socket::SSL::weaken;
  
  sub TIEHANDLE {
      my ($class, $handle) = @_;
      weaken($handle);
      bless \$handle, $class;
  }
  
  sub READ     { ${shift()}->sysread(@_) }
  sub READLINE { ${shift()}->readline(@_) }
  sub GETC     { ${shift()}->getc(@_) }
  
  sub PRINT    { ${shift()}->print(@_) }
  sub PRINTF   { ${shift()}->printf(@_) }
  sub WRITE    { ${shift()}->syswrite(@_) }
  
  sub FILENO   { ${shift()}->fileno(@_) }
  
  sub TELL     { $! = EBADF; return -1 }
  sub BINMODE  { return 0 }  # not perfect, but better than not implementing the method
  
  sub CLOSE {                          #<---- Do not change this function!
      my $ssl = ${$_[0]};
      local @_;
      $ssl->close();
  }
  
  
  package IO::Socket::SSL::SSL_Context;
  use Carp;
  use strict;
  
  my %CTX_CREATED_IN_THIS_THREAD;
  *DEBUG = *IO::Socket::SSL::DEBUG;
  
  use constant SSL_MODE_ENABLE_PARTIAL_WRITE => 1;
  use constant SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER => 2;
  
  use constant FILETYPE_PEM => Net::SSLeay::FILETYPE_PEM();
  use constant FILETYPE_ASN1 => Net::SSLeay::FILETYPE_ASN1();
  
  my $DEFAULT_SSL_OP = &Net::SSLeay::OP_ALL
      | &Net::SSLeay::OP_SINGLE_DH_USE
      | ($can_ecdh && &Net::SSLeay::OP_SINGLE_ECDH_USE);
  
  # Note that the final object will actually be a reference to the scalar
  # (C-style pointer) returned by Net::SSLeay::CTX_*_new() so that
  # it can be blessed.
  sub new {
      my $class = shift;
      #DEBUG( "$class @_" );
      my $arg_hash = (ref($_[0]) eq 'HASH') ? $_[0] : {@_};
  
      my $is_server = $arg_hash->{SSL_server};
      my %defaults = $is_server
  	? (%DEFAULT_SSL_SERVER_ARGS, %$GLOBAL_SSL_ARGS, %$GLOBAL_SSL_SERVER_ARGS) 
  	: (%DEFAULT_SSL_CLIENT_ARGS, %$GLOBAL_SSL_ARGS, %$GLOBAL_SSL_CLIENT_ARGS);
      if ( $defaults{SSL_reuse_ctx} ) {
  	# ignore default context if there are args to override it
  	delete $defaults{SSL_reuse_ctx}
  	    if grep { m{^SSL_(?!verifycn_name|hostname)$} } keys %$arg_hash;
      }
      %$arg_hash = ( %defaults, %$arg_hash ) if %defaults;
  
      if (my $ctx = $arg_hash->{'SSL_reuse_ctx'}) {
  	if ($ctx->isa('IO::Socket::SSL::SSL_Context') and
  	    $ctx->{context}) {
  	    # valid context
  	} elsif ( $ctx = ${*$ctx}{_SSL_ctx} ) {
  	    # reuse context from existing SSL object
  	}
  	return $ctx
      }
  
      # common problem forgetting to set SSL_use_cert
      # if client cert is given by user but SSL_use_cert is undef, assume that it
      # should be set
      if ( ! $is_server && ! defined $arg_hash->{SSL_use_cert}
  	&& ( grep { $arg_hash->{$_} } qw(SSL_cert SSL_cert_file))
  	&& ( grep { $arg_hash->{$_} } qw(SSL_key SSL_key_file)) ) {
  	$arg_hash->{SSL_use_cert} = 1
      }
  
      # if any of SSL_ca* is set don't set the other SSL_ca*
      # from defaults
      if ( $arg_hash->{SSL_ca} ) {
  	$arg_hash->{SSL_ca_file} ||= undef
  	$arg_hash->{SSL_ca_path} ||= undef
      } elsif ( $arg_hash->{SSL_ca_path} ) {
  	$arg_hash->{SSL_ca_file} ||= undef
      } elsif ( $arg_hash->{SSL_ca_file} ) {
  	$arg_hash->{SSL_ca_path} ||= undef;
      }
  
      # add library defaults
      $arg_hash->{SSL_use_cert} = $is_server if ! defined $arg_hash->{SSL_use_cert};
  
  
      # Avoid passing undef arguments to Net::SSLeay
      defined($arg_hash->{$_}) or delete($arg_hash->{$_}) for(keys %$arg_hash);
  
      # check SSL CA, cert etc arguments
      # some apps set keys '' to signal that it is not set, replace with undef
      for (qw( SSL_cert SSL_cert_file SSL_key SSL_key_file
  	SSL_ca SSL_ca_file SSL_ca_path
  	SSL_fingerprint )) {
  	$arg_hash->{$_} = undef if defined $arg_hash->{$_}
  	    and $arg_hash->{$_} eq '';
      }
      for(qw(SSL_cert_file SSL_key_file)) {
  	 defined( my $file = $arg_hash->{$_} ) or next;
  	for my $f (ref($file) eq 'HASH' ? values(%$file):$file ) {
  	    die "$_ $f can't be used: $!" if ! open(my $fh,'<',$f)
  	}
      }
  
      my $verify_mode = $arg_hash->{SSL_verify_mode} || 0;
      if ( $verify_mode != $Net_SSLeay_VERIFY_NONE) {
  	for (qw(SSL_ca_file SSL_ca_path)) {
  	    $CHECK_SSL_PATH->($_ => $arg_hash->{$_} || next);
  	}
      } elsif ( $verify_mode ne '0' ) {
  	# some users use the string 'SSL_VERIFY_PEER' instead of the constant
  	die "SSL_verify_mode must be a number and not a string";
      }
  
      my $self = bless {},$class;
  
      my $vcn_scheme = delete $arg_hash->{SSL_verifycn_scheme};
      my $vcn_publicsuffix = delete $arg_hash->{SSL_verifycn_publicsuffix};
      if ( ! $is_server and $verify_mode & 0x01 and
  	! $vcn_scheme || $vcn_scheme ne 'none' ) {
  
  	# gets updated during configure_SSL
  	my $verify_name;
  	$self->{verify_name_ref} = \$verify_name;
  
  	my $vcb = $arg_hash->{SSL_verify_callback};
  	$arg_hash->{SSL_verify_callback} = sub {
  	    my ($ok,$ctx_store,$certname,$error,$cert,$depth) = @_;
  	    $ok = $vcb->($ok,$ctx_store,$certname,$error,$cert,$depth) if $vcb;
  	    $ok or return 0;
  
  	    return $ok if $depth != 0;
  
  	    my $host = $verify_name || ref($vcn_scheme) && $vcn_scheme->{callback} && 'unknown';
  	    if ( ! $host ) {
  		if ( $vcn_scheme ) {
  		    IO::Socket::SSL->_internal_error(
  			"Cannot determine peer hostname for verification",8);
  		    return 0;
  		}
  		warn "Cannot determine hostname of peer for verification. ".
  		    "Disabling default hostname verification for now. ".
  		    "Please specify hostname with SSL_verifycn_name and better set SSL_verifycn_scheme too.\n";
  		return $ok;
  	    } elsif ( ! $vcn_scheme && $host =~m{^[\d.]+$|:} ) {
  		# don't try to verify IP by default
  		return $ok;
  	    }
  
  
  	    # verify name
  	    my $rv = IO::Socket::SSL::verify_hostname_of_cert(
  		$host,$cert,$vcn_scheme,$vcn_publicsuffix );
  	    if ( ! $rv ) {
  		IO::Socket::SSL->_internal_error(
  		    "hostname verification failed",5);
  	    }
  	    return $rv;
  	};
      }
  
      if ($is_server) {
  	if ($arg_hash->{SSL_ticket_keycb} && !$can_tckt_keycb) {
  	    warn "Ticket Key Callback is not supported - ignoring option SSL_ticket_keycb\n";
  	    delete $arg_hash->{SSL_ticket_keycb};
  	}
      }
  
  
      my $ssl_op = $DEFAULT_SSL_OP;
  
      my $ver;
      for (split(/\s*:\s*/,$arg_hash->{SSL_version})) {
  	m{^(!?)(?:(SSL(?:v2|v3|v23|v2/3))|(TLSv1(?:_?[123])?))$}i
  	or croak("invalid SSL_version specified");
  	my $not = $1;
  	( my $v = lc($2||$3) ) =~s{^(...)}{\U$1};
  	if ( $not ) {
  	    $ssl_op |= $SSL_OP_NO{$v};
  	} else {
  	    croak("cannot set multiple SSL protocols in SSL_version")
  		if $ver && $v ne $ver;
  	    $ver = $v;
  	    $ver =~s{/}{}; # interpret SSLv2/3 as SSLv23
  	    $ver =~s{(TLSv1)(\d)}{$1\_$2}; # TLSv1_1
  	}
      }
  
      my $ctx_new_sub =
  	$ver eq 'TLSv1_3' ? $CTX_tlsv1_3_new :
  	UNIVERSAL::can( 'Net::SSLeay',
  	    $ver eq 'SSLv2'   ? 'CTX_v2_new' :
  	    $ver eq 'SSLv3'   ? 'CTX_v3_new' :
  	    $ver eq 'TLSv1'   ? 'CTX_tlsv1_new' :
  	    $ver eq 'TLSv1_1' ? 'CTX_tlsv1_1_new' :
  	    $ver eq 'TLSv1_2' ? 'CTX_tlsv1_2_new' :
  	    'CTX_new'
  	)
  	or return IO::Socket::SSL->_internal_error("SSL Version $ver not supported",9);
  
      # For SNI in server mode we need a separate context for each certificate.
      my %ctx;
      if ($is_server) {
  	my %sni;
  	for my $opt (qw(SSL_key SSL_key_file SSL_cert SSL_cert_file)) {
  	    my $val  = $arg_hash->{$opt} or next;
  	    if ( ref($val) eq 'HASH' ) {
  		while ( my ($host,$v) = each %$val ) {
  		    $sni{lc($host)}{$opt} = $v;
  		}
  	    }
  	}
  	while (my ($host,$v) = each %sni) {
  	    $ctx{$host} = $host =~m{%} ? $v : { %$arg_hash, %$v };
  	}
      }
      $ctx{''} = $arg_hash if ! %ctx;
  
      for my $host (sort keys %ctx) {
  	my $arg_hash = delete $ctx{$host};
  	my $ctx;
  	if ($host =~m{^([^%]*)%}) {
  	    $ctx = $ctx{$1} or return IO::Socket::SSL->error(
  		"SSL Context init for $host failed - no config for $1");
  	    if (my @k = grep { !m{^SSL_(?:cert|key)(?:_file)?$} }
  		keys %$arg_hash) {
  		return IO::Socket::SSL->error(
  		    "invalid keys @k in configuration '$host' of additional certs");
  	    }
  	    $can_multi_cert or return IO::Socket::SSL->error(
  		"no support for both RSA and ECC certificate in same context");
  	    $host = $1;
  	    goto just_configure_certs;
  	}
  
  	$ctx = $ctx_new_sub->() or return
  	    IO::Socket::SSL->error("SSL Context init failed");
  	$CTX_CREATED_IN_THIS_THREAD{$ctx} = 1 if $use_threads;
  	$ctx{$host} = $ctx; # replace value in %ctx with real context
  
  	# SSL_OP_CIPHER_SERVER_PREFERENCE
  	$ssl_op |= 0x00400000 if $arg_hash->{SSL_honor_cipher_order};
  
  	if ($ver eq 'SSLv23' && !($ssl_op & $SSL_OP_NO{SSLv3})) {
  	    # At least LibreSSL disables SSLv3 by default in SSL_CTX_new.
  	    # If we really want SSL3.0 we need to explicitly allow it with
  	    # SSL_CTX_clear_options.
  	    Net::SSLeay::CTX_clear_options($ctx,$SSL_OP_NO{SSLv3});
  	}
  
  	Net::SSLeay::CTX_set_options($ctx,$ssl_op);
  
  	# enable X509_V_FLAG_PARTIAL_CHAIN if possible (OpenSSL 1.1.0+)
  	$check_partial_chain && $check_partial_chain->($ctx);
  
  	# if we don't set session_id_context if client certificate is expected
  	# client session caching will fail
  	# if user does not provide explicit id just use the stringification
  	# of the context
  	if($arg_hash->{SSL_server} and my $id = 
  	    $arg_hash->{SSL_session_id_context} || 
  	    ( $arg_hash->{SSL_verify_mode} & 0x01 ) && "$ctx" ) {
  	    Net::SSLeay::CTX_set_session_id_context($ctx,$id,length($id));
  	}
  
  	# SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER makes syswrite return if at least one
  	# buffer was written and not block for the rest
  	# SSL_MODE_ENABLE_PARTIAL_WRITE can be necessary for non-blocking because we
  	# cannot guarantee, that the location of the buffer stays constant
  	Net::SSLeay::CTX_set_mode( $ctx,
  	    SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER|SSL_MODE_ENABLE_PARTIAL_WRITE);
  
  	if ( my $proto_list = $arg_hash->{SSL_npn_protocols} ) {
  	    return IO::Socket::SSL->_internal_error("NPN not supported in Net::SSLeay",9)
  		if ! $can_npn;
  	    if($arg_hash->{SSL_server}) {
  		# on server side SSL_npn_protocols means a list of advertised protocols
  		Net::SSLeay::CTX_set_next_protos_advertised_cb($ctx, $proto_list);
  	    } else {
  		# on client side SSL_npn_protocols means a list of preferred protocols
  		# negotiation algorithm used is "as-openssl-implements-it"
  		Net::SSLeay::CTX_set_next_proto_select_cb($ctx, $proto_list);
  	    }
  	}
  
  	if ( my $proto_list = $arg_hash->{SSL_alpn_protocols} ) {
  	    return IO::Socket::SSL->_internal_error("ALPN not supported in Net::SSLeay",9)
  		if ! $can_alpn;
  	    if($arg_hash->{SSL_server}) {
  		Net::SSLeay::CTX_set_alpn_select_cb($ctx, $proto_list);
  	    } else {
  		Net::SSLeay::CTX_set_alpn_protos($ctx, $proto_list);
  	    }
  	}
  
  	if ($arg_hash->{SSL_ticket_keycb}) {
  	    my $cb = $arg_hash->{SSL_ticket_keycb};
  	    ($cb,my $arg) = ref($cb) eq 'CODE' ? ($cb):@$cb;
  	    Net::SSLeay::CTX_set_tlsext_ticket_getkey_cb($ctx,$cb,$arg);
  	}
  
  	# Try to apply SSL_ca even if SSL_verify_mode is 0, so that they can be
  	# used to verify OCSP responses.
  	# If applying fails complain only if verify_mode != VERIFY_NONE.
  	if ( $arg_hash->{SSL_ca}
  	    || defined $arg_hash->{SSL_ca_file}
  	    || defined $arg_hash->{SSL_ca_path} ) {
  	    my $file = $arg_hash->{SSL_ca_file};
  	    $file = undef if ref($file) eq 'SCALAR' && ! $$file;
  	    my $dir = $arg_hash->{SSL_ca_path};
  	    $dir = undef if ref($dir) eq 'SCALAR' && ! $$dir;
  	    if ( $arg_hash->{SSL_ca} ) {
  		my $store = Net::SSLeay::CTX_get_cert_store($ctx);
  		for (@{$arg_hash->{SSL_ca}}) {
  		    Net::SSLeay::X509_STORE_add_cert($store,$_) or
  			return IO::Socket::SSL->error(
  			    "Failed to add certificate to CA store");
  		}
  	    }
  	    $dir = join($OPENSSL_LIST_SEPARATOR,@$dir) if ref($dir);
  	    if ( $file || $dir and ! Net::SSLeay::CTX_load_verify_locations(
  		$ctx, $file || '', $dir || '')) {
  		return IO::Socket::SSL->error(
  		    "Invalid certificate authority locations")
  		    if $verify_mode != $Net_SSLeay_VERIFY_NONE;
  	    }
  	} elsif ( my %ca = IO::Socket::SSL::default_ca()) {
  	    # no CA path given, continue with system defaults
  	    my $dir = $ca{SSL_ca_path};
  	    $dir = join($OPENSSL_LIST_SEPARATOR,@$dir) if ref($dir);
  	    if (! Net::SSLeay::CTX_load_verify_locations( $ctx,
  		$ca{SSL_ca_file} || '',$dir || '')
  		&& $verify_mode != $Net_SSLeay_VERIFY_NONE) {
  		return IO::Socket::SSL->error(
  		    "Invalid default certificate authority locations")
  	    }
  	}
  
  	if ($is_server && ($verify_mode & $Net_SSLeay_VERIFY_PEER)) {
  	    if ($arg_hash->{SSL_client_ca}) {
  		for (@{$arg_hash->{SSL_client_ca}}) {
  		    return IO::Socket::SSL->error(
  			"Failed to add certificate to client CA list") if
  			! Net::SSLeay::CTX_add_client_CA($ctx,$_);
  		}
  	    }
  	    if ($arg_hash->{SSL_client_ca_file}) {
  		my $list = Net::SSLeay::load_client_CA_file(
  		    $arg_hash->{SSL_client_ca_file}) or
  		    return IO::Socket::SSL->error(
  		    "Failed to load certificate to client CA list");
  		Net::SSLeay::CTX_set_client_CA_list($ctx,$list);
  	    }
  	}
  
  	my $X509_STORE_flags = $DEFAULT_X509_STORE_flags;
  	if ($arg_hash->{'SSL_check_crl'}) {
  	    $X509_STORE_flags |= Net::SSLeay::X509_V_FLAG_CRL_CHECK();
  	    if ($arg_hash->{'SSL_crl_file'}) {
  		my $bio = Net::SSLeay::BIO_new_file($arg_hash->{'SSL_crl_file'}, 'r');
  		my $crl = Net::SSLeay::PEM_read_bio_X509_CRL($bio);
  		Net::SSLeay::BIO_free($bio);
  		if ( $crl ) {
  		    Net::SSLeay::X509_STORE_add_crl(Net::SSLeay::CTX_get_cert_store($ctx), $crl);
  		    Net::SSLeay::X509_CRL_free($crl);
  		} else {
  		    return IO::Socket::SSL->error("Invalid certificate revocation list");
  		}
  	    }
  	}
  
  	Net::SSLeay::X509_STORE_set_flags(
  	    Net::SSLeay::CTX_get_cert_store($ctx),
  	    $X509_STORE_flags
  	) if $X509_STORE_flags;
  
  	Net::SSLeay::CTX_set_default_passwd_cb($ctx,$arg_hash->{SSL_passwd_cb})
  	    if $arg_hash->{SSL_passwd_cb};
  
  	just_configure_certs:
  	my ($havekey,$havecert);
  	if ( my $x509 = $arg_hash->{SSL_cert} ) {
  	    # binary, e.g. X509*
  	    # we have either a single certificate or a list with
  	    # a chain of certificates
  	    my @x509 = ref($x509) eq 'ARRAY' ? @$x509: ($x509);
  	    my $cert = shift @x509;
  	    Net::SSLeay::CTX_use_certificate( $ctx,$cert )
  		|| return IO::Socket::SSL->error("Failed to use Certificate");
  	    foreach my $ca (@x509) {
  		Net::SSLeay::CTX_add_extra_chain_cert( $ctx,$ca )
  		    || return IO::Socket::SSL->error("Failed to use Certificate");
  	    }
  	    $havecert = 'OBJ';
  	} elsif ( my $f = $arg_hash->{SSL_cert_file} ) {
  	    # try to load chain from PEM or certificate from ASN1
  	    if (Net::SSLeay::CTX_use_certificate_chain_file($ctx,$f)) {
  		$havecert = 'PEM';
  	    } elsif (Net::SSLeay::CTX_use_certificate_file($ctx,$f,FILETYPE_ASN1)) {
  		$havecert = 'DER';
  	    } else {
  		# try to load certificate, key and chain from PKCS12 file
  		my ($key,$cert,@chain) = Net::SSLeay::P_PKCS12_load_file($f,1);
  		if (!$cert and $arg_hash->{SSL_passwd_cb}
  		    and defined( my $pw = $arg_hash->{SSL_passwd_cb}->(0))) {
  		    ($key,$cert,@chain) = Net::SSLeay::P_PKCS12_load_file($f,1,$pw);
  		}
  		PKCS12: while ($cert) {
  		    Net::SSLeay::CTX_use_certificate($ctx,$cert) or last;
  		    # Net::SSLeay::P_PKCS12_load_file is implemented using
  		    # OpenSSL PKCS12_parse which according to the source code
  		    # returns the chain with the last CA certificate first (i.e.
  		    # reverse order as in the PKCS12 file). This is not
  		    # documented but given the age of this function we'll assume
  		    # that this will stay this way in the future.
  		    while (my $ca = pop @chain) {
  			Net::SSLeay::CTX_add_extra_chain_cert($ctx,$ca)
  			    or last PKCS12;
  		    }
  		    last if $key && ! Net::SSLeay::CTX_use_PrivateKey($ctx,$key);
  		    $havecert = 'PKCS12';
  		    last;
  		}
  		$havekey = 'PKCS12' if $key;
  		Net::SSLeay::X509_free($cert) if $cert;
  		Net::SSLeay::EVP_PKEY_free($key) if $key;
  		# don't free @chain, because CTX_add_extra_chain_cert
  		# did not duplicate the certificates
  	    }
  	    $havecert or return IO::Socket::SSL->error(
  		"Failed to load certificate from file (no PEM, DER or PKCS12)");
  	}
  
  	if (!$havecert || $havekey) {
  	    # skip SSL_key_*
  	} elsif ( my $pkey = $arg_hash->{SSL_key} ) {
  	    # binary, e.g. EVP_PKEY*
  	    Net::SSLeay::CTX_use_PrivateKey($ctx, $pkey)
  		|| return IO::Socket::SSL->error("Failed to use Private Key");
  	    $havekey = 'MEM';
  	} elsif ( my $f = $arg_hash->{SSL_key_file}
  	    || (($havecert eq 'PEM') ? $arg_hash->{SSL_cert_file}:undef) ) {
  	    for my $ft ( FILETYPE_PEM, FILETYPE_ASN1 ) {
  		if (Net::SSLeay::CTX_use_PrivateKey_file($ctx,$f,$ft)) {
  		    $havekey = ($ft == FILETYPE_PEM) ? 'PEM':'DER';
  		    last;
  		}
  	    }
  	    $havekey or return IO::Socket::SSL->error(
  		"Failed to load key from file (no PEM or DER)");
  	}
  
          Net::SSLeay::CTX_set_post_handshake_auth($ctx,1)
              if (!$is_server && $can_pha && $havecert && $havekey);
      }
  
      if ($arg_hash->{SSL_server}) {
  
  	if ( my $f = $arg_hash->{SSL_dh_file} ) {
  	    my $bio = Net::SSLeay::BIO_new_file( $f,'r' )
  		|| return IO::Socket::SSL->error( "Failed to open DH file $f" );
  	    my $dh = Net::SSLeay::PEM_read_bio_DHparams($bio);
  	    Net::SSLeay::BIO_free($bio);
  	    $dh || return IO::Socket::SSL->error( "Failed to read PEM for DH from $f - wrong format?" );
  	    my $rv;
  	    for (values (%ctx)) {
  		$rv = Net::SSLeay::CTX_set_tmp_dh( $_,$dh ) or last;
  	    }
  	    Net::SSLeay::DH_free( $dh );
  	    $rv || return IO::Socket::SSL->error( "Failed to set DH from $f" );
  	} elsif ( my $dh = $arg_hash->{SSL_dh} ) {
  	    # binary, e.g. DH*
  
  	    for( values %ctx ) {
  		Net::SSLeay::CTX_set_tmp_dh( $_,$dh ) || return 
  		    IO::Socket::SSL->error( "Failed to set DH from SSL_dh" );
  	    }
  	}
      }
  
      if ( my $curve = $arg_hash->{SSL_ecdh_curve} ) {
  	return IO::Socket::SSL->_internal_error(
  	    "ECDH curve needs Net::SSLeay>=1.56 and OpenSSL>=1.0",9)
  	    if ! $can_ecdh;
  
  	for(values %ctx) {
  	    if ($arg_hash->{SSL_server} and $curve eq 'auto') {
  		if ($can_ecdh eq 'can_auto') {
  			Net::SSLeay::CTX_set_ecdh_auto($_,1) or
  			    return IO::Socket::SSL->error(
  			    "failed to set ECDH curve context");
  		} elsif ($can_ecdh eq 'auto') {
  		    # automatically enabled anyway
  		} else {
  		    return IO::Socket::SSL->error(
  			"SSL_CTX_set_ecdh_auto not implemented");
  		}
  
  	    } elsif ($set_groups_list) {
  		$set_groups_list->($_,$curve) or return IO::Socket::SSL->error(
  		    "failed to set ECDH groups/curves on context");
  		# needed for OpenSSL 1.0.2 if ($can_ecdh eq 'can_auto') {
  		Net::SSLeay::CTX_set_ecdh_auto($_,1) if $can_ecdh eq 'can_auto';
  	    } elsif ($curve =~m{:}) {
  		return IO::Socket::SSL->error(
  		    "SSL_CTX_groups_list or SSL_CTX_curves_list not implemented");
  
  	    } elsif ($arg_hash->{SSL_server}) {
  		if ( $curve !~ /^\d+$/ ) {
  		    # name of curve, find NID
  		    $curve = Net::SSLeay::OBJ_txt2nid($curve)
  			|| return IO::Socket::SSL->error(
  			"cannot find NID for curve name '$curve'");
  		}
  		my $ecdh = Net::SSLeay::EC_KEY_new_by_curve_name($curve) or
  		    return IO::Socket::SSL->error(
  		    "cannot create curve for NID $curve");
  		for( values %ctx ) {
  		    Net::SSLeay::CTX_set_tmp_ecdh($_,$ecdh) or
  			return IO::Socket::SSL->error(
  			"failed to set ECDH curve context");
  		}
  		Net::SSLeay::EC_KEY_free($ecdh);
  	    }
  	}
      }
  
      my $verify_cb = $arg_hash->{SSL_verify_callback};
      my @accept_fp;
      if ( my $fp = $arg_hash->{SSL_fingerprint} ) {
  	for( ref($fp) ? @$fp : $fp) {
  	    my ($algo,$pubkey,$digest) = m{^(?:([\w-]+)\$)?(pub\$)?([a-f\d:]+)$}i
  		or return IO::Socket::SSL->_internal_error("invalid fingerprint '$_'",9);
  	    ( $digest = lc($digest) ) =~s{:}{}g;
  	    $algo ||=
  		length($digest) == 32 ? 'md5' :
  		length($digest) == 40 ? 'sha1' :
  		length($digest) == 64 ? 'sha256' :
  		return IO::Socket::SSL->_internal_error(
  		    "cannot detect hash algorithem from fingerprint '$_'",9);
  	    $algo = lc($algo);
  	    push @accept_fp,[ $algo, $pubkey || '', pack('H*',$digest) ]
  	}
      }
      my $verify_fingerprint = @accept_fp && do {
  	my $fail;
  	sub {
  	    my ($ok,$cert,$depth) = @_;
  	    $fail = 1 if ! $ok;
  	    return 1 if $depth>0; # to let us continue with verification
  	    # Check fingerprint only from top certificate.
  	    my %fp;
  	    for(@accept_fp) {
  		my $fp = $fp{$_->[0],$_->[1]} ||= $_->[1]
  		    ? Net::SSLeay::X509_pubkey_digest($cert,$algo2digest->($_->[0]))
  		    : Net::SSLeay::X509_digest($cert,$algo2digest->($_->[0]));
  		next if $fp ne $_->[2];
  		return 1;
  	    }
  	    return ! $fail;
  	}
      };
      my $verify_callback = ( $verify_cb || @accept_fp ) && sub {
  	my ($ok, $ctx_store) = @_;
  	my ($certname,$cert,$error,$depth);
  	if ($ctx_store) {
  	    $cert  = Net::SSLeay::X509_STORE_CTX_get_current_cert($ctx_store);
  	    $error = Net::SSLeay::X509_STORE_CTX_get_error($ctx_store);
  	    $depth = Net::SSLeay::X509_STORE_CTX_get_error_depth($ctx_store);
  	    $certname =
  		Net::SSLeay::X509_NAME_oneline(Net::SSLeay::X509_get_issuer_name($cert)).
  		Net::SSLeay::X509_NAME_oneline(Net::SSLeay::X509_get_subject_name($cert));
  	    $error &&= Net::SSLeay::ERR_error_string($error);
  	}
  	$DEBUG>=3 && DEBUG( "ok=$ok [$depth] $certname" );
  	$ok = $verify_cb->($ok,$ctx_store,$certname,$error,$cert,$depth) if $verify_cb;
  	$ok = $verify_fingerprint->($ok,$cert,$depth) if $verify_fingerprint && $cert;
  	return $ok;
      };
  
      if ( $^O eq 'darwin' ) {
  	# explicitly set error code to disable use of apples TEA patch
  	# https://hynek.me/articles/apple-openssl-verification-surprises/
  	my $vcb = $verify_callback;
  	$verify_callback = sub {
  	    my $rv = $vcb ? &$vcb : $_[0];
  	    if ( $rv != 1 ) {
  		# 50 - X509_V_ERR_APPLICATION_VERIFICATION: application verification failure
  		Net::SSLeay::X509_STORE_CTX_set_error($_[1], 50);
  	    }
  	    return $rv;
  	};
      }
      Net::SSLeay::CTX_set_verify($_, $verify_mode, $verify_callback)
  	for (values %ctx);
  
      my $staple_callback = $arg_hash->{SSL_ocsp_staple_callback};
      if ( !$is_server && $can_ocsp_staple && ! $verify_fingerprint) {
  	$self->{ocsp_cache} = $arg_hash->{SSL_ocsp_cache};
  	my $status_cb = sub {
  	    my ($ssl,$resp) = @_;
  	    my $iossl = $SSL_OBJECT{$ssl} or
  		die "no IO::Socket::SSL object found for SSL $ssl";
  	    $iossl->[1] and do {
  		# we must return with 1 or it will be called again
  		# and because we have no SSL object we must make the error global
  		Carp::cluck($IO::Socket::SSL::SSL_ERROR
  		    = "OCSP callback on server side");
  		return 1;
  	    };
  	    $iossl = $iossl->[0];
  
  	    # if we have a callback use this
  	    # callback must not free or copy $resp !!
  	    if ( $staple_callback ) {
  		$staple_callback->($iossl,$resp);
  		return 1;
  	    }
  
  	    # default callback does verification
  	    if ( ! $resp ) {
  		$DEBUG>=3 && DEBUG("did not get stapled OCSP response");
  		return 1;
  	    }
  	    $DEBUG>=3 && DEBUG("got stapled OCSP response");
  	    my $status = Net::SSLeay::OCSP_response_status($resp);
  	    if ($status != Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL()) {
  		$DEBUG>=3 && DEBUG("bad status of stapled OCSP response: ".
  		    Net::SSLeay::OCSP_response_status_str($status));
  		return 1;
  	    }
  	    if (!eval { Net::SSLeay::OCSP_response_verify($ssl,$resp) }) {
  		$DEBUG>=3 && DEBUG("verify of stapled OCSP response failed");
  		return 1;
  	    }
  	    my (@results,$hard_error);
  	    my @chain = $iossl->peer_certificates;
  	    for my $cert (@chain) {
  		my $certid = eval { Net::SSLeay::OCSP_cert2ids($ssl,$cert) };
  		if (!$certid) {
  		    $DEBUG>=3 && DEBUG("cannot create OCSP_CERTID: $@");
  		    push @results,[-1,$@];
  		    last;
  		}
  		($status) = Net::SSLeay::OCSP_response_results($resp,$certid);
  		if ($status && $status->[2]) {
  		    my $cache = ${*$iossl}{_SSL_ctx}{ocsp_cache};
  		    if (!$status->[1]) {
  			push @results,[1,$status->[2]{nextUpdate}];
  			$cache && $cache->put($certid,$status->[2]);
  		    } elsif ( $status->[2]{statusType} ==
  			Net::SSLeay::V_OCSP_CERTSTATUS_GOOD()) {
  			push @results,[1,$status->[2]{nextUpdate}];
  			$cache && $cache->put($certid,{
  			    %{$status->[2]},
  			    expire => time()+120,
  			    soft_error => $status->[1],
  			});
  		    } else {
  			push @results,($hard_error = [0,$status->[1]]);
  			$cache && $cache->put($certid,{
  			    %{$status->[2]},
  			    hard_error => $status->[1],
  			});
  		    }
  		}
  	    }
  	    # return result of lead certificate, this should be in chain[0] and
  	    # thus result[0], but we better check. But if we had any hard_error
  	    # return this instead
  	    if ($hard_error) {
  		${*$iossl}{_SSL_ocsp_verify} = $hard_error;
  	    } elsif (@results and $chain[0] == $iossl->peer_certificate) {
  		${*$iossl}{_SSL_ocsp_verify} = $results[0];
  	    }
  	    return 1;
  	};
  	Net::SSLeay::CTX_set_tlsext_status_cb($_,$status_cb) for (values %ctx);
      }
  
      if ( my $cl = $arg_hash->{SSL_cipher_list} ) {
  	for (keys %ctx) {
  	    Net::SSLeay::CTX_set_cipher_list($ctx{$_}, ref($cl) 
  		? $cl->{$_} || $cl->{''} || $DEFAULT_SSL_ARGS{SSL_cipher_list} || next 
  		: $cl
  	    ) || return IO::Socket::SSL->error("Failed to set SSL cipher list");
  	}
      }
  
      # Main context is default context or any other if no default context.
      my $ctx = $ctx{''} || (values %ctx)[0];
      if (keys(%ctx) > 1 || ! exists $ctx{''}) {
  	$can_server_sni or return IO::Socket::SSL->_internal_error(
  	    "Server side SNI not supported for this openssl/Net::SSLeay",9);
  
  	Net::SSLeay::CTX_set_tlsext_servername_callback($ctx, sub {
  	    my $ssl = shift;
  	    my $host = Net::SSLeay::get_servername($ssl);
  	    $host = '' if ! defined $host;
  	    my $snictx = $ctx{lc($host)} || $ctx{''} or do {
  		$DEBUG>1 and DEBUG(
  		    "cannot get context from servername '$host'");
  		return 0;
  	    };
  	    $DEBUG>1 and DEBUG("set context from servername $host");
  	    Net::SSLeay::set_SSL_CTX($ssl,$snictx) if $snictx != $ctx;
  	    return 1;
  	});
      }
  
      if ( my $cb = $arg_hash->{SSL_create_ctx_callback} ) {
  	$cb->($_) for values (%ctx);
      }
  
      $self->{context} = $ctx;
      $self->{verify_mode} = $arg_hash->{SSL_verify_mode};
      $self->{ocsp_mode} =
  	defined($arg_hash->{SSL_ocsp_mode}) ? $arg_hash->{SSL_ocsp_mode} :
  	$self->{verify_mode} ? IO::Socket::SSL::SSL_OCSP_TRY_STAPLE() :
  	0;
      $DEBUG>=3 && DEBUG( "new ctx $ctx" );
  
      if ( my $cache = $arg_hash->{SSL_session_cache} ) {
  	# use predefined cache
  	$self->{session_cache} = $cache
      } elsif ( my $size = $arg_hash->{SSL_session_cache_size}) {
  	$self->{session_cache} = IO::Socket::SSL::Session_Cache->new( $size );
      }
  
  
      if ($self->{session_cache} and %sess_cb) {
  	Net::SSLeay::CTX_set_session_cache_mode($ctx,
  	    Net::SSLeay::SESS_CACHE_CLIENT());
  	my $cache = $self->{session_cache};
  	$sess_cb{new}($ctx, sub {
  	    my ($ssl,$session) = @_;
  	    my $self = ($SSL_OBJECT{$ssl} || do {
  		warn "callback session new: no known SSL object for $ssl";
  		return;
  	    })->[0];
  	    my $args = ${*$self}{_SSL_arguments};
  	    my $key = $args->{SSL_session_key} or do {
  		warn "callback session new: no known SSL_session_key for $ssl";
  		return;
  	    };
  	    $DEBUG>=3 && DEBUG("callback session new <$key> $session");
  	    Net::SSLeay::SESSION_up_ref($session);
  	    $cache->add_session($key,$session);
  	});
  	$sess_cb{remove}($ctx, sub {
  	    my ($ctx,$session) = @_;
  	    $DEBUG>=3 && DEBUG("callback session remove $session");
  	    $cache->del_session(undef,$session);
  	});
      }
  
      return $self;
  }
  
  
  sub has_session_cache {
      return defined shift->{session_cache};
  }
  
  
  sub CLONE { %CTX_CREATED_IN_THIS_THREAD = (); }
  sub DESTROY {
      my $self = shift;
      if ( my $ctx = $self->{context} ) {
  	$DEBUG>=3 && DEBUG("free ctx $ctx open=".join( " ",keys %CTX_CREATED_IN_THIS_THREAD ));
  	if (!$use_threads or delete $CTX_CREATED_IN_THIS_THREAD{$ctx} ) {
  	    # remove any verify callback for this context
  	    if ( $self->{verify_mode}) {
  		$DEBUG>=3 && DEBUG("free ctx $ctx callback" );
  		Net::SSLeay::CTX_set_verify($ctx, 0,undef);
  	    }
  	    if ( $self->{ocsp_error_ref}) {
  		$DEBUG>=3 && DEBUG("free ctx $ctx tlsext_status_cb" );
  		Net::SSLeay::CTX_set_tlsext_status_cb($ctx,undef);
  	    }
  	    $DEBUG>=3 && DEBUG("OK free ctx $ctx" );
  	    Net::SSLeay::CTX_free($ctx);
  	}
      }
      delete(@{$self}{'context','session_cache'});
  }
  
  package IO::Socket::SSL::Session_Cache;
  *DEBUG = *IO::Socket::SSL::DEBUG;
  use constant {
      SESSION => 0,
      KEY     => 1,
      GNEXT   => 2,
      GPREV   => 3,
      SNEXT   => 4,
      SPREV   => 5,
  };
  
  sub new {
      my ($class, $size) = @_;
      $size>0 or return;
      return bless {
  	room  => $size,
  	ghead => undef,
  	shead => {},
      }, $class;
  }
  
  sub add_session {
      my ($self, $key, $session) = @_;
  
      # create new
      my $v = [];
      $v->[SESSION] = $session;
      $v->[KEY] = $key;
      $DEBUG>=3 && DEBUG("add_session($key,$session)");
      _add_entry($self,$v);
  }
  
  sub replace_session {
      my ($self, $key, $session) = @_;
      $self->del_session($key);
      $self->add_session($key, $session);
  }
  
  sub del_session {
      my ($self, $key, $session) = @_;
      my ($head,$inext) = $key
  	? ($self->{shead}{$key},SNEXT) : ($self->{ghead},GNEXT);
      my $v = $head;
      my @del;
      while ($v) {
  	if (!$session) {
  	    push @del,$v
  	} elsif ($v->[SESSION] == $session) {
  	    push @del, $v;
  	    last;
  	}
  	$v = $v->[$inext];
  	last if $v == $head;
      }
      $DEBUG>=3 && DEBUG("del_session("
  	. ($key ? $key : "undef")
  	. ($session ? ",$session) -> " : ") -> ")
  	.  (~~@del || 'none'));
      for (@del) {
  	_del_entry($self,$_);
  	Net::SSLeay::SESSION_free($_->[SESSION]) if $_->[SESSION];
      }
      return ~~@del;
  }
  
  sub get_session {
      my ($self, $key, $session) = @_;
      my $v = $self->{shead}{$key};
      if ($session) {
  	my $shead = $v;
  	while ($v) {
  	    $DEBUG>=3 && DEBUG("check $session - $v->[SESSION]");
  	    last if $v->[SESSION] == $session;
  	    $v = $v->[SNEXT];
  	    $v = undef if $v == $shead; # session not found
  	}
      }
      if ($v) {
  	_del_entry($self, $v); # remove
  	_add_entry($self, $v); # and add back on top
      }
      $DEBUG>=3 && DEBUG("get_session($key"
  	. ( $session ? ",$session) -> " : ") -> ")
  	. ($v? $v->[SESSION]:"none"));
      return $v && $v->[SESSION];
  }
  
  sub _add_entry {
      my ($self,$v) = @_;
      for(
  	[ SNEXT, SPREV, \$self->{shead}{$v->[KEY]} ],
  	[ GNEXT, GPREV, \$self->{ghead} ],
      ) {
  	my ($inext,$iprev,$rhead) = @$_;
  	if ($$rhead) {
  	    $v->[$inext] = $$rhead;
  	    $v->[$iprev] = ${$rhead}->[$iprev];
  	    ${$rhead}->[$iprev][$inext] = $v;
  	    ${$rhead}->[$iprev] = $v;
  	} else {
  	    $v->[$inext] = $v->[$iprev] = $v;
  	}
  	$$rhead = $v;
      }
  
      $self->{room}--;
  
      # drop old entries if necessary
      if ($self->{room}<0) {
  	my $l = $self->{ghead}[GPREV];
  	_del_entry($self,$l);
  	Net::SSLeay::SESSION_free($l->[SESSION]) if $l->[SESSION];
      }
  }
  
  sub _del_entry {
      my ($self,$v) = @_;
      for(
  	[ SNEXT, SPREV, \$self->{shead}{$v->[KEY]} ],
  	[ GNEXT, GPREV, \$self->{ghead} ],
      ) {
  	my ($inext,$iprev,$rhead) = @$_;
  	$$rhead or return;
  	$v->[$inext][$iprev] = $v->[$iprev];
  	$v->[$iprev][$inext] = $v->[$inext];
  	if ($v != $$rhead) {
  	    # not removed from top of list
  	} elsif ($v->[$inext] == $v) {
  	    # was only element on list, drop list
  	    if ($inext == SNEXT) {
  		delete $self->{shead}{$v->[KEY]};
  	    } else {
  		$$rhead = undef;
  	    }
  	} else {
  	    # was top element, keep others
  	    $$rhead = $v->[$inext];
  	}
      }
      $self->{room}++;
  }
  
  sub _dump {
      my $self = shift;
  
      my %v2i;
      my $v = $self->{ghead};
      while ($v) {
  	exists $v2i{$v} and die;
  	$v2i{$v} = int(keys %v2i);
  	$v = $v->[GNEXT];
  	last if $v == $self->{ghead};
      }
  
      my $out = "room: $self->{room}\nghead:\n";
      $v = $self->{ghead};
      while ($v) {
  	$out .= sprintf(" - [%d] <%d,%d> '%s' <%s>\n",
  	    $v2i{$v}, $v2i{$v->[GPREV]}, $v2i{$v->[GNEXT]},
  	    $v->[KEY], $v->[SESSION]);
  	$v = $v->[GNEXT];
  	last if $v == $self->{ghead};
      }
      $out .= "shead:\n";
      for my $key (sort keys %{$self->{shead}}) {
  	$out .= " - '$key'\n";
  	my $shead = $self->{shead}{$key};
  	my $v = $shead;
  	while ($v) {
  	    $out .= sprintf("   - [%d] <%d,%d> '%s' <%s>\n",
  		$v2i{$v}, $v2i{$v->[SPREV]}, $v2i{$v->[SNEXT]},
  		$v->[KEY], $v->[SESSION]);
  	    $v = $v->[SNEXT];
  	    last if $v == $shead;
  	}
      }
      return $out;
  }
  
  sub DESTROY {
      my $self = shift;
      delete $self->{shead};
      my $v = delete $self->{ghead};
      while ($v) {
  	Net::SSLeay::SESSION_free($v->[SESSION]) if $v->[SESSION];
  	my $next = $v->[GNEXT];
  	@$v = ();
  	$v = $next;
      }
  }
  
  
  
  package IO::Socket::SSL::OCSP_Cache;
  
  sub new {
      my ($class,$size) = @_;
      return bless {
  	'' => { _lru => 0, size => $size || 100 }
      },$class;
  }
  sub get {
      my ($self,$id) = @_;
      my $e = $self->{$id} or return;
      $e->{_lru} = $self->{''}{_lru}++;
      if ( $e->{expire} && time()<$e->{expire}) {
  	delete $self->{$id};
  	return;
      }
      if ( $e->{nextUpdate} && time()<$e->{nextUpdate} ) {
  	delete $self->{$id};
  	return;
      }
      return $e;
  }
  
  sub put {
      my ($self,$id,$e) = @_;
      $self->{$id} = $e;
      $e->{_lru} = $self->{''}{_lru}++;
      my $del = keys(%$self) - $self->{''}{size};
      if ($del>0) {
  	my @k = sort { $self->{$a}{_lru} <=> $self->{$b}{_lru} } keys %$self;
  	delete @{$self}{ splice(@k,0,$del) };
      }
      return $e;
  }
  
  package IO::Socket::SSL::OCSP_Resolver;
  *DEBUG = *IO::Socket::SSL::DEBUG;
  
  # create a new resolver
  # $ssl - the ssl object
  # $cache - OCSP_Cache object (put,get)
  # $failhard - flag if we should fail hard on OCSP problems
  # $certs - list of certs to verify
  sub new {
      my ($class,$ssl,$cache,$failhard,$certs) = @_;
      my (%todo,$done,$hard_error,@soft_error);
      for my $cert (@$certs) {
  	# skip entries which have no OCSP uri or where we cannot get a certid
  	# (e.g. self-signed or where we don't have the issuer)
  	my $subj = Net::SSLeay::X509_NAME_oneline(Net::SSLeay::X509_get_subject_name($cert));
  	my $uri = Net::SSLeay::P_X509_get_ocsp_uri($cert) or do {
  	    $DEBUG>2 && DEBUG("no URI for certificate $subj");
  	    push @soft_error,"no ocsp_uri for $subj";
  	    next;
  	};
  	my $certid = eval { Net::SSLeay::OCSP_cert2ids($ssl,$cert) } or do {
  	    $DEBUG>2 && DEBUG("no OCSP_CERTID for certificate $subj: $@");
  	    push @soft_error,"no certid for $subj: $@";
  	    next;
  	};
  	if (!($done = $cache->get($certid))) {
  	    push @{ $todo{$uri}{ids} }, $certid;
  	    push @{ $todo{$uri}{subj} }, $subj;
  	} elsif ( $done->{hard_error} ) {
  	    # one error is enough to fail validation
  	    $hard_error = $done->{hard_error};
  	    %todo = ();
  	    last;
  	} elsif ( $done->{soft_error} ) {
  	    push @soft_error,$done->{soft_error};
  	}
      }
      while ( my($uri,$v) = each %todo) {
  	my $ids = $v->{ids};
  	$v->{req} = Net::SSLeay::i2d_OCSP_REQUEST(
  	    Net::SSLeay::OCSP_ids2req(@$ids));
      }
      $hard_error ||= '' if ! %todo;
      return bless {
  	ssl => $ssl,
  	cache => $cache,
  	failhard => $failhard,
  	hard_error => $hard_error,
  	soft_error => @soft_error ? join("; ",@soft_error) : undef,
  	todo => \%todo,
      },$class;
  }
  
  # return current result, e.g. '' for no error, else error
  # if undef we have no final result yet
  sub hard_error { return shift->{hard_error} }
  sub soft_error { return shift->{soft_error} }
  
  # return hash with uri => ocsp_request_data for open requests
  sub requests {
      my $todo = shift()->{todo};
      return map { ($_,$todo->{$_}{req}) } keys %$todo;
  }
  
  # add new response
  sub add_response {
      my ($self,$uri,$resp) = @_;
      my $todo = delete $self->{todo}{$uri};
      return $self->{error} if ! $todo || $self->{error};
  
      my ($req,@soft_error,@hard_error);
  
      # do we have a response
      if (!$resp) {
  	@soft_error = "http request for OCSP failed; subject: ".
  	    join("; ",@{$todo->{subj}});
  
      # is it a valid OCSP_RESPONSE
      } elsif ( ! eval { $resp = Net::SSLeay::d2i_OCSP_RESPONSE($resp) }) {
  	@soft_error = "invalid response (no OCSP_RESPONSE); subject: ".
  	    join("; ",@{$todo->{subj}});
  	# hopefully short-time error
  	$self->{cache}->put($_,{
  	    soft_error => "@soft_error",
  	    expire => time()+10,
  	}) for (@{$todo->{ids}});
      # is the OCSP response status success
      } elsif (
  	( my $status = Net::SSLeay::OCSP_response_status($resp))
  	    != Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL()
      ){
  	@soft_error = "OCSP response failed: ".
  	    Net::SSLeay::OCSP_response_status_str($status).
  	    "; subject: ".join("; ",@{$todo->{subj}});
  	# hopefully short-time error
  	$self->{cache}->put($_,{
  	    soft_error => "@soft_error",
  	    expire => time()+10,
  	}) for (@{$todo->{ids}});
  
      # does nonce match the request and can the signature be verified
      } elsif ( ! eval {
  	$req = Net::SSLeay::d2i_OCSP_REQUEST($todo->{req});
  	Net::SSLeay::OCSP_response_verify($self->{ssl},$resp,$req);
      }) {
  	if ($@) {
  	    @soft_error = $@
  	} else {
  	    my @err;
  	    while ( my $err = Net::SSLeay::ERR_get_error()) {
  		push @soft_error, Net::SSLeay::ERR_error_string($err);
  	    }
  	    @soft_error = 'failed to verify OCSP response; subject: '.
  		join("; ",@{$todo->{subj}}) if ! @soft_error;
  	}
  	# configuration problem or we don't know the signer
  	$self->{cache}->put($_,{
  	    soft_error => "@soft_error",
  	    expire => time()+120,
  	}) for (@{$todo->{ids}});
  
      # extract results from response
      } elsif ( my @result =
  	Net::SSLeay::OCSP_response_results($resp,@{$todo->{ids}})) {
  	my (@found,@miss);
  	for my $rv (@result) {
  	    if ($rv->[2]) {
  		push @found,$rv->[0];
  		if (!$rv->[1]) {
  		    # no error
  		    $self->{cache}->put($rv->[0],$rv->[2]);
  		} elsif ( $rv->[2]{statusType} ==
  		    Net::SSLeay::V_OCSP_CERTSTATUS_GOOD()) {
  		    # soft error, like response after nextUpdate
  		    push @soft_error,$rv->[1]."; subject: ".
  			join("; ",@{$todo->{subj}});
  		    $self->{cache}->put($rv->[0],{
  			%{$rv->[2]},
  			soft_error => "@soft_error",
  			expire => time()+120,
  		    });
  		} else {
  		    # hard error
  		    $self->{cache}->put($rv->[0],$rv->[2]);
  		    push @hard_error, $rv->[1]."; subject: ".
  			join("; ",@{$todo->{subj}});
  		}
  	    } else {
  		push @miss,$rv->[0];
  	    }
  	}
  	if (@miss && @found) {
  	    # we sent multiple responses, but server answered only to one
  	    # try again
  	    $self->{todo}{$uri} = $todo;
  	    $todo->{ids} = \@miss;
  	    $todo->{req} = Net::SSLeay::i2d_OCSP_REQUEST(
  		Net::SSLeay::OCSP_ids2req(@miss));
  	    $DEBUG>=2 && DEBUG("$uri just answered ".@found." of ".(@found+@miss)." requests");
  	}
      } else {
  	@soft_error = "no data in response; subject: ".
  	    join("; ",@{$todo->{subj}});
  	# probably configuration problem
  	$self->{cache}->put($_,{
  	    soft_error => "@soft_error",
  	    expire => time()+120,
  	}) for (@{$todo->{ids}});
      }
  
      Net::SSLeay::OCSP_REQUEST_free($req) if $req;
      if ($self->{failhard}) {
  	push @hard_error,@soft_error;
  	@soft_error = ();
      }
      if (@soft_error) {
  	$self->{soft_error} .= "; " if $self->{soft_error};
  	$self->{soft_error} .= "$uri: ".join('; ',@soft_error);
      }
      if (@hard_error) {
  	$self->{hard_error} = "$uri: ".join('; ',@hard_error);
  	%{$self->{todo}} = ();
      } elsif ( ! %{$self->{todo}} ) {
  	$self->{hard_error} = ''
      }
      return $self->{hard_error};
  }
  
  # make all necessary requests to get OCSP responses blocking
  sub resolve_blocking {
      my ($self,%args) = @_;
      while ( my %todo = $self->requests ) {
  	eval { require HTTP::Tiny } or die "need HTTP::Tiny installed";
  	# OCSP responses have their own signature, so we don't need SSL verification
  	my $ua = HTTP::Tiny->new(verify_SSL => 0,%args);
  	while (my ($uri,$reqdata) = each %todo) {
  	    $DEBUG && DEBUG("sending OCSP request to $uri");
  	    my $resp = $ua->request('POST',$uri, {
  		headers => { 'Content-type' => 'application/ocsp-request' },
  		content => $reqdata
  	    });
  	    $DEBUG && DEBUG("got  OCSP response from $uri code=$resp->{status}");
  	    defined ($self->add_response($uri,
  		$resp->{success} && $resp->{content}))
  		&& last;
  	}
      }
      $DEBUG>=2 && DEBUG("no more open OCSP requests");
      return $self->{hard_error};
  }
  
  1;
  
  __END__
IO_SOCKET_SSL

$fatpacked{"IO/Socket/SSL/Intercept.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_SSL_INTERCEPT';
  
  package IO::Socket::SSL::Intercept;
  use strict;
  use warnings;
  use Carp 'croak';
  use IO::Socket::SSL::Utils;
  use Net::SSLeay;
  
  our $VERSION = '2.056';
  
  
  sub new {
      my ($class,%args) = @_;
  
      my $cacert = delete $args{proxy_cert};
      if ( ! $cacert ) {
  	if ( my $f = delete $args{proxy_cert_file} ) {
  	    $cacert = PEM_file2cert($f);
  	} else {
  	    croak "no proxy_cert or proxy_cert_file given";
  	}
      }
  
      my $cakey  = delete $args{proxy_key};
      if ( ! $cakey ) {
  	if ( my $f = delete $args{proxy_key_file} ) {
  	    $cakey = PEM_file2key($f);
  	} else {
  	    croak "no proxy_cert or proxy_cert_file given";
  	}
      }
  
      my $certkey = delete $args{cert_key};
      if ( ! $certkey ) {
  	if ( my $f = delete $args{cert_key_file} ) {
  	    $certkey = PEM_file2key($f);
  	}
      }
  
      my $cache = delete $args{cache} || {};
      if (ref($cache) eq 'CODE') {
  	# check cache type
  	my $type = $cache->('type');
  	if (!$type) {
  	    # old cache interface - change into new interface
  	    # get: $cache->(fp)
  	    # set: $cache->(fp,cert,key)
  	    my $oc = $cache;
  	    $cache = sub {
  		my ($fp,$create_cb) = @_;
  		my @ck = $oc->($fp);
  		$oc->($fp, @ck = &$create_cb) if !@ck;
  		return @ck;
  	    };
  	} elsif ($type == 1) {
  	    # current interface:
  	    # get/set: $cache->(fp,cb_create)
  	} else {
  	    die "invalid type of cache: $type";
  	}
      }
  
      my $self = bless {
  	cacert => $cacert,
  	cakey => $cakey,
  	certkey => $certkey,
  	cache => $cache,
  	serial => delete $args{serial},
      };
      return $self;
  }
  
  sub DESTROY {
      # call various ssl _free routines
      my $self = shift or return;
      for ( \$self->{cacert}, 
  	map { \$_->{cert} } ref($self->{cache}) ne 'CODE' ? values %{$self->{cache}} :()) {
  	$$_ or next;
  	CERT_free($$_);
  	$$_ = undef;
      }
      for ( \$self->{cakey}, \$self->{pubkey} ) {
  	$$_ or next;
  	KEY_free($$_);
  	$$_ = undef;
      }
  }
  
  sub clone_cert {
      my ($self,$old_cert,$clone_key) = @_;
  
      my $hash = CERT_asHash($old_cert);
      my $create_cb = sub {
  	# if not in cache create new certificate based on original
  	# copy most but not all extensions
  	if (my $ext = $hash->{ext}) {
  	    @$ext = grep {
  		defined($_->{sn}) && $_->{sn} !~m{^(?:
  		    authorityInfoAccess    |
  		    subjectKeyIdentifier   |
  		    authorityKeyIdentifier |
  		    certificatePolicies    |
  		    crlDistributionPoints
  		)$}x
  	    } @$ext;
  	}
  	my ($clone,$key) = CERT_create(
  	    %$hash,
  	    issuer_cert => $self->{cacert},
  	    issuer_key => $self->{cakey},
  	    key => $self->{certkey},
  	    serial =>
  		! defined($self->{serial}) ? (unpack('L',$hash->{x509_digest_sha256}))[0] :
  		ref($self->{serial}) eq 'CODE' ? $self->{serial}($old_cert,$hash) :
  		++$self->{serial},
  	);
  	return ($clone,$key);
      };
  
      $clone_key ||= substr(unpack("H*", $hash->{x509_digest_sha256}),0,32);
      my $c = $self->{cache};
      return $c->($clone_key,$create_cb) if ref($c) eq 'CODE';
  
      my $e = $c->{$clone_key} ||= do {
  	my ($cert,$key) = &$create_cb;
  	{ cert => $cert, key => $key };
      };
      $e->{atime} = time();
      return ($e->{cert},$e->{key});
  }
  
  
  sub STORABLE_freeze { my $self = shift; $self->serialize() }
  sub STORABLE_thaw   { my ($class,undef,$data) = @_; $class->unserialize($data) }
  
  sub serialize {
      my $self = shift;
      my $data = pack("N",2); # version
      $data .= pack("N/a", PEM_cert2string($self->{cacert}));
      $data .= pack("N/a", PEM_key2string($self->{cakey}));
      if ( $self->{certkey} ) {
  	$data .= pack("N/a", PEM_key2string($self->{certkey}));
      } else {
  	$data .= pack("N/a", '');
      }
      $data .= pack("N",$self->{serial});
      if ( ref($self->{cache}) eq 'HASH' ) {
  	while ( my($k,$v) = each %{ $self->{cache}} ) {
  	    $data .= pack("N/aN/aN/aN", $k,
  		PEM_cert2string($k->{cert}),
  		$k->{key} ? PEM_key2string($k->{key}) : '',
  		$k->{atime});
  	}
      }
      return $data;
  }
  
  sub unserialize {
      my ($class,$data) = @_;
      unpack("N",substr($data,0,4,'')) == 2 or 
  	croak("serialized with wrong version");
      ( my $cacert,my $cakey,my $certkey,my $serial,$data) 
  	= unpack("N/aN/aN/aNa*",$data);
      my $self = bless {
  	serial => $serial,
  	cacert => PEM_string2cert($cacert),
  	cakey => PEM_string2key($cakey),
  	$certkey ? ( certkey => PEM_string2key($certkey)):(),
      }, ref($class)||$class;
  
      $self->{cache} = {} if $data ne '';
      while ( $data ne '' ) {
  	(my $key,my $cert,my $certkey, my $atime,$data) = unpack("N/aN/aNa*",$data);
  	$self->{cache}{$key} = { 
  	    cert => PEM_string2cert($cert), 
  	    $key ? ( key => PEM_string2key($certkey)):(),
  	    atime => $atime 
  	};
      }
      return $self;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Socket::SSL::Intercept -- SSL interception (man in the middle)
  
  =head1 SYNOPSIS
  
      use IO::Socket::SSL::Intercept;
      # create interceptor with proxy certificates
      my $mitm = IO::Socket::SSL::Intercept->new(
  	proxy_cert_file => 'proxy_cert.pem',
  	proxy_key_file  => 'proxy_key.pem',
  	...
      );
      my $listen = IO::Socket::INET->new( LocalAddr => .., Listen => .. );
      while (1) {
  	# TCP accept new client
  	my $client = $listen->accept or next;
  	# SSL connect to server
  	my $server = IO::Socket::SSL->new(
  	    PeerAddr => ..,
  	    SSL_verify_mode => ...,
  	    ...
  	) or die "ssl connect failed: $!,$SSL_ERROR";
  	# clone server certificate
  	my ($cert,$key) = $mitm->clone_cert( $server->peer_certificate );
  	# and upgrade client side to SSL with cloned certificate
  	IO::Socket::SSL->start_SSL($client,
  	    SSL_server => 1,
  	    SSL_cert => $cert,
  	    SSL_key => $key
  	) or die "upgrade failed: $SSL_ERROR";
  	# now transfer data between $client and $server and analyze
  	# the unencrypted data
  	...
      }
  
  
  =head1 DESCRIPTION
  
  This module provides functionality to clone certificates and sign them with a
  proxy certificate, thus making it easy to intercept SSL connections (man in the
  middle). It also manages a cache of the generated certificates.
  
  =head1 How Intercepting SSL Works
  
  Intercepting SSL connections is useful for analyzing encrypted traffic for
  security reasons or for testing. It does not break the end-to-end security of
  SSL, e.g. a properly written client will notice the interception unless you
  explicitly configure the client to trust your interceptor.
  Intercepting SSL works the following way:
  
  =over 4
  
  =item *
  
  Create a new CA certificate, which will be used to sign the cloned certificates.
  This proxy CA certificate should be trusted by the client, or (a properly
  written client) will throw error messages or deny the connections because it
  detected a man in the middle attack.
  Due to the way the interception works there no support for client side
  certificates is possible.
  
  Using openssl such a proxy CA certificate and private key can be created with:
  
    openssl genrsa -out proxy_key.pem 1024
    openssl req -new -x509 -extensions v3_ca -key proxy_key.pem -out proxy_cert.pem
    # export as PKCS12 for import into browser
    openssl pkcs12 -export -in proxy_cert.pem -inkey proxy_key.pem -out proxy_cert.p12
  
  =item * 
  
  Configure client to connect to use intercepting proxy or somehow redirect
  connections from client to the proxy (e.g. packet filter redirects, ARP or DNS
  spoofing etc).
  
  =item *
  
  Accept the TCP connection from the client, e.g. don't do any SSL handshakes with
  the client yet.
  
  =item *
  
  Establish the SSL connection to the server and verify the servers certificate as
  usually. Then create a new certificate based on the original servers
  certificate, but signed by your proxy CA.
  This is the step where IO::Socket::SSL::Intercept helps.
  
  =item *
  
  Upgrade the TCP connection to the client to SSL using the cloned certificate
  from the server. If the client trusts your proxy CA it will accept the upgrade
  to SSL.
  
  =item *
  
  Transfer data between client and server. While the connections to client and
  server are both encrypted with SSL you will read/write the unencrypted data in
  your proxy application.
  
  =back
  
  =head1 METHODS 
  
  IO::Socket::SSL::Intercept helps creating the cloned certificate with the
  following methods:
  
  =over 4
  
  =item B<< $mitm = IO::Socket::SSL::Intercept->new(%args) >>
  
  This creates a new interceptor object. C<%args> should be
  
  =over 8
  
  =item proxy_cert X509 | proxy_cert_file filename
  
  This is the proxy certificate.
  It can be either given by an X509 object from L<Net::SSLeay>s internal
  representation, or using a file in PEM format.
  
  =item proxy_key EVP_PKEY | proxy_key_file filename
  
  This is the key for the proxy certificate.
  It can be either given by an EVP_PKEY object from L<Net::SSLeay>s internal
  representation, or using a file in PEM format.
  The key should not have a passphrase.
  
  =item pubkey EVP_PKEY | pubkey_file filename
  
  This optional argument specifies the public key used for the cloned certificate.
  It can be either given by an EVP_PKEY object from L<Net::SSLeay>s internal
  representation, or using a file in PEM format.
  If not given it will create a new public key on each call of C<new>.
  
  =item serial INTEGER|CODE
  
  This optional argument gives the starting point for the serial numbers of the
  newly created certificates. If not set the serial number will be created based
  on the digest of the original certificate. If the value is code it will be
  called with C<< serial(original_cert,CERT_asHash(original_cert)) >> and should
  return the new serial number.
  
  =item cache HASH | SUBROUTINE
  
  This optional argument gives a way to cache created certificates, so that they
  don't get recreated on future accesses to the same host.
  If the argument ist not given an internal HASH ist used.
  
  If the argument is a hash it will store for each generated certificate a hash
  reference with C<cert> and C<atime> in the hash, where C<atime> is the time of
  last access (to expire unused entries) and C<cert> is the certificate. Please
  note, that the certificate is in L<Net::SSLeay>s internal X509 format and can
  thus not be simply dumped and restored.
  The key for the hash is an C<ident> either given to C<clone_cert> or generated
  from the original certificate.
  
  If the argument is a subroutine it will be called as C<< $cache->(ident,sub) >>.
  This call should return either an existing (cached) C<< (cert,key) >> or
  call C<sub> without arguments to create a new C<< (cert,key) >>, store it
  and return it.
  If called with C<< $cache->('type') >> the function should just return 1 to
  signal that it supports the current type of cache. If it reutrns nothing
  instead the older cache interface is assumed for compatibility reasons.
  
  =back
  
  =item B<< ($clone_cert,$key) = $mitm->clone_cert($original_cert,[ $ident ]) >>
  
  This clones the given certificate.
  An ident as the key into the cache can be given (like C<host:port>), if not it
  will be created from the properties of the original certificate.
  It returns the cloned certificate and its key (which is the same for alle
  created certificates).
  
  =item B<< $string = $mitm->serialize >>
  
  This creates a serialized version of the object (e.g. a string) which can then
  be used to persistantly store created certificates over restarts of the
  application. The cache will only be serialized if it is a HASH.
  To work together with L<Storable> the C<STORABLE_freeze> function is defined to
  call C<serialize>.
  
  =item B<< $mitm = IO::Socket::SSL::Intercept->unserialize($string) >>
  
  This restores an Intercept object from a serialized string.
  To work together with L<Storable> the C<STORABLE_thaw> function is defined to
  call C<unserialize>.
  
  =back
  
  =head1 AUTHOR
  
  Steffen Ullrich
IO_SOCKET_SSL_INTERCEPT

$fatpacked{"IO/Socket/SSL/PublicSuffix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_SSL_PUBLICSUFFIX';
  
  use strict;
  use warnings;
  package IO::Socket::SSL::PublicSuffix;
  use Carp;
  
  # for updates
  use constant URL => 'http://publicsuffix.org/list/effective_tld_names.dat';
  
  =head1 NAME
  
  IO::Socket::SSL::PublicSuffix - provide access to Mozilla's list of effective TLD names
  
  =head1 SYNOPSIS
  
      # use builtin default
      use IO::Socket::SSL::PublicSuffix;
      $ps = IO::Socket::SSL::PublicSuffix->default;
  
      # load from string
      $ps = IO::Socket::SSL::PublicSuffix->from_string("*.uk\n*");
  
      # load from file or file handle
      $ps = IO::Socket::SSL::PublicSuffix->from_file($filename);
      $ps = IO::Socket::SSL::PublicSuffix->from_file(\*STDIN);
  
  
      # --- string in -> string out
      # $rest -> whatever.host
      # $tld  -> co.uk
      my ($rest,$tld) = $ps->public_suffix('whatever.host.co.uk');
      my $tld = $ps->public_suffix('whatever.host.co.uk');
  
      # $root_domain -> host.co.uk
      my $root_domain = $ps->public_suffix('whatever.host.co.uk', 1);
  
      # --- array in -> array out
      # $rest -> [qw(whatever host)]
      # $tld  -> [qw(co uk)]
      my ($rest,$tld) = $ps->public_suffix([qw(whatever host co uk)]);
  
   ----
  
      # To update this file with the current list:
      perl -MIO::Socket::SSL::PublicSuffix -e 'IO::Socket::SSL::PublicSuffix::update_self_from_url()'
  
  
  
  =head1 DESCRIPTION
  
  This module uses the list of effective top level domain names from the mozilla
  project to determine the public top level domain for a given hostname.
  
  =head2 Method
  
  =over 4
  
  =item class->default(%args)
  
  Returns object with builtin default.
  C<min_suffix> can be given in C<%args> to specify the minimal suffix, default
  is 1.
  
  =item class->from_string(string,%args)
  
  Returns object with configuration from string.
  See method C<default> for C<%args>.
  
  =item class->from_file( file name| file handle, %args )
  
  Returns object with configuration from file or file handle.
  See method C<default> for C<%args>.
  
  =item $self->public_suffix( $host|\@host, [ $add ] )
  
  In array context the function returns the non-tld part and the tld part of the
  given hostname, in scalar context only the tld part.
  It adds C<$add> parts of the non-tld part to the tld, e.g. with C<$add=1> it
  will return the root domain.
  
  If there were no explicit matches against the public suffix configuration it
  will fall back to a suffix of length 1.
  
  The function accepts a string or an array-ref (e.g. host split by C<.>). In the
  first case it will return string(s), in the latter case array-ref(s).
  
  International hostnames or labels can be in ASCII (IDNA form starting with
  C<xn-->) or unicode. In the latter case an IDNA handling library like
  L<Net::IDN:::Encode>, L<Net::LibIDN> or recent versions of L<URI> need to be
  installed.
  
  =item ($self|class)->can_idn
  
  Returns true if IDN support is available.
  
  =back
  
  =head1 FILES
  
  http://publicsuffix.org/list/effective_tld_names.dat
  
  =head1 SEE ALSO
  
  Domain::PublicSuffix, Mozilla::PublicSuffix
  
  =head1 BUGS
  
   Q: Why yet another module, we already have L<Domain::PublicSuffix> and
      L<Mozilla::PublicSuffix>.
   A: Because the public suffix data change more often than these modules do,
      IO::Socket::SSL needs this list and it is more easy this way to keep it
      up-to-date.
  
  
  =head1 AUTHOR
  
  Steffen Ullrich
  
  =cut
  
  
  BEGIN {
      if ( eval {
  	require URI::_idna;
  	defined &URI::_idna::encode && defined &URI::_idna::decode
      }) {
  	*idn_to_ascii   = \&URI::_idna::encode;
  	*idn_to_unicode = \&URI::_idna::decode;
  	*can_idn = sub { 1 };
      } elsif ( eval { require Net::IDN::Encode } ) {
  	*idn_to_ascii   = \&Net::IDN::Encode::domain_to_ascii;
  	*idn_to_unicode = \&Net::IDN::Encode::domain_to_unicode;
  	*can_idn = sub { 1 };
      } elsif ( eval { require Net::LibIDN; require Encode } ) {
  	# Net::LibIDN does not use utf-8 flag and expects raw data
  	*idn_to_ascii   = sub { 
  	    Net::LibIDN::idn_to_ascii(Encode::encode('utf-8',$_[0]),'utf-8');
  	},
  	*idn_to_unicode = sub { 
  	    Encode::decode('utf-8',Net::LibIDN::idn_to_unicode($_[0],'utf-8'));
  	},
  	*can_idn = sub { 1 };
      } else {
  	*idn_to_ascii   = sub { croak "idn_to_ascii(@_) - no IDNA library installed" };
  	*idn_to_unicode = sub { croak "idn_to_unicode(@_) - no IDNA library installed" };
  	*can_idn = sub { 0 };
      }
  }
  
  {
      my %default;
      sub default {
  	my (undef,%args) = @_;
  	my $min_suffix = delete $args{min_suffix};
  	$min_suffix = 1 if ! defined $min_suffix;
  	%args and die "unknown args: ".join(" ",sort keys %args);
  	return $default{$min_suffix} ||= shift->from_string(_default_data(),
  	    min_suffix => $min_suffix);
      }
  }
  
  sub from_string {
      my $class = shift;
      my $data  = shift;
      open( my $fh,'<', \$data );
      return $class->from_file($fh,@_);
  }
  
  sub from_file {
      my ($class,$file,%args) = @_;
      my $min_suffix = delete $args{min_suffix};
      $min_suffix = 1 if ! defined $min_suffix;
      %args and die "unknown args: ".join(" ",sort keys %args);
  
      my $fh;
      if ( ref($file)) {
  	$fh = $file
      } elsif ( ! open($fh,'<',$file)) {
  	die "failed to open $file: $!";
      }
      my %tree;
      local $/ = "\n";
      while ( my $line = <$fh>) {
  	$line =~s{//.*}{};
  	$line =~s{\s+$}{};
  	$line eq '' and next;
  	my $p = \%tree;
  	$line = idn_to_ascii($line) if $line !~m{\A[\x00-\x7f]*\Z};
  	my $not = $line =~s{^!}{};
  	my @path = split(m{\.},$line);
  	for(reverse @path) {
  	    $p = $p->{$_} ||= {}
  	}
  	$p->{'\0'} = $not ? -1:1;
      }
      return bless { 
  	tree => \%tree, 
  	min_suffix => $min_suffix 
      },$class;
  }
  
  
  sub public_suffix {
      my ($self,$name,$add) = @_;
      my $want; # [a]rray, [s]tring, [u]nicode-string
      if ( ref($name)) {
  	$want = 'a';
  	$name = [ @$name ]; # don't change input
      } else {
  	return if ! defined $name;
  	if ( $name !~m{\A[\x00-\x7f]*\Z} ) {
  	    $name = idn_to_ascii($name);
  	    $want = 'u';
  	} else {
  	    $want = 's';
  	}
  	$name = lc($name);
  	$name =~s{\.$}{};
  	$name = [ $name =~m{([^.]+)}g ];
      }
      @$name or return;
      $_ = lc($_) for(@$name);
  
      my (%wild,%host,%xcept,@stack,$choices);
      my $p = $self->{tree};
      for( my $i=0; $i<@$name; $i++ ) {
  	$choices = [];
  	if ( my $px = $p->{ $name->[$#$name-$i] } ) {
  	    # name match, continue with next path element
  	    push @$choices,$px;
  	    if ( my $end = $px->{'\0'} ) {
  		( $end>0 ? \%host : \%xcept )->{$i+1} = $end;
  	    }
  	}
  	if ( my $px = $p->{'*'} ) {
  	    # wildcard match, continue with next path element
  	    push @$choices,$px;
  	    if ( my $end = $px->{'\0'} ) {
  		( $end>0 ? \%wild : \%xcept )->{$i+1} = $end;
  	    }
  	}
  
  
  	next_choice:
  	if ( @$choices ) {
  	    $p = shift(@$choices);
  	    push @stack, [ $choices, $i ] if @$choices;
  	    next; # go deeper
  	}
  
  	# backtrack
  	@stack or last;
  	($choices,$i) = @{ pop(@stack) };
  	goto next_choice;
      }
  
      #warn Dumper([\%wild,\%host,\%xcept]); use Data::Dumper;
  
  
      # remove all exceptions from wildcards
      delete @wild{ keys %xcept } if %xcept;
      # get longest match
      my ($len) = sort { $b <=> $a } (
  	keys(%wild), keys(%host), map { $_-1 } keys(%xcept));
      # if we have no matches use a minimum of min_suffix
      $len = $self->{min_suffix} if ! defined $len;
      $len += $add if $add;
      my $suffix;
      if ( $len < @$name ) {
  	$suffix = [ splice( @$name, -$len, $len ) ];
      } elsif ( $len > 0 ) {
  	$suffix = $name;
  	$name = []
      } else {
  	$suffix = []
      }
  
      if ( $want ne 'a' ) {
  	$suffix = join('.',@$suffix);
  	$name = join('.',@$name);
  	if ( $want eq 'u' ) {
  	    $suffix = idn_to_unicode($suffix);
  	    $name   = idn_to_unicode($name);
  	}
      }
  
      return wantarray ? ($name,$suffix):$suffix;
  }
  
  
  {
      my $data;
      sub _default_data {
  	if ( ! defined $data ) {
  	    $data = _builtin_data();
  	    $data =~s{^// ===END ICANN DOMAINS.*}{}ms
  		or die "cannot find END ICANN DOMAINS";
  	}
  	return $data;
      }
  }
  
  sub update_self_from_url {
      my $url = shift || URL();
      my $dst = __FILE__;
      -w $dst or die "cannot write $dst";
      open( my $fh,'<',$dst ) or die "open $dst: $!";
      my $code = '';
      local $/ = "\n";
      while (<$fh>) {
  	$code .= $_;
  	m{<<\'END_BUILTIN_DATA\'} and last;
      }
      my $tail;
      while (<$fh>) {
  	m{\AEND_BUILTIN_DATA\r?\n} or next;
  	$tail = $_;
  	last;
      }
      $tail .= do { local $/; <$fh> };
      close($fh);
  
      require LWP::UserAgent;
      my $resp = LWP::UserAgent->new->get($url)
  	or die "no response from $url";
      die "no success url=$url code=".$resp->code." ".$resp->message 
  	if ! $resp->is_success;
      my $content = $resp->decoded_content;
      while ( $content =~m{(.*\n)}g ) {
  	my $line = $1;
  	if ( $line =~m{\S} && $line !~m{\A\s*//} ) {
  	    $line =~s{//.*}{};
  	    $line =~s{\s+$}{};
  	    $line eq '' and next;
  	    if ( $line !~m{\A[\x00-\x7f]+\Z} ) {
  		$line = idn_to_ascii($line);
  	    }
  	    $code .= "$line\n";
  	} else {
  	    $code .= "$line";
  	}
      }
  
      open( $fh,'>:utf8',$dst ) or die "open $dst: $!";
      print $fh $code.$tail;
  }
  
  sub _builtin_data { return <<'END_BUILTIN_DATA' }
  // This Source Code Form is subject to the terms of the Mozilla Public
  // License, v. 2.0. If a copy of the MPL was not distributed with this
  // file, You can obtain one at https://mozilla.org/MPL/2.0/.
  
  // Please pull this list from, and only from https://publicsuffix.org/list/public_suffix_list.dat,
  // rather than any other VCS sites. Pulling from any other URL is not guaranteed to be supported.
  
  // Instructions on pulling and using this list can be found at https://publicsuffix.org/list/.
  
  // ===BEGIN ICANN DOMAINS===
  
  // ac : https://en.wikipedia.org/wiki/.ac
  ac
  com.ac
  edu.ac
  gov.ac
  net.ac
  mil.ac
  org.ac
  
  // ad : https://en.wikipedia.org/wiki/.ad
  ad
  nom.ad
  
  // ae : https://en.wikipedia.org/wiki/.ae
  // see also: "Domain Name Eligibility Policy" at http://www.aeda.ae/eng/aepolicy.php
  ae
  co.ae
  net.ae
  org.ae
  sch.ae
  ac.ae
  gov.ae
  mil.ae
  
  // aero : see https://www.information.aero/index.php?id=66
  aero
  accident-investigation.aero
  accident-prevention.aero
  aerobatic.aero
  aeroclub.aero
  aerodrome.aero
  agents.aero
  aircraft.aero
  airline.aero
  airport.aero
  air-surveillance.aero
  airtraffic.aero
  air-traffic-control.aero
  ambulance.aero
  amusement.aero
  association.aero
  author.aero
  ballooning.aero
  broker.aero
  caa.aero
  cargo.aero
  catering.aero
  certification.aero
  championship.aero
  charter.aero
  civilaviation.aero
  club.aero
  conference.aero
  consultant.aero
  consulting.aero
  control.aero
  council.aero
  crew.aero
  design.aero
  dgca.aero
  educator.aero
  emergency.aero
  engine.aero
  engineer.aero
  entertainment.aero
  equipment.aero
  exchange.aero
  express.aero
  federation.aero
  flight.aero
  freight.aero
  fuel.aero
  gliding.aero
  government.aero
  groundhandling.aero
  group.aero
  hanggliding.aero
  homebuilt.aero
  insurance.aero
  journal.aero
  journalist.aero
  leasing.aero
  logistics.aero
  magazine.aero
  maintenance.aero
  media.aero
  microlight.aero
  modelling.aero
  navigation.aero
  parachuting.aero
  paragliding.aero
  passenger-association.aero
  pilot.aero
  press.aero
  production.aero
  recreation.aero
  repbody.aero
  res.aero
  research.aero
  rotorcraft.aero
  safety.aero
  scientist.aero
  services.aero
  show.aero
  skydiving.aero
  software.aero
  student.aero
  trader.aero
  trading.aero
  trainer.aero
  union.aero
  workinggroup.aero
  works.aero
  
  // af : http://www.nic.af/help.jsp
  af
  gov.af
  com.af
  org.af
  net.af
  edu.af
  
  // ag : http://www.nic.ag/prices.htm
  ag
  com.ag
  org.ag
  net.ag
  co.ag
  nom.ag
  
  // ai : http://nic.com.ai/
  ai
  off.ai
  com.ai
  net.ai
  org.ai
  
  // al : http://www.ert.gov.al/ert_alb/faq_det.html?Id=31
  al
  com.al
  edu.al
  gov.al
  mil.al
  net.al
  org.al
  
  // am : https://en.wikipedia.org/wiki/.am
  am
  
  // ao : https://en.wikipedia.org/wiki/.ao
  // http://www.dns.ao/REGISTR.DOC
  ao
  ed.ao
  gv.ao
  og.ao
  co.ao
  pb.ao
  it.ao
  
  // aq : https://en.wikipedia.org/wiki/.aq
  aq
  
  // ar : https://nic.ar/nic-argentina/normativa-vigente
  ar
  com.ar
  edu.ar
  gob.ar
  gov.ar
  int.ar
  mil.ar
  musica.ar
  net.ar
  org.ar
  tur.ar
  
  // arpa : https://en.wikipedia.org/wiki/.arpa
  // Confirmed by registry <iana-questions@icann.org> 2008-06-18
  arpa
  e164.arpa
  in-addr.arpa
  ip6.arpa
  iris.arpa
  uri.arpa
  urn.arpa
  
  // as : https://en.wikipedia.org/wiki/.as
  as
  gov.as
  
  // asia : https://en.wikipedia.org/wiki/.asia
  asia
  
  // at : https://en.wikipedia.org/wiki/.at
  // Confirmed by registry <it@nic.at> 2008-06-17
  at
  ac.at
  co.at
  gv.at
  or.at
  
  // au : https://en.wikipedia.org/wiki/.au
  // http://www.auda.org.au/
  au
  // 2LDs
  com.au
  net.au
  org.au
  edu.au
  gov.au
  asn.au
  id.au
  // Historic 2LDs (closed to new registration, but sites still exist)
  info.au
  conf.au
  oz.au
  // CGDNs - http://www.cgdn.org.au/
  act.au
  nsw.au
  nt.au
  qld.au
  sa.au
  tas.au
  vic.au
  wa.au
  // 3LDs
  act.edu.au
  nsw.edu.au
  nt.edu.au
  qld.edu.au
  sa.edu.au
  tas.edu.au
  vic.edu.au
  wa.edu.au
  // act.gov.au  Bug 984824 - Removed at request of Greg Tankard
  // nsw.gov.au  Bug 547985 - Removed at request of <Shae.Donelan@services.nsw.gov.au>
  // nt.gov.au  Bug 940478 - Removed at request of Greg Connors <Greg.Connors@nt.gov.au>
  qld.gov.au
  sa.gov.au
  tas.gov.au
  vic.gov.au
  wa.gov.au
  
  // aw : https://en.wikipedia.org/wiki/.aw
  aw
  com.aw
  
  // ax : https://en.wikipedia.org/wiki/.ax
  ax
  
  // az : https://en.wikipedia.org/wiki/.az
  az
  com.az
  net.az
  int.az
  gov.az
  org.az
  edu.az
  info.az
  pp.az
  mil.az
  name.az
  pro.az
  biz.az
  
  // ba : http://nic.ba/users_data/files/pravilnik_o_registraciji.pdf
  ba
  com.ba
  edu.ba
  gov.ba
  mil.ba
  net.ba
  org.ba
  
  // bb : https://en.wikipedia.org/wiki/.bb
  bb
  biz.bb
  co.bb
  com.bb
  edu.bb
  gov.bb
  info.bb
  net.bb
  org.bb
  store.bb
  tv.bb
  
  // bd : https://en.wikipedia.org/wiki/.bd
  *.bd
  
  // be : https://en.wikipedia.org/wiki/.be
  // Confirmed by registry <tech@dns.be> 2008-06-08
  be
  ac.be
  
  // bf : https://en.wikipedia.org/wiki/.bf
  bf
  gov.bf
  
  // bg : https://en.wikipedia.org/wiki/.bg
  // https://www.register.bg/user/static/rules/en/index.html
  bg
  a.bg
  b.bg
  c.bg
  d.bg
  e.bg
  f.bg
  g.bg
  h.bg
  i.bg
  j.bg
  k.bg
  l.bg
  m.bg
  n.bg
  o.bg
  p.bg
  q.bg
  r.bg
  s.bg
  t.bg
  u.bg
  v.bg
  w.bg
  x.bg
  y.bg
  z.bg
  0.bg
  1.bg
  2.bg
  3.bg
  4.bg
  5.bg
  6.bg
  7.bg
  8.bg
  9.bg
  
  // bh : https://en.wikipedia.org/wiki/.bh
  bh
  com.bh
  edu.bh
  net.bh
  org.bh
  gov.bh
  
  // bi : https://en.wikipedia.org/wiki/.bi
  // http://whois.nic.bi/
  bi
  co.bi
  com.bi
  edu.bi
  or.bi
  org.bi
  
  // biz : https://en.wikipedia.org/wiki/.biz
  biz
  
  // bj : https://en.wikipedia.org/wiki/.bj
  bj
  asso.bj
  barreau.bj
  gouv.bj
  
  // bm : http://www.bermudanic.bm/dnr-text.txt
  bm
  com.bm
  edu.bm
  gov.bm
  net.bm
  org.bm
  
  // bn : http://www.bnnic.bn/faqs
  bn
  com.bn
  edu.bn
  gov.bn
  net.bn
  org.bn
  
  // bo : https://nic.bo/delegacion2015.php#h-1.10
  bo
  com.bo
  edu.bo
  gob.bo
  int.bo
  org.bo
  net.bo
  mil.bo
  tv.bo
  web.bo
  // Social Domains
  academia.bo
  agro.bo
  arte.bo
  blog.bo
  bolivia.bo
  ciencia.bo
  cooperativa.bo
  democracia.bo
  deporte.bo
  ecologia.bo
  economia.bo
  empresa.bo
  indigena.bo
  industria.bo
  info.bo
  medicina.bo
  movimiento.bo
  musica.bo
  natural.bo
  nombre.bo
  noticias.bo
  patria.bo
  politica.bo
  profesional.bo
  plurinacional.bo
  pueblo.bo
  revista.bo
  salud.bo
  tecnologia.bo
  tksat.bo
  transporte.bo
  wiki.bo
  
  // br : http://registro.br/dominio/categoria.html
  // Submitted by registry <fneves@registro.br>
  br
  9guacu.br
  abc.br
  adm.br
  adv.br
  agr.br
  aju.br
  am.br
  anani.br
  aparecida.br
  arq.br
  art.br
  ato.br
  b.br
  barueri.br
  belem.br
  bhz.br
  bio.br
  blog.br
  bmd.br
  boavista.br
  bsb.br
  campinagrande.br
  campinas.br
  caxias.br
  cim.br
  cng.br
  cnt.br
  com.br
  contagem.br
  coop.br
  cri.br
  cuiaba.br
  curitiba.br
  def.br
  ecn.br
  eco.br
  edu.br
  emp.br
  eng.br
  esp.br
  etc.br
  eti.br
  far.br
  feira.br
  flog.br
  floripa.br
  fm.br
  fnd.br
  fortal.br
  fot.br
  foz.br
  fst.br
  g12.br
  ggf.br
  goiania.br
  gov.br
  // gov.br 26 states + df https://en.wikipedia.org/wiki/States_of_Brazil
  ac.gov.br
  al.gov.br
  am.gov.br
  ap.gov.br
  ba.gov.br
  ce.gov.br
  df.gov.br
  es.gov.br
  go.gov.br
  ma.gov.br
  mg.gov.br
  ms.gov.br
  mt.gov.br
  pa.gov.br
  pb.gov.br
  pe.gov.br
  pi.gov.br
  pr.gov.br
  rj.gov.br
  rn.gov.br
  ro.gov.br
  rr.gov.br
  rs.gov.br
  sc.gov.br
  se.gov.br
  sp.gov.br
  to.gov.br
  gru.br
  imb.br
  ind.br
  inf.br
  jab.br
  jampa.br
  jdf.br
  joinville.br
  jor.br
  jus.br
  leg.br
  lel.br
  londrina.br
  macapa.br
  maceio.br
  manaus.br
  maringa.br
  mat.br
  med.br
  mil.br
  morena.br
  mp.br
  mus.br
  natal.br
  net.br
  niteroi.br
  *.nom.br
  not.br
  ntr.br
  odo.br
  ong.br
  org.br
  osasco.br
  palmas.br
  poa.br
  ppg.br
  pro.br
  psc.br
  psi.br
  pvh.br
  qsl.br
  radio.br
  rec.br
  recife.br
  ribeirao.br
  rio.br
  riobranco.br
  riopreto.br
  salvador.br
  sampa.br
  santamaria.br
  santoandre.br
  saobernardo.br
  saogonca.br
  sjc.br
  slg.br
  slz.br
  sorocaba.br
  srv.br
  taxi.br
  teo.br
  the.br
  tmp.br
  trd.br
  tur.br
  tv.br
  udi.br
  vet.br
  vix.br
  vlog.br
  wiki.br
  zlg.br
  
  // bs : http://www.nic.bs/rules.html
  bs
  com.bs
  net.bs
  org.bs
  edu.bs
  gov.bs
  
  // bt : https://en.wikipedia.org/wiki/.bt
  bt
  com.bt
  edu.bt
  gov.bt
  net.bt
  org.bt
  
  // bv : No registrations at this time.
  // Submitted by registry <jarle@uninett.no>
  bv
  
  // bw : https://en.wikipedia.org/wiki/.bw
  // http://www.gobin.info/domainname/bw.doc
  // list of other 2nd level tlds ?
  bw
  co.bw
  org.bw
  
  // by : https://en.wikipedia.org/wiki/.by
  // http://tld.by/rules_2006_en.html
  // list of other 2nd level tlds ?
  by
  gov.by
  mil.by
  // Official information does not indicate that com.by is a reserved
  // second-level domain, but it's being used as one (see www.google.com.by and
  // www.yahoo.com.by, for example), so we list it here for safety's sake.
  com.by
  
  // http://hoster.by/
  of.by
  
  // bz : https://en.wikipedia.org/wiki/.bz
  // http://www.belizenic.bz/
  bz
  com.bz
  net.bz
  org.bz
  edu.bz
  gov.bz
  
  // ca : https://en.wikipedia.org/wiki/.ca
  ca
  // ca geographical names
  ab.ca
  bc.ca
  mb.ca
  nb.ca
  nf.ca
  nl.ca
  ns.ca
  nt.ca
  nu.ca
  on.ca
  pe.ca
  qc.ca
  sk.ca
  yk.ca
  // gc.ca: https://en.wikipedia.org/wiki/.gc.ca
  // see also: http://registry.gc.ca/en/SubdomainFAQ
  gc.ca
  
  // cat : https://en.wikipedia.org/wiki/.cat
  cat
  
  // cc : https://en.wikipedia.org/wiki/.cc
  cc
  
  // cd : https://en.wikipedia.org/wiki/.cd
  // see also: https://www.nic.cd/domain/insertDomain_2.jsp?act=1
  cd
  gov.cd
  
  // cf : https://en.wikipedia.org/wiki/.cf
  cf
  
  // cg : https://en.wikipedia.org/wiki/.cg
  cg
  
  // ch : https://en.wikipedia.org/wiki/.ch
  ch
  
  // ci : https://en.wikipedia.org/wiki/.ci
  // http://www.nic.ci/index.php?page=charte
  ci
  org.ci
  or.ci
  com.ci
  co.ci
  edu.ci
  ed.ci
  ac.ci
  net.ci
  go.ci
  asso.ci
  xn--aroport-bya.ci
  int.ci
  presse.ci
  md.ci
  gouv.ci
  
  // ck : https://en.wikipedia.org/wiki/.ck
  *.ck
  !www.ck
  
  // cl : https://en.wikipedia.org/wiki/.cl
  cl
  gov.cl
  gob.cl
  co.cl
  mil.cl
  
  // cm : https://en.wikipedia.org/wiki/.cm plus bug 981927
  cm
  co.cm
  com.cm
  gov.cm
  net.cm
  
  // cn : https://en.wikipedia.org/wiki/.cn
  // Submitted by registry <tanyaling@cnnic.cn>
  cn
  ac.cn
  com.cn
  edu.cn
  gov.cn
  net.cn
  org.cn
  mil.cn
  xn--55qx5d.cn
  xn--io0a7i.cn
  xn--od0alg.cn
  // cn geographic names
  ah.cn
  bj.cn
  cq.cn
  fj.cn
  gd.cn
  gs.cn
  gz.cn
  gx.cn
  ha.cn
  hb.cn
  he.cn
  hi.cn
  hl.cn
  hn.cn
  jl.cn
  js.cn
  jx.cn
  ln.cn
  nm.cn
  nx.cn
  qh.cn
  sc.cn
  sd.cn
  sh.cn
  sn.cn
  sx.cn
  tj.cn
  xj.cn
  xz.cn
  yn.cn
  zj.cn
  hk.cn
  mo.cn
  tw.cn
  
  // co : https://en.wikipedia.org/wiki/.co
  // Submitted by registry <tecnico@uniandes.edu.co>
  co
  arts.co
  com.co
  edu.co
  firm.co
  gov.co
  info.co
  int.co
  mil.co
  net.co
  nom.co
  org.co
  rec.co
  web.co
  
  // com : https://en.wikipedia.org/wiki/.com
  com
  
  // coop : https://en.wikipedia.org/wiki/.coop
  coop
  
  // cr : http://www.nic.cr/niccr_publico/showRegistroDominiosScreen.do
  cr
  ac.cr
  co.cr
  ed.cr
  fi.cr
  go.cr
  or.cr
  sa.cr
  
  // cu : https://en.wikipedia.org/wiki/.cu
  cu
  com.cu
  edu.cu
  org.cu
  net.cu
  gov.cu
  inf.cu
  
  // cv : https://en.wikipedia.org/wiki/.cv
  cv
  
  // cw : http://www.una.cw/cw_registry/
  // Confirmed by registry <registry@una.net> 2013-03-26
  cw
  com.cw
  edu.cw
  net.cw
  org.cw
  
  // cx : https://en.wikipedia.org/wiki/.cx
  // list of other 2nd level tlds ?
  cx
  gov.cx
  
  // cy : http://www.nic.cy/
  // Submitted by registry Panayiotou Fotia <cydns@ucy.ac.cy>
  cy
  ac.cy
  biz.cy
  com.cy
  ekloges.cy
  gov.cy
  ltd.cy
  name.cy
  net.cy
  org.cy
  parliament.cy
  press.cy
  pro.cy
  tm.cy
  
  // cz : https://en.wikipedia.org/wiki/.cz
  cz
  
  // de : https://en.wikipedia.org/wiki/.de
  // Confirmed by registry <ops@denic.de> (with technical
  // reservations) 2008-07-01
  de
  
  // dj : https://en.wikipedia.org/wiki/.dj
  dj
  
  // dk : https://en.wikipedia.org/wiki/.dk
  // Confirmed by registry <robert@dk-hostmaster.dk> 2008-06-17
  dk
  
  // dm : https://en.wikipedia.org/wiki/.dm
  dm
  com.dm
  net.dm
  org.dm
  edu.dm
  gov.dm
  
  // do : https://en.wikipedia.org/wiki/.do
  do
  art.do
  com.do
  edu.do
  gob.do
  gov.do
  mil.do
  net.do
  org.do
  sld.do
  web.do
  
  // dz : https://en.wikipedia.org/wiki/.dz
  dz
  com.dz
  org.dz
  net.dz
  gov.dz
  edu.dz
  asso.dz
  pol.dz
  art.dz
  
  // ec : http://www.nic.ec/reg/paso1.asp
  // Submitted by registry <vabboud@nic.ec>
  ec
  com.ec
  info.ec
  net.ec
  fin.ec
  k12.ec
  med.ec
  pro.ec
  org.ec
  edu.ec
  gov.ec
  gob.ec
  mil.ec
  
  // edu : https://en.wikipedia.org/wiki/.edu
  edu
  
  // ee : http://www.eenet.ee/EENet/dom_reeglid.html#lisa_B
  ee
  edu.ee
  gov.ee
  riik.ee
  lib.ee
  med.ee
  com.ee
  pri.ee
  aip.ee
  org.ee
  fie.ee
  
  // eg : https://en.wikipedia.org/wiki/.eg
  eg
  com.eg
  edu.eg
  eun.eg
  gov.eg
  mil.eg
  name.eg
  net.eg
  org.eg
  sci.eg
  
  // er : https://en.wikipedia.org/wiki/.er
  *.er
  
  // es : https://www.nic.es/site_ingles/ingles/dominios/index.html
  es
  com.es
  nom.es
  org.es
  gob.es
  edu.es
  
  // et : https://en.wikipedia.org/wiki/.et
  et
  com.et
  gov.et
  org.et
  edu.et
  biz.et
  name.et
  info.et
  net.et
  
  // eu : https://en.wikipedia.org/wiki/.eu
  eu
  
  // fi : https://en.wikipedia.org/wiki/.fi
  fi
  // aland.fi : https://en.wikipedia.org/wiki/.ax
  // This domain is being phased out in favor of .ax. As there are still many
  // domains under aland.fi, we still keep it on the list until aland.fi is
  // completely removed.
  // TODO: Check for updates (expected to be phased out around Q1/2009)
  aland.fi
  
  // fj : https://en.wikipedia.org/wiki/.fj
  *.fj
  
  // fk : https://en.wikipedia.org/wiki/.fk
  *.fk
  
  // fm : https://en.wikipedia.org/wiki/.fm
  fm
  
  // fo : https://en.wikipedia.org/wiki/.fo
  fo
  
  // fr : http://www.afnic.fr/
  // domaines descriptifs : http://www.afnic.fr/obtenir/chartes/nommage-fr/annexe-descriptifs
  fr
  com.fr
  asso.fr
  nom.fr
  prd.fr
  presse.fr
  tm.fr
  // domaines sectoriels : http://www.afnic.fr/obtenir/chartes/nommage-fr/annexe-sectoriels
  aeroport.fr
  assedic.fr
  avocat.fr
  avoues.fr
  cci.fr
  chambagri.fr
  chirurgiens-dentistes.fr
  experts-comptables.fr
  geometre-expert.fr
  gouv.fr
  greta.fr
  huissier-justice.fr
  medecin.fr
  notaires.fr
  pharmacien.fr
  port.fr
  veterinaire.fr
  
  // ga : https://en.wikipedia.org/wiki/.ga
  ga
  
  // gb : This registry is effectively dormant
  // Submitted by registry <Damien.Shaw@ja.net>
  gb
  
  // gd : https://en.wikipedia.org/wiki/.gd
  gd
  
  // ge : http://www.nic.net.ge/policy_en.pdf
  ge
  com.ge
  edu.ge
  gov.ge
  org.ge
  mil.ge
  net.ge
  pvt.ge
  
  // gf : https://en.wikipedia.org/wiki/.gf
  gf
  
  // gg : http://www.channelisles.net/register-domains/
  // Confirmed by registry <nigel@channelisles.net> 2013-11-28
  gg
  co.gg
  net.gg
  org.gg
  
  // gh : https://en.wikipedia.org/wiki/.gh
  // see also: http://www.nic.gh/reg_now.php
  // Although domains directly at second level are not possible at the moment,
  // they have been possible for some time and may come back.
  gh
  com.gh
  edu.gh
  gov.gh
  org.gh
  mil.gh
  
  // gi : http://www.nic.gi/rules.html
  gi
  com.gi
  ltd.gi
  gov.gi
  mod.gi
  edu.gi
  org.gi
  
  // gl : https://en.wikipedia.org/wiki/.gl
  // http://nic.gl
  gl
  co.gl
  com.gl
  edu.gl
  net.gl
  org.gl
  
  // gm : http://www.nic.gm/htmlpages%5Cgm-policy.htm
  gm
  
  // gn : http://psg.com/dns/gn/gn.txt
  // Submitted by registry <randy@psg.com>
  gn
  ac.gn
  com.gn
  edu.gn
  gov.gn
  org.gn
  net.gn
  
  // gov : https://en.wikipedia.org/wiki/.gov
  gov
  
  // gp : http://www.nic.gp/index.php?lang=en
  gp
  com.gp
  net.gp
  mobi.gp
  edu.gp
  org.gp
  asso.gp
  
  // gq : https://en.wikipedia.org/wiki/.gq
  gq
  
  // gr : https://grweb.ics.forth.gr/english/1617-B-2005.html
  // Submitted by registry <segred@ics.forth.gr>
  gr
  com.gr
  edu.gr
  net.gr
  org.gr
  gov.gr
  
  // gs : https://en.wikipedia.org/wiki/.gs
  gs
  
  // gt : http://www.gt/politicas_de_registro.html
  gt
  com.gt
  edu.gt
  gob.gt
  ind.gt
  mil.gt
  net.gt
  org.gt
  
  // gu : http://gadao.gov.gu/register.html
  // University of Guam : https://www.uog.edu
  // Submitted by uognoc@triton.uog.edu
  gu
  com.gu
  edu.gu
  gov.gu
  guam.gu
  info.gu
  net.gu
  org.gu
  web.gu
  
  // gw : https://en.wikipedia.org/wiki/.gw
  gw
  
  // gy : https://en.wikipedia.org/wiki/.gy
  // http://registry.gy/
  gy
  co.gy
  com.gy
  edu.gy
  gov.gy
  net.gy
  org.gy
  
  // hk : https://www.hkirc.hk
  // Submitted by registry <hk.tech@hkirc.hk>
  hk
  com.hk
  edu.hk
  gov.hk
  idv.hk
  net.hk
  org.hk
  xn--55qx5d.hk
  xn--wcvs22d.hk
  xn--lcvr32d.hk
  xn--mxtq1m.hk
  xn--gmqw5a.hk
  xn--ciqpn.hk
  xn--gmq050i.hk
  xn--zf0avx.hk
  xn--io0a7i.hk
  xn--mk0axi.hk
  xn--od0alg.hk
  xn--od0aq3b.hk
  xn--tn0ag.hk
  xn--uc0atv.hk
  xn--uc0ay4a.hk
  
  // hm : https://en.wikipedia.org/wiki/.hm
  hm
  
  // hn : http://www.nic.hn/politicas/ps02,,05.html
  hn
  com.hn
  edu.hn
  org.hn
  net.hn
  mil.hn
  gob.hn
  
  // hr : http://www.dns.hr/documents/pdf/HRTLD-regulations.pdf
  hr
  iz.hr
  from.hr
  name.hr
  com.hr
  
  // ht : http://www.nic.ht/info/charte.cfm
  ht
  com.ht
  shop.ht
  firm.ht
  info.ht
  adult.ht
  net.ht
  pro.ht
  org.ht
  med.ht
  art.ht
  coop.ht
  pol.ht
  asso.ht
  edu.ht
  rel.ht
  gouv.ht
  perso.ht
  
  // hu : http://www.domain.hu/domain/English/sld.html
  // Confirmed by registry <pasztor@iszt.hu> 2008-06-12
  hu
  co.hu
  info.hu
  org.hu
  priv.hu
  sport.hu
  tm.hu
  2000.hu
  agrar.hu
  bolt.hu
  casino.hu
  city.hu
  erotica.hu
  erotika.hu
  film.hu
  forum.hu
  games.hu
  hotel.hu
  ingatlan.hu
  jogasz.hu
  konyvelo.hu
  lakas.hu
  media.hu
  news.hu
  reklam.hu
  sex.hu
  shop.hu
  suli.hu
  szex.hu
  tozsde.hu
  utazas.hu
  video.hu
  
  // id : https://pandi.id/en/domain/registration-requirements/
  id
  ac.id
  biz.id
  co.id
  desa.id
  go.id
  mil.id
  my.id
  net.id
  or.id
  ponpes.id
  sch.id
  web.id
  
  // ie : https://en.wikipedia.org/wiki/.ie
  ie
  gov.ie
  
  // il : http://www.isoc.org.il/domains/
  il
  ac.il
  co.il
  gov.il
  idf.il
  k12.il
  muni.il
  net.il
  org.il
  
  // im : https://www.nic.im/
  // Submitted by registry <info@nic.im>
  im
  ac.im
  co.im
  com.im
  ltd.co.im
  net.im
  org.im
  plc.co.im
  tt.im
  tv.im
  
  // in : https://en.wikipedia.org/wiki/.in
  // see also: https://registry.in/Policies
  // Please note, that nic.in is not an official eTLD, but used by most
  // government institutions.
  in
  co.in
  firm.in
  net.in
  org.in
  gen.in
  ind.in
  nic.in
  ac.in
  edu.in
  res.in
  gov.in
  mil.in
  
  // info : https://en.wikipedia.org/wiki/.info
  info
  
  // int : https://en.wikipedia.org/wiki/.int
  // Confirmed by registry <iana-questions@icann.org> 2008-06-18
  int
  eu.int
  
  // io : http://www.nic.io/rules.html
  // list of other 2nd level tlds ?
  io
  com.io
  
  // iq : http://www.cmc.iq/english/iq/iqregister1.htm
  iq
  gov.iq
  edu.iq
  mil.iq
  com.iq
  org.iq
  net.iq
  
  // ir : http://www.nic.ir/Terms_and_Conditions_ir,_Appendix_1_Domain_Rules
  // Also see http://www.nic.ir/Internationalized_Domain_Names
  // Two <iran>.ir entries added at request of <tech-team@nic.ir>, 2010-04-16
  ir
  ac.ir
  co.ir
  gov.ir
  id.ir
  net.ir
  org.ir
  sch.ir
  // xn--mgba3a4f16a.ir (<iran>.ir, Persian YEH)
  xn--mgba3a4f16a.ir
  // xn--mgba3a4fra.ir (<iran>.ir, Arabic YEH)
  xn--mgba3a4fra.ir
  
  // is : http://www.isnic.is/domain/rules.php
  // Confirmed by registry <marius@isgate.is> 2008-12-06
  is
  net.is
  com.is
  edu.is
  gov.is
  org.is
  int.is
  
  // it : https://en.wikipedia.org/wiki/.it
  it
  gov.it
  edu.it
  // Reserved geo-names (regions and provinces):
  // http://www.nic.it/sites/default/files/docs/Regulation_assignation_v7.1.pdf
  // Regions
  abr.it
  abruzzo.it
  aosta-valley.it
  aostavalley.it
  bas.it
  basilicata.it
  cal.it
  calabria.it
  cam.it
  campania.it
  emilia-romagna.it
  emiliaromagna.it
  emr.it
  friuli-v-giulia.it
  friuli-ve-giulia.it
  friuli-vegiulia.it
  friuli-venezia-giulia.it
  friuli-veneziagiulia.it
  friuli-vgiulia.it
  friuliv-giulia.it
  friulive-giulia.it
  friulivegiulia.it
  friulivenezia-giulia.it
  friuliveneziagiulia.it
  friulivgiulia.it
  fvg.it
  laz.it
  lazio.it
  lig.it
  liguria.it
  lom.it
  lombardia.it
  lombardy.it
  lucania.it
  mar.it
  marche.it
  mol.it
  molise.it
  piedmont.it
  piemonte.it
  pmn.it
  pug.it
  puglia.it
  sar.it
  sardegna.it
  sardinia.it
  sic.it
  sicilia.it
  sicily.it
  taa.it
  tos.it
  toscana.it
  trentin-sud-tirol.it
  xn--trentin-sd-tirol-rzb.it
  trentin-sudtirol.it
  xn--trentin-sdtirol-7vb.it
  trentin-sued-tirol.it
  trentin-suedtirol.it
  trentino-a-adige.it
  trentino-aadige.it
  trentino-alto-adige.it
  trentino-altoadige.it
  trentino-s-tirol.it
  trentino-stirol.it
  trentino-sud-tirol.it
  xn--trentino-sd-tirol-c3b.it
  trentino-sudtirol.it
  xn--trentino-sdtirol-szb.it
  trentino-sued-tirol.it
  trentino-suedtirol.it
  trentino.it
  trentinoa-adige.it
  trentinoaadige.it
  trentinoalto-adige.it
  trentinoaltoadige.it
  trentinos-tirol.it
  trentinostirol.it
  trentinosud-tirol.it
  xn--trentinosd-tirol-rzb.it
  trentinosudtirol.it
  xn--trentinosdtirol-7vb.it
  trentinosued-tirol.it
  trentinosuedtirol.it
  trentinsud-tirol.it
  xn--trentinsd-tirol-6vb.it
  trentinsudtirol.it
  xn--trentinsdtirol-nsb.it
  trentinsued-tirol.it
  trentinsuedtirol.it
  tuscany.it
  umb.it
  umbria.it
  val-d-aosta.it
  val-daosta.it
  vald-aosta.it
  valdaosta.it
  valle-aosta.it
  valle-d-aosta.it
  valle-daosta.it
  valleaosta.it
  valled-aosta.it
  valledaosta.it
  vallee-aoste.it
  xn--valle-aoste-ebb.it
  vallee-d-aoste.it
  xn--valle-d-aoste-ehb.it
  valleeaoste.it
  xn--valleaoste-e7a.it
  valleedaoste.it
  xn--valledaoste-ebb.it
  vao.it
  vda.it
  ven.it
  veneto.it
  // Provinces
  ag.it
  agrigento.it
  al.it
  alessandria.it
  alto-adige.it
  altoadige.it
  an.it
  ancona.it
  andria-barletta-trani.it
  andria-trani-barletta.it
  andriabarlettatrani.it
  andriatranibarletta.it
  ao.it
  aosta.it
  aoste.it
  ap.it
  aq.it
  aquila.it
  ar.it
  arezzo.it
  ascoli-piceno.it
  ascolipiceno.it
  asti.it
  at.it
  av.it
  avellino.it
  ba.it
  balsan-sudtirol.it
  xn--balsan-sdtirol-nsb.it
  balsan-suedtirol.it
  balsan.it
  bari.it
  barletta-trani-andria.it
  barlettatraniandria.it
  belluno.it
  benevento.it
  bergamo.it
  bg.it
  bi.it
  biella.it
  bl.it
  bn.it
  bo.it
  bologna.it
  bolzano-altoadige.it
  bolzano.it
  bozen-sudtirol.it
  xn--bozen-sdtirol-2ob.it
  bozen-suedtirol.it
  bozen.it
  br.it
  brescia.it
  brindisi.it
  bs.it
  bt.it
  bulsan-sudtirol.it
  xn--bulsan-sdtirol-nsb.it
  bulsan-suedtirol.it
  bulsan.it
  bz.it
  ca.it
  cagliari.it
  caltanissetta.it
  campidano-medio.it
  campidanomedio.it
  campobasso.it
  carbonia-iglesias.it
  carboniaiglesias.it
  carrara-massa.it
  carraramassa.it
  caserta.it
  catania.it
  catanzaro.it
  cb.it
  ce.it
  cesena-forli.it
  xn--cesena-forl-mcb.it
  cesenaforli.it
  xn--cesenaforl-i8a.it
  ch.it
  chieti.it
  ci.it
  cl.it
  cn.it
  co.it
  como.it
  cosenza.it
  cr.it
  cremona.it
  crotone.it
  cs.it
  ct.it
  cuneo.it
  cz.it
  dell-ogliastra.it
  dellogliastra.it
  en.it
  enna.it
  fc.it
  fe.it
  fermo.it
  ferrara.it
  fg.it
  fi.it
  firenze.it
  florence.it
  fm.it
  foggia.it
  forli-cesena.it
  xn--forl-cesena-fcb.it
  forlicesena.it
  xn--forlcesena-c8a.it
  fr.it
  frosinone.it
  ge.it
  genoa.it
  genova.it
  go.it
  gorizia.it
  gr.it
  grosseto.it
  iglesias-carbonia.it
  iglesiascarbonia.it
  im.it
  imperia.it
  is.it
  isernia.it
  kr.it
  la-spezia.it
  laquila.it
  laspezia.it
  latina.it
  lc.it
  le.it
  lecce.it
  lecco.it
  li.it
  livorno.it
  lo.it
  lodi.it
  lt.it
  lu.it
  lucca.it
  macerata.it
  mantova.it
  massa-carrara.it
  massacarrara.it
  matera.it
  mb.it
  mc.it
  me.it
  medio-campidano.it
  mediocampidano.it
  messina.it
  mi.it
  milan.it
  milano.it
  mn.it
  mo.it
  modena.it
  monza-brianza.it
  monza-e-della-brianza.it
  monza.it
  monzabrianza.it
  monzaebrianza.it
  monzaedellabrianza.it
  ms.it
  mt.it
  na.it
  naples.it
  napoli.it
  no.it
  novara.it
  nu.it
  nuoro.it
  og.it
  ogliastra.it
  olbia-tempio.it
  olbiatempio.it
  or.it
  oristano.it
  ot.it
  pa.it
  padova.it
  padua.it
  palermo.it
  parma.it
  pavia.it
  pc.it
  pd.it
  pe.it
  perugia.it
  pesaro-urbino.it
  pesarourbino.it
  pescara.it
  pg.it
  pi.it
  piacenza.it
  pisa.it
  pistoia.it
  pn.it
  po.it
  pordenone.it
  potenza.it
  pr.it
  prato.it
  pt.it
  pu.it
  pv.it
  pz.it
  ra.it
  ragusa.it
  ravenna.it
  rc.it
  re.it
  reggio-calabria.it
  reggio-emilia.it
  reggiocalabria.it
  reggioemilia.it
  rg.it
  ri.it
  rieti.it
  rimini.it
  rm.it
  rn.it
  ro.it
  roma.it
  rome.it
  rovigo.it
  sa.it
  salerno.it
  sassari.it
  savona.it
  si.it
  siena.it
  siracusa.it
  so.it
  sondrio.it
  sp.it
  sr.it
  ss.it
  suedtirol.it
  xn--sdtirol-n2a.it
  sv.it
  ta.it
  taranto.it
  te.it
  tempio-olbia.it
  tempioolbia.it
  teramo.it
  terni.it
  tn.it
  to.it
  torino.it
  tp.it
  tr.it
  trani-andria-barletta.it
  trani-barletta-andria.it
  traniandriabarletta.it
  tranibarlettaandria.it
  trapani.it
  trento.it
  treviso.it
  trieste.it
  ts.it
  turin.it
  tv.it
  ud.it
  udine.it
  urbino-pesaro.it
  urbinopesaro.it
  va.it
  varese.it
  vb.it
  vc.it
  ve.it
  venezia.it
  venice.it
  verbania.it
  vercelli.it
  verona.it
  vi.it
  vibo-valentia.it
  vibovalentia.it
  vicenza.it
  viterbo.it
  vr.it
  vs.it
  vt.it
  vv.it
  
  // je : http://www.channelisles.net/register-domains/
  // Confirmed by registry <nigel@channelisles.net> 2013-11-28
  je
  co.je
  net.je
  org.je
  
  // jm : http://www.com.jm/register.html
  *.jm
  
  // jo : http://www.dns.jo/Registration_policy.aspx
  jo
  com.jo
  org.jo
  net.jo
  edu.jo
  sch.jo
  gov.jo
  mil.jo
  name.jo
  
  // jobs : https://en.wikipedia.org/wiki/.jobs
  jobs
  
  // jp : https://en.wikipedia.org/wiki/.jp
  // http://jprs.co.jp/en/jpdomain.html
  // Submitted by registry <info@jprs.jp>
  jp
  // jp organizational type names
  ac.jp
  ad.jp
  co.jp
  ed.jp
  go.jp
  gr.jp
  lg.jp
  ne.jp
  or.jp
  // jp prefecture type names
  aichi.jp
  akita.jp
  aomori.jp
  chiba.jp
  ehime.jp
  fukui.jp
  fukuoka.jp
  fukushima.jp
  gifu.jp
  gunma.jp
  hiroshima.jp
  hokkaido.jp
  hyogo.jp
  ibaraki.jp
  ishikawa.jp
  iwate.jp
  kagawa.jp
  kagoshima.jp
  kanagawa.jp
  kochi.jp
  kumamoto.jp
  kyoto.jp
  mie.jp
  miyagi.jp
  miyazaki.jp
  nagano.jp
  nagasaki.jp
  nara.jp
  niigata.jp
  oita.jp
  okayama.jp
  okinawa.jp
  osaka.jp
  saga.jp
  saitama.jp
  shiga.jp
  shimane.jp
  shizuoka.jp
  tochigi.jp
  tokushima.jp
  tokyo.jp
  tottori.jp
  toyama.jp
  wakayama.jp
  yamagata.jp
  yamaguchi.jp
  yamanashi.jp
  xn--4pvxs.jp
  xn--vgu402c.jp
  xn--c3s14m.jp
  xn--f6qx53a.jp
  xn--8pvr4u.jp
  xn--uist22h.jp
  xn--djrs72d6uy.jp
  xn--mkru45i.jp
  xn--0trq7p7nn.jp
  xn--8ltr62k.jp
  xn--2m4a15e.jp
  xn--efvn9s.jp
  xn--32vp30h.jp
  xn--4it797k.jp
  xn--1lqs71d.jp
  xn--5rtp49c.jp
  xn--5js045d.jp
  xn--ehqz56n.jp
  xn--1lqs03n.jp
  xn--qqqt11m.jp
  xn--kbrq7o.jp
  xn--pssu33l.jp
  xn--ntsq17g.jp
  xn--uisz3g.jp
  xn--6btw5a.jp
  xn--1ctwo.jp
  xn--6orx2r.jp
  xn--rht61e.jp
  xn--rht27z.jp
  xn--djty4k.jp
  xn--nit225k.jp
  xn--rht3d.jp
  xn--klty5x.jp
  xn--kltx9a.jp
  xn--kltp7d.jp
  xn--uuwu58a.jp
  xn--zbx025d.jp
  xn--ntso0iqx3a.jp
  xn--elqq16h.jp
  xn--4it168d.jp
  xn--klt787d.jp
  xn--rny31h.jp
  xn--7t0a264c.jp
  xn--5rtq34k.jp
  xn--k7yn95e.jp
  xn--tor131o.jp
  xn--d5qv7z876c.jp
  // jp geographic type names
  // http://jprs.jp/doc/rule/saisoku-1.html
  *.kawasaki.jp
  *.kitakyushu.jp
  *.kobe.jp
  *.nagoya.jp
  *.sapporo.jp
  *.sendai.jp
  *.yokohama.jp
  !city.kawasaki.jp
  !city.kitakyushu.jp
  !city.kobe.jp
  !city.nagoya.jp
  !city.sapporo.jp
  !city.sendai.jp
  !city.yokohama.jp
  // 4th level registration
  aisai.aichi.jp
  ama.aichi.jp
  anjo.aichi.jp
  asuke.aichi.jp
  chiryu.aichi.jp
  chita.aichi.jp
  fuso.aichi.jp
  gamagori.aichi.jp
  handa.aichi.jp
  hazu.aichi.jp
  hekinan.aichi.jp
  higashiura.aichi.jp
  ichinomiya.aichi.jp
  inazawa.aichi.jp
  inuyama.aichi.jp
  isshiki.aichi.jp
  iwakura.aichi.jp
  kanie.aichi.jp
  kariya.aichi.jp
  kasugai.aichi.jp
  kira.aichi.jp
  kiyosu.aichi.jp
  komaki.aichi.jp
  konan.aichi.jp
  kota.aichi.jp
  mihama.aichi.jp
  miyoshi.aichi.jp
  nishio.aichi.jp
  nisshin.aichi.jp
  obu.aichi.jp
  oguchi.aichi.jp
  oharu.aichi.jp
  okazaki.aichi.jp
  owariasahi.aichi.jp
  seto.aichi.jp
  shikatsu.aichi.jp
  shinshiro.aichi.jp
  shitara.aichi.jp
  tahara.aichi.jp
  takahama.aichi.jp
  tobishima.aichi.jp
  toei.aichi.jp
  togo.aichi.jp
  tokai.aichi.jp
  tokoname.aichi.jp
  toyoake.aichi.jp
  toyohashi.aichi.jp
  toyokawa.aichi.jp
  toyone.aichi.jp
  toyota.aichi.jp
  tsushima.aichi.jp
  yatomi.aichi.jp
  akita.akita.jp
  daisen.akita.jp
  fujisato.akita.jp
  gojome.akita.jp
  hachirogata.akita.jp
  happou.akita.jp
  higashinaruse.akita.jp
  honjo.akita.jp
  honjyo.akita.jp
  ikawa.akita.jp
  kamikoani.akita.jp
  kamioka.akita.jp
  katagami.akita.jp
  kazuno.akita.jp
  kitaakita.akita.jp
  kosaka.akita.jp
  kyowa.akita.jp
  misato.akita.jp
  mitane.akita.jp
  moriyoshi.akita.jp
  nikaho.akita.jp
  noshiro.akita.jp
  odate.akita.jp
  oga.akita.jp
  ogata.akita.jp
  semboku.akita.jp
  yokote.akita.jp
  yurihonjo.akita.jp
  aomori.aomori.jp
  gonohe.aomori.jp
  hachinohe.aomori.jp
  hashikami.aomori.jp
  hiranai.aomori.jp
  hirosaki.aomori.jp
  itayanagi.aomori.jp
  kuroishi.aomori.jp
  misawa.aomori.jp
  mutsu.aomori.jp
  nakadomari.aomori.jp
  noheji.aomori.jp
  oirase.aomori.jp
  owani.aomori.jp
  rokunohe.aomori.jp
  sannohe.aomori.jp
  shichinohe.aomori.jp
  shingo.aomori.jp
  takko.aomori.jp
  towada.aomori.jp
  tsugaru.aomori.jp
  tsuruta.aomori.jp
  abiko.chiba.jp
  asahi.chiba.jp
  chonan.chiba.jp
  chosei.chiba.jp
  choshi.chiba.jp
  chuo.chiba.jp
  funabashi.chiba.jp
  futtsu.chiba.jp
  hanamigawa.chiba.jp
  ichihara.chiba.jp
  ichikawa.chiba.jp
  ichinomiya.chiba.jp
  inzai.chiba.jp
  isumi.chiba.jp
  kamagaya.chiba.jp
  kamogawa.chiba.jp
  kashiwa.chiba.jp
  katori.chiba.jp
  katsuura.chiba.jp
  kimitsu.chiba.jp
  kisarazu.chiba.jp
  kozaki.chiba.jp
  kujukuri.chiba.jp
  kyonan.chiba.jp
  matsudo.chiba.jp
  midori.chiba.jp
  mihama.chiba.jp
  minamiboso.chiba.jp
  mobara.chiba.jp
  mutsuzawa.chiba.jp
  nagara.chiba.jp
  nagareyama.chiba.jp
  narashino.chiba.jp
  narita.chiba.jp
  noda.chiba.jp
  oamishirasato.chiba.jp
  omigawa.chiba.jp
  onjuku.chiba.jp
  otaki.chiba.jp
  sakae.chiba.jp
  sakura.chiba.jp
  shimofusa.chiba.jp
  shirako.chiba.jp
  shiroi.chiba.jp
  shisui.chiba.jp
  sodegaura.chiba.jp
  sosa.chiba.jp
  tako.chiba.jp
  tateyama.chiba.jp
  togane.chiba.jp
  tohnosho.chiba.jp
  tomisato.chiba.jp
  urayasu.chiba.jp
  yachimata.chiba.jp
  yachiyo.chiba.jp
  yokaichiba.chiba.jp
  yokoshibahikari.chiba.jp
  yotsukaido.chiba.jp
  ainan.ehime.jp
  honai.ehime.jp
  ikata.ehime.jp
  imabari.ehime.jp
  iyo.ehime.jp
  kamijima.ehime.jp
  kihoku.ehime.jp
  kumakogen.ehime.jp
  masaki.ehime.jp
  matsuno.ehime.jp
  matsuyama.ehime.jp
  namikata.ehime.jp
  niihama.ehime.jp
  ozu.ehime.jp
  saijo.ehime.jp
  seiyo.ehime.jp
  shikokuchuo.ehime.jp
  tobe.ehime.jp
  toon.ehime.jp
  uchiko.ehime.jp
  uwajima.ehime.jp
  yawatahama.ehime.jp
  echizen.fukui.jp
  eiheiji.fukui.jp
  fukui.fukui.jp
  ikeda.fukui.jp
  katsuyama.fukui.jp
  mihama.fukui.jp
  minamiechizen.fukui.jp
  obama.fukui.jp
  ohi.fukui.jp
  ono.fukui.jp
  sabae.fukui.jp
  sakai.fukui.jp
  takahama.fukui.jp
  tsuruga.fukui.jp
  wakasa.fukui.jp
  ashiya.fukuoka.jp
  buzen.fukuoka.jp
  chikugo.fukuoka.jp
  chikuho.fukuoka.jp
  chikujo.fukuoka.jp
  chikushino.fukuoka.jp
  chikuzen.fukuoka.jp
  chuo.fukuoka.jp
  dazaifu.fukuoka.jp
  fukuchi.fukuoka.jp
  hakata.fukuoka.jp
  higashi.fukuoka.jp
  hirokawa.fukuoka.jp
  hisayama.fukuoka.jp
  iizuka.fukuoka.jp
  inatsuki.fukuoka.jp
  kaho.fukuoka.jp
  kasuga.fukuoka.jp
  kasuya.fukuoka.jp
  kawara.fukuoka.jp
  keisen.fukuoka.jp
  koga.fukuoka.jp
  kurate.fukuoka.jp
  kurogi.fukuoka.jp
  kurume.fukuoka.jp
  minami.fukuoka.jp
  miyako.fukuoka.jp
  miyama.fukuoka.jp
  miyawaka.fukuoka.jp
  mizumaki.fukuoka.jp
  munakata.fukuoka.jp
  nakagawa.fukuoka.jp
  nakama.fukuoka.jp
  nishi.fukuoka.jp
  nogata.fukuoka.jp
  ogori.fukuoka.jp
  okagaki.fukuoka.jp
  okawa.fukuoka.jp
  oki.fukuoka.jp
  omuta.fukuoka.jp
  onga.fukuoka.jp
  onojo.fukuoka.jp
  oto.fukuoka.jp
  saigawa.fukuoka.jp
  sasaguri.fukuoka.jp
  shingu.fukuoka.jp
  shinyoshitomi.fukuoka.jp
  shonai.fukuoka.jp
  soeda.fukuoka.jp
  sue.fukuoka.jp
  tachiarai.fukuoka.jp
  tagawa.fukuoka.jp
  takata.fukuoka.jp
  toho.fukuoka.jp
  toyotsu.fukuoka.jp
  tsuiki.fukuoka.jp
  ukiha.fukuoka.jp
  umi.fukuoka.jp
  usui.fukuoka.jp
  yamada.fukuoka.jp
  yame.fukuoka.jp
  yanagawa.fukuoka.jp
  yukuhashi.fukuoka.jp
  aizubange.fukushima.jp
  aizumisato.fukushima.jp
  aizuwakamatsu.fukushima.jp
  asakawa.fukushima.jp
  bandai.fukushima.jp
  date.fukushima.jp
  fukushima.fukushima.jp
  furudono.fukushima.jp
  futaba.fukushima.jp
  hanawa.fukushima.jp
  higashi.fukushima.jp
  hirata.fukushima.jp
  hirono.fukushima.jp
  iitate.fukushima.jp
  inawashiro.fukushima.jp
  ishikawa.fukushima.jp
  iwaki.fukushima.jp
  izumizaki.fukushima.jp
  kagamiishi.fukushima.jp
  kaneyama.fukushima.jp
  kawamata.fukushima.jp
  kitakata.fukushima.jp
  kitashiobara.fukushima.jp
  koori.fukushima.jp
  koriyama.fukushima.jp
  kunimi.fukushima.jp
  miharu.fukushima.jp
  mishima.fukushima.jp
  namie.fukushima.jp
  nango.fukushima.jp
  nishiaizu.fukushima.jp
  nishigo.fukushima.jp
  okuma.fukushima.jp
  omotego.fukushima.jp
  ono.fukushima.jp
  otama.fukushima.jp
  samegawa.fukushima.jp
  shimogo.fukushima.jp
  shirakawa.fukushima.jp
  showa.fukushima.jp
  soma.fukushima.jp
  sukagawa.fukushima.jp
  taishin.fukushima.jp
  tamakawa.fukushima.jp
  tanagura.fukushima.jp
  tenei.fukushima.jp
  yabuki.fukushima.jp
  yamato.fukushima.jp
  yamatsuri.fukushima.jp
  yanaizu.fukushima.jp
  yugawa.fukushima.jp
  anpachi.gifu.jp
  ena.gifu.jp
  gifu.gifu.jp
  ginan.gifu.jp
  godo.gifu.jp
  gujo.gifu.jp
  hashima.gifu.jp
  hichiso.gifu.jp
  hida.gifu.jp
  higashishirakawa.gifu.jp
  ibigawa.gifu.jp
  ikeda.gifu.jp
  kakamigahara.gifu.jp
  kani.gifu.jp
  kasahara.gifu.jp
  kasamatsu.gifu.jp
  kawaue.gifu.jp
  kitagata.gifu.jp
  mino.gifu.jp
  minokamo.gifu.jp
  mitake.gifu.jp
  mizunami.gifu.jp
  motosu.gifu.jp
  nakatsugawa.gifu.jp
  ogaki.gifu.jp
  sakahogi.gifu.jp
  seki.gifu.jp
  sekigahara.gifu.jp
  shirakawa.gifu.jp
  tajimi.gifu.jp
  takayama.gifu.jp
  tarui.gifu.jp
  toki.gifu.jp
  tomika.gifu.jp
  wanouchi.gifu.jp
  yamagata.gifu.jp
  yaotsu.gifu.jp
  yoro.gifu.jp
  annaka.gunma.jp
  chiyoda.gunma.jp
  fujioka.gunma.jp
  higashiagatsuma.gunma.jp
  isesaki.gunma.jp
  itakura.gunma.jp
  kanna.gunma.jp
  kanra.gunma.jp
  katashina.gunma.jp
  kawaba.gunma.jp
  kiryu.gunma.jp
  kusatsu.gunma.jp
  maebashi.gunma.jp
  meiwa.gunma.jp
  midori.gunma.jp
  minakami.gunma.jp
  naganohara.gunma.jp
  nakanojo.gunma.jp
  nanmoku.gunma.jp
  numata.gunma.jp
  oizumi.gunma.jp
  ora.gunma.jp
  ota.gunma.jp
  shibukawa.gunma.jp
  shimonita.gunma.jp
  shinto.gunma.jp
  showa.gunma.jp
  takasaki.gunma.jp
  takayama.gunma.jp
  tamamura.gunma.jp
  tatebayashi.gunma.jp
  tomioka.gunma.jp
  tsukiyono.gunma.jp
  tsumagoi.gunma.jp
  ueno.gunma.jp
  yoshioka.gunma.jp
  asaminami.hiroshima.jp
  daiwa.hiroshima.jp
  etajima.hiroshima.jp
  fuchu.hiroshima.jp
  fukuyama.hiroshima.jp
  hatsukaichi.hiroshima.jp
  higashihiroshima.hiroshima.jp
  hongo.hiroshima.jp
  jinsekikogen.hiroshima.jp
  kaita.hiroshima.jp
  kui.hiroshima.jp
  kumano.hiroshima.jp
  kure.hiroshima.jp
  mihara.hiroshima.jp
  miyoshi.hiroshima.jp
  naka.hiroshima.jp
  onomichi.hiroshima.jp
  osakikamijima.hiroshima.jp
  otake.hiroshima.jp
  saka.hiroshima.jp
  sera.hiroshima.jp
  seranishi.hiroshima.jp
  shinichi.hiroshima.jp
  shobara.hiroshima.jp
  takehara.hiroshima.jp
  abashiri.hokkaido.jp
  abira.hokkaido.jp
  aibetsu.hokkaido.jp
  akabira.hokkaido.jp
  akkeshi.hokkaido.jp
  asahikawa.hokkaido.jp
  ashibetsu.hokkaido.jp
  ashoro.hokkaido.jp
  assabu.hokkaido.jp
  atsuma.hokkaido.jp
  bibai.hokkaido.jp
  biei.hokkaido.jp
  bifuka.hokkaido.jp
  bihoro.hokkaido.jp
  biratori.hokkaido.jp
  chippubetsu.hokkaido.jp
  chitose.hokkaido.jp
  date.hokkaido.jp
  ebetsu.hokkaido.jp
  embetsu.hokkaido.jp
  eniwa.hokkaido.jp
  erimo.hokkaido.jp
  esan.hokkaido.jp
  esashi.hokkaido.jp
  fukagawa.hokkaido.jp
  fukushima.hokkaido.jp
  furano.hokkaido.jp
  furubira.hokkaido.jp
  haboro.hokkaido.jp
  hakodate.hokkaido.jp
  hamatonbetsu.hokkaido.jp
  hidaka.hokkaido.jp
  higashikagura.hokkaido.jp
  higashikawa.hokkaido.jp
  hiroo.hokkaido.jp
  hokuryu.hokkaido.jp
  hokuto.hokkaido.jp
  honbetsu.hokkaido.jp
  horokanai.hokkaido.jp
  horonobe.hokkaido.jp
  ikeda.hokkaido.jp
  imakane.hokkaido.jp
  ishikari.hokkaido.jp
  iwamizawa.hokkaido.jp
  iwanai.hokkaido.jp
  kamifurano.hokkaido.jp
  kamikawa.hokkaido.jp
  kamishihoro.hokkaido.jp
  kamisunagawa.hokkaido.jp
  kamoenai.hokkaido.jp
  kayabe.hokkaido.jp
  kembuchi.hokkaido.jp
  kikonai.hokkaido.jp
  kimobetsu.hokkaido.jp
  kitahiroshima.hokkaido.jp
  kitami.hokkaido.jp
  kiyosato.hokkaido.jp
  koshimizu.hokkaido.jp
  kunneppu.hokkaido.jp
  kuriyama.hokkaido.jp
  kuromatsunai.hokkaido.jp
  kushiro.hokkaido.jp
  kutchan.hokkaido.jp
  kyowa.hokkaido.jp
  mashike.hokkaido.jp
  matsumae.hokkaido.jp
  mikasa.hokkaido.jp
  minamifurano.hokkaido.jp
  mombetsu.hokkaido.jp
  moseushi.hokkaido.jp
  mukawa.hokkaido.jp
  muroran.hokkaido.jp
  naie.hokkaido.jp
  nakagawa.hokkaido.jp
  nakasatsunai.hokkaido.jp
  nakatombetsu.hokkaido.jp
  nanae.hokkaido.jp
  nanporo.hokkaido.jp
  nayoro.hokkaido.jp
  nemuro.hokkaido.jp
  niikappu.hokkaido.jp
  niki.hokkaido.jp
  nishiokoppe.hokkaido.jp
  noboribetsu.hokkaido.jp
  numata.hokkaido.jp
  obihiro.hokkaido.jp
  obira.hokkaido.jp
  oketo.hokkaido.jp
  okoppe.hokkaido.jp
  otaru.hokkaido.jp
  otobe.hokkaido.jp
  otofuke.hokkaido.jp
  otoineppu.hokkaido.jp
  oumu.hokkaido.jp
  ozora.hokkaido.jp
  pippu.hokkaido.jp
  rankoshi.hokkaido.jp
  rebun.hokkaido.jp
  rikubetsu.hokkaido.jp
  rishiri.hokkaido.jp
  rishirifuji.hokkaido.jp
  saroma.hokkaido.jp
  sarufutsu.hokkaido.jp
  shakotan.hokkaido.jp
  shari.hokkaido.jp
  shibecha.hokkaido.jp
  shibetsu.hokkaido.jp
  shikabe.hokkaido.jp
  shikaoi.hokkaido.jp
  shimamaki.hokkaido.jp
  shimizu.hokkaido.jp
  shimokawa.hokkaido.jp
  shinshinotsu.hokkaido.jp
  shintoku.hokkaido.jp
  shiranuka.hokkaido.jp
  shiraoi.hokkaido.jp
  shiriuchi.hokkaido.jp
  sobetsu.hokkaido.jp
  sunagawa.hokkaido.jp
  taiki.hokkaido.jp
  takasu.hokkaido.jp
  takikawa.hokkaido.jp
  takinoue.hokkaido.jp
  teshikaga.hokkaido.jp
  tobetsu.hokkaido.jp
  tohma.hokkaido.jp
  tomakomai.hokkaido.jp
  tomari.hokkaido.jp
  toya.hokkaido.jp
  toyako.hokkaido.jp
  toyotomi.hokkaido.jp
  toyoura.hokkaido.jp
  tsubetsu.hokkaido.jp
  tsukigata.hokkaido.jp
  urakawa.hokkaido.jp
  urausu.hokkaido.jp
  uryu.hokkaido.jp
  utashinai.hokkaido.jp
  wakkanai.hokkaido.jp
  wassamu.hokkaido.jp
  yakumo.hokkaido.jp
  yoichi.hokkaido.jp
  aioi.hyogo.jp
  akashi.hyogo.jp
  ako.hyogo.jp
  amagasaki.hyogo.jp
  aogaki.hyogo.jp
  asago.hyogo.jp
  ashiya.hyogo.jp
  awaji.hyogo.jp
  fukusaki.hyogo.jp
  goshiki.hyogo.jp
  harima.hyogo.jp
  himeji.hyogo.jp
  ichikawa.hyogo.jp
  inagawa.hyogo.jp
  itami.hyogo.jp
  kakogawa.hyogo.jp
  kamigori.hyogo.jp
  kamikawa.hyogo.jp
  kasai.hyogo.jp
  kasuga.hyogo.jp
  kawanishi.hyogo.jp
  miki.hyogo.jp
  minamiawaji.hyogo.jp
  nishinomiya.hyogo.jp
  nishiwaki.hyogo.jp
  ono.hyogo.jp
  sanda.hyogo.jp
  sannan.hyogo.jp
  sasayama.hyogo.jp
  sayo.hyogo.jp
  shingu.hyogo.jp
  shinonsen.hyogo.jp
  shiso.hyogo.jp
  sumoto.hyogo.jp
  taishi.hyogo.jp
  taka.hyogo.jp
  takarazuka.hyogo.jp
  takasago.hyogo.jp
  takino.hyogo.jp
  tamba.hyogo.jp
  tatsuno.hyogo.jp
  toyooka.hyogo.jp
  yabu.hyogo.jp
  yashiro.hyogo.jp
  yoka.hyogo.jp
  yokawa.hyogo.jp
  ami.ibaraki.jp
  asahi.ibaraki.jp
  bando.ibaraki.jp
  chikusei.ibaraki.jp
  daigo.ibaraki.jp
  fujishiro.ibaraki.jp
  hitachi.ibaraki.jp
  hitachinaka.ibaraki.jp
  hitachiomiya.ibaraki.jp
  hitachiota.ibaraki.jp
  ibaraki.ibaraki.jp
  ina.ibaraki.jp
  inashiki.ibaraki.jp
  itako.ibaraki.jp
  iwama.ibaraki.jp
  joso.ibaraki.jp
  kamisu.ibaraki.jp
  kasama.ibaraki.jp
  kashima.ibaraki.jp
  kasumigaura.ibaraki.jp
  koga.ibaraki.jp
  miho.ibaraki.jp
  mito.ibaraki.jp
  moriya.ibaraki.jp
  naka.ibaraki.jp
  namegata.ibaraki.jp
  oarai.ibaraki.jp
  ogawa.ibaraki.jp
  omitama.ibaraki.jp
  ryugasaki.ibaraki.jp
  sakai.ibaraki.jp
  sakuragawa.ibaraki.jp
  shimodate.ibaraki.jp
  shimotsuma.ibaraki.jp
  shirosato.ibaraki.jp
  sowa.ibaraki.jp
  suifu.ibaraki.jp
  takahagi.ibaraki.jp
  tamatsukuri.ibaraki.jp
  tokai.ibaraki.jp
  tomobe.ibaraki.jp
  tone.ibaraki.jp
  toride.ibaraki.jp
  tsuchiura.ibaraki.jp
  tsukuba.ibaraki.jp
  uchihara.ibaraki.jp
  ushiku.ibaraki.jp
  yachiyo.ibaraki.jp
  yamagata.ibaraki.jp
  yawara.ibaraki.jp
  yuki.ibaraki.jp
  anamizu.ishikawa.jp
  hakui.ishikawa.jp
  hakusan.ishikawa.jp
  kaga.ishikawa.jp
  kahoku.ishikawa.jp
  kanazawa.ishikawa.jp
  kawakita.ishikawa.jp
  komatsu.ishikawa.jp
  nakanoto.ishikawa.jp
  nanao.ishikawa.jp
  nomi.ishikawa.jp
  nonoichi.ishikawa.jp
  noto.ishikawa.jp
  shika.ishikawa.jp
  suzu.ishikawa.jp
  tsubata.ishikawa.jp
  tsurugi.ishikawa.jp
  uchinada.ishikawa.jp
  wajima.ishikawa.jp
  fudai.iwate.jp
  fujisawa.iwate.jp
  hanamaki.iwate.jp
  hiraizumi.iwate.jp
  hirono.iwate.jp
  ichinohe.iwate.jp
  ichinoseki.iwate.jp
  iwaizumi.iwate.jp
  iwate.iwate.jp
  joboji.iwate.jp
  kamaishi.iwate.jp
  kanegasaki.iwate.jp
  karumai.iwate.jp
  kawai.iwate.jp
  kitakami.iwate.jp
  kuji.iwate.jp
  kunohe.iwate.jp
  kuzumaki.iwate.jp
  miyako.iwate.jp
  mizusawa.iwate.jp
  morioka.iwate.jp
  ninohe.iwate.jp
  noda.iwate.jp
  ofunato.iwate.jp
  oshu.iwate.jp
  otsuchi.iwate.jp
  rikuzentakata.iwate.jp
  shiwa.iwate.jp
  shizukuishi.iwate.jp
  sumita.iwate.jp
  tanohata.iwate.jp
  tono.iwate.jp
  yahaba.iwate.jp
  yamada.iwate.jp
  ayagawa.kagawa.jp
  higashikagawa.kagawa.jp
  kanonji.kagawa.jp
  kotohira.kagawa.jp
  manno.kagawa.jp
  marugame.kagawa.jp
  mitoyo.kagawa.jp
  naoshima.kagawa.jp
  sanuki.kagawa.jp
  tadotsu.kagawa.jp
  takamatsu.kagawa.jp
  tonosho.kagawa.jp
  uchinomi.kagawa.jp
  utazu.kagawa.jp
  zentsuji.kagawa.jp
  akune.kagoshima.jp
  amami.kagoshima.jp
  hioki.kagoshima.jp
  isa.kagoshima.jp
  isen.kagoshima.jp
  izumi.kagoshima.jp
  kagoshima.kagoshima.jp
  kanoya.kagoshima.jp
  kawanabe.kagoshima.jp
  kinko.kagoshima.jp
  kouyama.kagoshima.jp
  makurazaki.kagoshima.jp
  matsumoto.kagoshima.jp
  minamitane.kagoshima.jp
  nakatane.kagoshima.jp
  nishinoomote.kagoshima.jp
  satsumasendai.kagoshima.jp
  soo.kagoshima.jp
  tarumizu.kagoshima.jp
  yusui.kagoshima.jp
  aikawa.kanagawa.jp
  atsugi.kanagawa.jp
  ayase.kanagawa.jp
  chigasaki.kanagawa.jp
  ebina.kanagawa.jp
  fujisawa.kanagawa.jp
  hadano.kanagawa.jp
  hakone.kanagawa.jp
  hiratsuka.kanagawa.jp
  isehara.kanagawa.jp
  kaisei.kanagawa.jp
  kamakura.kanagawa.jp
  kiyokawa.kanagawa.jp
  matsuda.kanagawa.jp
  minamiashigara.kanagawa.jp
  miura.kanagawa.jp
  nakai.kanagawa.jp
  ninomiya.kanagawa.jp
  odawara.kanagawa.jp
  oi.kanagawa.jp
  oiso.kanagawa.jp
  sagamihara.kanagawa.jp
  samukawa.kanagawa.jp
  tsukui.kanagawa.jp
  yamakita.kanagawa.jp
  yamato.kanagawa.jp
  yokosuka.kanagawa.jp
  yugawara.kanagawa.jp
  zama.kanagawa.jp
  zushi.kanagawa.jp
  aki.kochi.jp
  geisei.kochi.jp
  hidaka.kochi.jp
  higashitsuno.kochi.jp
  ino.kochi.jp
  kagami.kochi.jp
  kami.kochi.jp
  kitagawa.kochi.jp
  kochi.kochi.jp
  mihara.kochi.jp
  motoyama.kochi.jp
  muroto.kochi.jp
  nahari.kochi.jp
  nakamura.kochi.jp
  nankoku.kochi.jp
  nishitosa.kochi.jp
  niyodogawa.kochi.jp
  ochi.kochi.jp
  okawa.kochi.jp
  otoyo.kochi.jp
  otsuki.kochi.jp
  sakawa.kochi.jp
  sukumo.kochi.jp
  susaki.kochi.jp
  tosa.kochi.jp
  tosashimizu.kochi.jp
  toyo.kochi.jp
  tsuno.kochi.jp
  umaji.kochi.jp
  yasuda.kochi.jp
  yusuhara.kochi.jp
  amakusa.kumamoto.jp
  arao.kumamoto.jp
  aso.kumamoto.jp
  choyo.kumamoto.jp
  gyokuto.kumamoto.jp
  kamiamakusa.kumamoto.jp
  kikuchi.kumamoto.jp
  kumamoto.kumamoto.jp
  mashiki.kumamoto.jp
  mifune.kumamoto.jp
  minamata.kumamoto.jp
  minamioguni.kumamoto.jp
  nagasu.kumamoto.jp
  nishihara.kumamoto.jp
  oguni.kumamoto.jp
  ozu.kumamoto.jp
  sumoto.kumamoto.jp
  takamori.kumamoto.jp
  uki.kumamoto.jp
  uto.kumamoto.jp
  yamaga.kumamoto.jp
  yamato.kumamoto.jp
  yatsushiro.kumamoto.jp
  ayabe.kyoto.jp
  fukuchiyama.kyoto.jp
  higashiyama.kyoto.jp
  ide.kyoto.jp
  ine.kyoto.jp
  joyo.kyoto.jp
  kameoka.kyoto.jp
  kamo.kyoto.jp
  kita.kyoto.jp
  kizu.kyoto.jp
  kumiyama.kyoto.jp
  kyotamba.kyoto.jp
  kyotanabe.kyoto.jp
  kyotango.kyoto.jp
  maizuru.kyoto.jp
  minami.kyoto.jp
  minamiyamashiro.kyoto.jp
  miyazu.kyoto.jp
  muko.kyoto.jp
  nagaokakyo.kyoto.jp
  nakagyo.kyoto.jp
  nantan.kyoto.jp
  oyamazaki.kyoto.jp
  sakyo.kyoto.jp
  seika.kyoto.jp
  tanabe.kyoto.jp
  uji.kyoto.jp
  ujitawara.kyoto.jp
  wazuka.kyoto.jp
  yamashina.kyoto.jp
  yawata.kyoto.jp
  asahi.mie.jp
  inabe.mie.jp
  ise.mie.jp
  kameyama.mie.jp
  kawagoe.mie.jp
  kiho.mie.jp
  kisosaki.mie.jp
  kiwa.mie.jp
  komono.mie.jp
  kumano.mie.jp
  kuwana.mie.jp
  matsusaka.mie.jp
  meiwa.mie.jp
  mihama.mie.jp
  minamiise.mie.jp
  misugi.mie.jp
  miyama.mie.jp
  nabari.mie.jp
  shima.mie.jp
  suzuka.mie.jp
  tado.mie.jp
  taiki.mie.jp
  taki.mie.jp
  tamaki.mie.jp
  toba.mie.jp
  tsu.mie.jp
  udono.mie.jp
  ureshino.mie.jp
  watarai.mie.jp
  yokkaichi.mie.jp
  furukawa.miyagi.jp
  higashimatsushima.miyagi.jp
  ishinomaki.miyagi.jp
  iwanuma.miyagi.jp
  kakuda.miyagi.jp
  kami.miyagi.jp
  kawasaki.miyagi.jp
  marumori.miyagi.jp
  matsushima.miyagi.jp
  minamisanriku.miyagi.jp
  misato.miyagi.jp
  murata.miyagi.jp
  natori.miyagi.jp
  ogawara.miyagi.jp
  ohira.miyagi.jp
  onagawa.miyagi.jp
  osaki.miyagi.jp
  rifu.miyagi.jp
  semine.miyagi.jp
  shibata.miyagi.jp
  shichikashuku.miyagi.jp
  shikama.miyagi.jp
  shiogama.miyagi.jp
  shiroishi.miyagi.jp
  tagajo.miyagi.jp
  taiwa.miyagi.jp
  tome.miyagi.jp
  tomiya.miyagi.jp
  wakuya.miyagi.jp
  watari.miyagi.jp
  yamamoto.miyagi.jp
  zao.miyagi.jp
  aya.miyazaki.jp
  ebino.miyazaki.jp
  gokase.miyazaki.jp
  hyuga.miyazaki.jp
  kadogawa.miyazaki.jp
  kawaminami.miyazaki.jp
  kijo.miyazaki.jp
  kitagawa.miyazaki.jp
  kitakata.miyazaki.jp
  kitaura.miyazaki.jp
  kobayashi.miyazaki.jp
  kunitomi.miyazaki.jp
  kushima.miyazaki.jp
  mimata.miyazaki.jp
  miyakonojo.miyazaki.jp
  miyazaki.miyazaki.jp
  morotsuka.miyazaki.jp
  nichinan.miyazaki.jp
  nishimera.miyazaki.jp
  nobeoka.miyazaki.jp
  saito.miyazaki.jp
  shiiba.miyazaki.jp
  shintomi.miyazaki.jp
  takaharu.miyazaki.jp
  takanabe.miyazaki.jp
  takazaki.miyazaki.jp
  tsuno.miyazaki.jp
  achi.nagano.jp
  agematsu.nagano.jp
  anan.nagano.jp
  aoki.nagano.jp
  asahi.nagano.jp
  azumino.nagano.jp
  chikuhoku.nagano.jp
  chikuma.nagano.jp
  chino.nagano.jp
  fujimi.nagano.jp
  hakuba.nagano.jp
  hara.nagano.jp
  hiraya.nagano.jp
  iida.nagano.jp
  iijima.nagano.jp
  iiyama.nagano.jp
  iizuna.nagano.jp
  ikeda.nagano.jp
  ikusaka.nagano.jp
  ina.nagano.jp
  karuizawa.nagano.jp
  kawakami.nagano.jp
  kiso.nagano.jp
  kisofukushima.nagano.jp
  kitaaiki.nagano.jp
  komagane.nagano.jp
  komoro.nagano.jp
  matsukawa.nagano.jp
  matsumoto.nagano.jp
  miasa.nagano.jp
  minamiaiki.nagano.jp
  minamimaki.nagano.jp
  minamiminowa.nagano.jp
  minowa.nagano.jp
  miyada.nagano.jp
  miyota.nagano.jp
  mochizuki.nagano.jp
  nagano.nagano.jp
  nagawa.nagano.jp
  nagiso.nagano.jp
  nakagawa.nagano.jp
  nakano.nagano.jp
  nozawaonsen.nagano.jp
  obuse.nagano.jp
  ogawa.nagano.jp
  okaya.nagano.jp
  omachi.nagano.jp
  omi.nagano.jp
  ookuwa.nagano.jp
  ooshika.nagano.jp
  otaki.nagano.jp
  otari.nagano.jp
  sakae.nagano.jp
  sakaki.nagano.jp
  saku.nagano.jp
  sakuho.nagano.jp
  shimosuwa.nagano.jp
  shinanomachi.nagano.jp
  shiojiri.nagano.jp
  suwa.nagano.jp
  suzaka.nagano.jp
  takagi.nagano.jp
  takamori.nagano.jp
  takayama.nagano.jp
  tateshina.nagano.jp
  tatsuno.nagano.jp
  togakushi.nagano.jp
  togura.nagano.jp
  tomi.nagano.jp
  ueda.nagano.jp
  wada.nagano.jp
  yamagata.nagano.jp
  yamanouchi.nagano.jp
  yasaka.nagano.jp
  yasuoka.nagano.jp
  chijiwa.nagasaki.jp
  futsu.nagasaki.jp
  goto.nagasaki.jp
  hasami.nagasaki.jp
  hirado.nagasaki.jp
  iki.nagasaki.jp
  isahaya.nagasaki.jp
  kawatana.nagasaki.jp
  kuchinotsu.nagasaki.jp
  matsuura.nagasaki.jp
  nagasaki.nagasaki.jp
  obama.nagasaki.jp
  omura.nagasaki.jp
  oseto.nagasaki.jp
  saikai.nagasaki.jp
  sasebo.nagasaki.jp
  seihi.nagasaki.jp
  shimabara.nagasaki.jp
  shinkamigoto.nagasaki.jp
  togitsu.nagasaki.jp
  tsushima.nagasaki.jp
  unzen.nagasaki.jp
  ando.nara.jp
  gose.nara.jp
  heguri.nara.jp
  higashiyoshino.nara.jp
  ikaruga.nara.jp
  ikoma.nara.jp
  kamikitayama.nara.jp
  kanmaki.nara.jp
  kashiba.nara.jp
  kashihara.nara.jp
  katsuragi.nara.jp
  kawai.nara.jp
  kawakami.nara.jp
  kawanishi.nara.jp
  koryo.nara.jp
  kurotaki.nara.jp
  mitsue.nara.jp
  miyake.nara.jp
  nara.nara.jp
  nosegawa.nara.jp
  oji.nara.jp
  ouda.nara.jp
  oyodo.nara.jp
  sakurai.nara.jp
  sango.nara.jp
  shimoichi.nara.jp
  shimokitayama.nara.jp
  shinjo.nara.jp
  soni.nara.jp
  takatori.nara.jp
  tawaramoto.nara.jp
  tenkawa.nara.jp
  tenri.nara.jp
  uda.nara.jp
  yamatokoriyama.nara.jp
  yamatotakada.nara.jp
  yamazoe.nara.jp
  yoshino.nara.jp
  aga.niigata.jp
  agano.niigata.jp
  gosen.niigata.jp
  itoigawa.niigata.jp
  izumozaki.niigata.jp
  joetsu.niigata.jp
  kamo.niigata.jp
  kariwa.niigata.jp
  kashiwazaki.niigata.jp
  minamiuonuma.niigata.jp
  mitsuke.niigata.jp
  muika.niigata.jp
  murakami.niigata.jp
  myoko.niigata.jp
  nagaoka.niigata.jp
  niigata.niigata.jp
  ojiya.niigata.jp
  omi.niigata.jp
  sado.niigata.jp
  sanjo.niigata.jp
  seiro.niigata.jp
  seirou.niigata.jp
  sekikawa.niigata.jp
  shibata.niigata.jp
  tagami.niigata.jp
  tainai.niigata.jp
  tochio.niigata.jp
  tokamachi.niigata.jp
  tsubame.niigata.jp
  tsunan.niigata.jp
  uonuma.niigata.jp
  yahiko.niigata.jp
  yoita.niigata.jp
  yuzawa.niigata.jp
  beppu.oita.jp
  bungoono.oita.jp
  bungotakada.oita.jp
  hasama.oita.jp
  hiji.oita.jp
  himeshima.oita.jp
  hita.oita.jp
  kamitsue.oita.jp
  kokonoe.oita.jp
  kuju.oita.jp
  kunisaki.oita.jp
  kusu.oita.jp
  oita.oita.jp
  saiki.oita.jp
  taketa.oita.jp
  tsukumi.oita.jp
  usa.oita.jp
  usuki.oita.jp
  yufu.oita.jp
  akaiwa.okayama.jp
  asakuchi.okayama.jp
  bizen.okayama.jp
  hayashima.okayama.jp
  ibara.okayama.jp
  kagamino.okayama.jp
  kasaoka.okayama.jp
  kibichuo.okayama.jp
  kumenan.okayama.jp
  kurashiki.okayama.jp
  maniwa.okayama.jp
  misaki.okayama.jp
  nagi.okayama.jp
  niimi.okayama.jp
  nishiawakura.okayama.jp
  okayama.okayama.jp
  satosho.okayama.jp
  setouchi.okayama.jp
  shinjo.okayama.jp
  shoo.okayama.jp
  soja.okayama.jp
  takahashi.okayama.jp
  tamano.okayama.jp
  tsuyama.okayama.jp
  wake.okayama.jp
  yakage.okayama.jp
  aguni.okinawa.jp
  ginowan.okinawa.jp
  ginoza.okinawa.jp
  gushikami.okinawa.jp
  haebaru.okinawa.jp
  higashi.okinawa.jp
  hirara.okinawa.jp
  iheya.okinawa.jp
  ishigaki.okinawa.jp
  ishikawa.okinawa.jp
  itoman.okinawa.jp
  izena.okinawa.jp
  kadena.okinawa.jp
  kin.okinawa.jp
  kitadaito.okinawa.jp
  kitanakagusuku.okinawa.jp
  kumejima.okinawa.jp
  kunigami.okinawa.jp
  minamidaito.okinawa.jp
  motobu.okinawa.jp
  nago.okinawa.jp
  naha.okinawa.jp
  nakagusuku.okinawa.jp
  nakijin.okinawa.jp
  nanjo.okinawa.jp
  nishihara.okinawa.jp
  ogimi.okinawa.jp
  okinawa.okinawa.jp
  onna.okinawa.jp
  shimoji.okinawa.jp
  taketomi.okinawa.jp
  tarama.okinawa.jp
  tokashiki.okinawa.jp
  tomigusuku.okinawa.jp
  tonaki.okinawa.jp
  urasoe.okinawa.jp
  uruma.okinawa.jp
  yaese.okinawa.jp
  yomitan.okinawa.jp
  yonabaru.okinawa.jp
  yonaguni.okinawa.jp
  zamami.okinawa.jp
  abeno.osaka.jp
  chihayaakasaka.osaka.jp
  chuo.osaka.jp
  daito.osaka.jp
  fujiidera.osaka.jp
  habikino.osaka.jp
  hannan.osaka.jp
  higashiosaka.osaka.jp
  higashisumiyoshi.osaka.jp
  higashiyodogawa.osaka.jp
  hirakata.osaka.jp
  ibaraki.osaka.jp
  ikeda.osaka.jp
  izumi.osaka.jp
  izumiotsu.osaka.jp
  izumisano.osaka.jp
  kadoma.osaka.jp
  kaizuka.osaka.jp
  kanan.osaka.jp
  kashiwara.osaka.jp
  katano.osaka.jp
  kawachinagano.osaka.jp
  kishiwada.osaka.jp
  kita.osaka.jp
  kumatori.osaka.jp
  matsubara.osaka.jp
  minato.osaka.jp
  minoh.osaka.jp
  misaki.osaka.jp
  moriguchi.osaka.jp
  neyagawa.osaka.jp
  nishi.osaka.jp
  nose.osaka.jp
  osakasayama.osaka.jp
  sakai.osaka.jp
  sayama.osaka.jp
  sennan.osaka.jp
  settsu.osaka.jp
  shijonawate.osaka.jp
  shimamoto.osaka.jp
  suita.osaka.jp
  tadaoka.osaka.jp
  taishi.osaka.jp
  tajiri.osaka.jp
  takaishi.osaka.jp
  takatsuki.osaka.jp
  tondabayashi.osaka.jp
  toyonaka.osaka.jp
  toyono.osaka.jp
  yao.osaka.jp
  ariake.saga.jp
  arita.saga.jp
  fukudomi.saga.jp
  genkai.saga.jp
  hamatama.saga.jp
  hizen.saga.jp
  imari.saga.jp
  kamimine.saga.jp
  kanzaki.saga.jp
  karatsu.saga.jp
  kashima.saga.jp
  kitagata.saga.jp
  kitahata.saga.jp
  kiyama.saga.jp
  kouhoku.saga.jp
  kyuragi.saga.jp
  nishiarita.saga.jp
  ogi.saga.jp
  omachi.saga.jp
  ouchi.saga.jp
  saga.saga.jp
  shiroishi.saga.jp
  taku.saga.jp
  tara.saga.jp
  tosu.saga.jp
  yoshinogari.saga.jp
  arakawa.saitama.jp
  asaka.saitama.jp
  chichibu.saitama.jp
  fujimi.saitama.jp
  fujimino.saitama.jp
  fukaya.saitama.jp
  hanno.saitama.jp
  hanyu.saitama.jp
  hasuda.saitama.jp
  hatogaya.saitama.jp
  hatoyama.saitama.jp
  hidaka.saitama.jp
  higashichichibu.saitama.jp
  higashimatsuyama.saitama.jp
  honjo.saitama.jp
  ina.saitama.jp
  iruma.saitama.jp
  iwatsuki.saitama.jp
  kamiizumi.saitama.jp
  kamikawa.saitama.jp
  kamisato.saitama.jp
  kasukabe.saitama.jp
  kawagoe.saitama.jp
  kawaguchi.saitama.jp
  kawajima.saitama.jp
  kazo.saitama.jp
  kitamoto.saitama.jp
  koshigaya.saitama.jp
  kounosu.saitama.jp
  kuki.saitama.jp
  kumagaya.saitama.jp
  matsubushi.saitama.jp
  minano.saitama.jp
  misato.saitama.jp
  miyashiro.saitama.jp
  miyoshi.saitama.jp
  moroyama.saitama.jp
  nagatoro.saitama.jp
  namegawa.saitama.jp
  niiza.saitama.jp
  ogano.saitama.jp
  ogawa.saitama.jp
  ogose.saitama.jp
  okegawa.saitama.jp
  omiya.saitama.jp
  otaki.saitama.jp
  ranzan.saitama.jp
  ryokami.saitama.jp
  saitama.saitama.jp
  sakado.saitama.jp
  satte.saitama.jp
  sayama.saitama.jp
  shiki.saitama.jp
  shiraoka.saitama.jp
  soka.saitama.jp
  sugito.saitama.jp
  toda.saitama.jp
  tokigawa.saitama.jp
  tokorozawa.saitama.jp
  tsurugashima.saitama.jp
  urawa.saitama.jp
  warabi.saitama.jp
  yashio.saitama.jp
  yokoze.saitama.jp
  yono.saitama.jp
  yorii.saitama.jp
  yoshida.saitama.jp
  yoshikawa.saitama.jp
  yoshimi.saitama.jp
  aisho.shiga.jp
  gamo.shiga.jp
  higashiomi.shiga.jp
  hikone.shiga.jp
  koka.shiga.jp
  konan.shiga.jp
  kosei.shiga.jp
  koto.shiga.jp
  kusatsu.shiga.jp
  maibara.shiga.jp
  moriyama.shiga.jp
  nagahama.shiga.jp
  nishiazai.shiga.jp
  notogawa.shiga.jp
  omihachiman.shiga.jp
  otsu.shiga.jp
  ritto.shiga.jp
  ryuoh.shiga.jp
  takashima.shiga.jp
  takatsuki.shiga.jp
  torahime.shiga.jp
  toyosato.shiga.jp
  yasu.shiga.jp
  akagi.shimane.jp
  ama.shimane.jp
  gotsu.shimane.jp
  hamada.shimane.jp
  higashiizumo.shimane.jp
  hikawa.shimane.jp
  hikimi.shimane.jp
  izumo.shimane.jp
  kakinoki.shimane.jp
  masuda.shimane.jp
  matsue.shimane.jp
  misato.shimane.jp
  nishinoshima.shimane.jp
  ohda.shimane.jp
  okinoshima.shimane.jp
  okuizumo.shimane.jp
  shimane.shimane.jp
  tamayu.shimane.jp
  tsuwano.shimane.jp
  unnan.shimane.jp
  yakumo.shimane.jp
  yasugi.shimane.jp
  yatsuka.shimane.jp
  arai.shizuoka.jp
  atami.shizuoka.jp
  fuji.shizuoka.jp
  fujieda.shizuoka.jp
  fujikawa.shizuoka.jp
  fujinomiya.shizuoka.jp
  fukuroi.shizuoka.jp
  gotemba.shizuoka.jp
  haibara.shizuoka.jp
  hamamatsu.shizuoka.jp
  higashiizu.shizuoka.jp
  ito.shizuoka.jp
  iwata.shizuoka.jp
  izu.shizuoka.jp
  izunokuni.shizuoka.jp
  kakegawa.shizuoka.jp
  kannami.shizuoka.jp
  kawanehon.shizuoka.jp
  kawazu.shizuoka.jp
  kikugawa.shizuoka.jp
  kosai.shizuoka.jp
  makinohara.shizuoka.jp
  matsuzaki.shizuoka.jp
  minamiizu.shizuoka.jp
  mishima.shizuoka.jp
  morimachi.shizuoka.jp
  nishiizu.shizuoka.jp
  numazu.shizuoka.jp
  omaezaki.shizuoka.jp
  shimada.shizuoka.jp
  shimizu.shizuoka.jp
  shimoda.shizuoka.jp
  shizuoka.shizuoka.jp
  susono.shizuoka.jp
  yaizu.shizuoka.jp
  yoshida.shizuoka.jp
  ashikaga.tochigi.jp
  bato.tochigi.jp
  haga.tochigi.jp
  ichikai.tochigi.jp
  iwafune.tochigi.jp
  kaminokawa.tochigi.jp
  kanuma.tochigi.jp
  karasuyama.tochigi.jp
  kuroiso.tochigi.jp
  mashiko.tochigi.jp
  mibu.tochigi.jp
  moka.tochigi.jp
  motegi.tochigi.jp
  nasu.tochigi.jp
  nasushiobara.tochigi.jp
  nikko.tochigi.jp
  nishikata.tochigi.jp
  nogi.tochigi.jp
  ohira.tochigi.jp
  ohtawara.tochigi.jp
  oyama.tochigi.jp
  sakura.tochigi.jp
  sano.tochigi.jp
  shimotsuke.tochigi.jp
  shioya.tochigi.jp
  takanezawa.tochigi.jp
  tochigi.tochigi.jp
  tsuga.tochigi.jp
  ujiie.tochigi.jp
  utsunomiya.tochigi.jp
  yaita.tochigi.jp
  aizumi.tokushima.jp
  anan.tokushima.jp
  ichiba.tokushima.jp
  itano.tokushima.jp
  kainan.tokushima.jp
  komatsushima.tokushima.jp
  matsushige.tokushima.jp
  mima.tokushima.jp
  minami.tokushima.jp
  miyoshi.tokushima.jp
  mugi.tokushima.jp
  nakagawa.tokushima.jp
  naruto.tokushima.jp
  sanagochi.tokushima.jp
  shishikui.tokushima.jp
  tokushima.tokushima.jp
  wajiki.tokushima.jp
  adachi.tokyo.jp
  akiruno.tokyo.jp
  akishima.tokyo.jp
  aogashima.tokyo.jp
  arakawa.tokyo.jp
  bunkyo.tokyo.jp
  chiyoda.tokyo.jp
  chofu.tokyo.jp
  chuo.tokyo.jp
  edogawa.tokyo.jp
  fuchu.tokyo.jp
  fussa.tokyo.jp
  hachijo.tokyo.jp
  hachioji.tokyo.jp
  hamura.tokyo.jp
  higashikurume.tokyo.jp
  higashimurayama.tokyo.jp
  higashiyamato.tokyo.jp
  hino.tokyo.jp
  hinode.tokyo.jp
  hinohara.tokyo.jp
  inagi.tokyo.jp
  itabashi.tokyo.jp
  katsushika.tokyo.jp
  kita.tokyo.jp
  kiyose.tokyo.jp
  kodaira.tokyo.jp
  koganei.tokyo.jp
  kokubunji.tokyo.jp
  komae.tokyo.jp
  koto.tokyo.jp
  kouzushima.tokyo.jp
  kunitachi.tokyo.jp
  machida.tokyo.jp
  meguro.tokyo.jp
  minato.tokyo.jp
  mitaka.tokyo.jp
  mizuho.tokyo.jp
  musashimurayama.tokyo.jp
  musashino.tokyo.jp
  nakano.tokyo.jp
  nerima.tokyo.jp
  ogasawara.tokyo.jp
  okutama.tokyo.jp
  ome.tokyo.jp
  oshima.tokyo.jp
  ota.tokyo.jp
  setagaya.tokyo.jp
  shibuya.tokyo.jp
  shinagawa.tokyo.jp
  shinjuku.tokyo.jp
  suginami.tokyo.jp
  sumida.tokyo.jp
  tachikawa.tokyo.jp
  taito.tokyo.jp
  tama.tokyo.jp
  toshima.tokyo.jp
  chizu.tottori.jp
  hino.tottori.jp
  kawahara.tottori.jp
  koge.tottori.jp
  kotoura.tottori.jp
  misasa.tottori.jp
  nanbu.tottori.jp
  nichinan.tottori.jp
  sakaiminato.tottori.jp
  tottori.tottori.jp
  wakasa.tottori.jp
  yazu.tottori.jp
  yonago.tottori.jp
  asahi.toyama.jp
  fuchu.toyama.jp
  fukumitsu.toyama.jp
  funahashi.toyama.jp
  himi.toyama.jp
  imizu.toyama.jp
  inami.toyama.jp
  johana.toyama.jp
  kamiichi.toyama.jp
  kurobe.toyama.jp
  nakaniikawa.toyama.jp
  namerikawa.toyama.jp
  nanto.toyama.jp
  nyuzen.toyama.jp
  oyabe.toyama.jp
  taira.toyama.jp
  takaoka.toyama.jp
  tateyama.toyama.jp
  toga.toyama.jp
  tonami.toyama.jp
  toyama.toyama.jp
  unazuki.toyama.jp
  uozu.toyama.jp
  yamada.toyama.jp
  arida.wakayama.jp
  aridagawa.wakayama.jp
  gobo.wakayama.jp
  hashimoto.wakayama.jp
  hidaka.wakayama.jp
  hirogawa.wakayama.jp
  inami.wakayama.jp
  iwade.wakayama.jp
  kainan.wakayama.jp
  kamitonda.wakayama.jp
  katsuragi.wakayama.jp
  kimino.wakayama.jp
  kinokawa.wakayama.jp
  kitayama.wakayama.jp
  koya.wakayama.jp
  koza.wakayama.jp
  kozagawa.wakayama.jp
  kudoyama.wakayama.jp
  kushimoto.wakayama.jp
  mihama.wakayama.jp
  misato.wakayama.jp
  nachikatsuura.wakayama.jp
  shingu.wakayama.jp
  shirahama.wakayama.jp
  taiji.wakayama.jp
  tanabe.wakayama.jp
  wakayama.wakayama.jp
  yuasa.wakayama.jp
  yura.wakayama.jp
  asahi.yamagata.jp
  funagata.yamagata.jp
  higashine.yamagata.jp
  iide.yamagata.jp
  kahoku.yamagata.jp
  kaminoyama.yamagata.jp
  kaneyama.yamagata.jp
  kawanishi.yamagata.jp
  mamurogawa.yamagata.jp
  mikawa.yamagata.jp
  murayama.yamagata.jp
  nagai.yamagata.jp
  nakayama.yamagata.jp
  nanyo.yamagata.jp
  nishikawa.yamagata.jp
  obanazawa.yamagata.jp
  oe.yamagata.jp
  oguni.yamagata.jp
  ohkura.yamagata.jp
  oishida.yamagata.jp
  sagae.yamagata.jp
  sakata.yamagata.jp
  sakegawa.yamagata.jp
  shinjo.yamagata.jp
  shirataka.yamagata.jp
  shonai.yamagata.jp
  takahata.yamagata.jp
  tendo.yamagata.jp
  tozawa.yamagata.jp
  tsuruoka.yamagata.jp
  yamagata.yamagata.jp
  yamanobe.yamagata.jp
  yonezawa.yamagata.jp
  yuza.yamagata.jp
  abu.yamaguchi.jp
  hagi.yamaguchi.jp
  hikari.yamaguchi.jp
  hofu.yamaguchi.jp
  iwakuni.yamaguchi.jp
  kudamatsu.yamaguchi.jp
  mitou.yamaguchi.jp
  nagato.yamaguchi.jp
  oshima.yamaguchi.jp
  shimonoseki.yamaguchi.jp
  shunan.yamaguchi.jp
  tabuse.yamaguchi.jp
  tokuyama.yamaguchi.jp
  toyota.yamaguchi.jp
  ube.yamaguchi.jp
  yuu.yamaguchi.jp
  chuo.yamanashi.jp
  doshi.yamanashi.jp
  fuefuki.yamanashi.jp
  fujikawa.yamanashi.jp
  fujikawaguchiko.yamanashi.jp
  fujiyoshida.yamanashi.jp
  hayakawa.yamanashi.jp
  hokuto.yamanashi.jp
  ichikawamisato.yamanashi.jp
  kai.yamanashi.jp
  kofu.yamanashi.jp
  koshu.yamanashi.jp
  kosuge.yamanashi.jp
  minami-alps.yamanashi.jp
  minobu.yamanashi.jp
  nakamichi.yamanashi.jp
  nanbu.yamanashi.jp
  narusawa.yamanashi.jp
  nirasaki.yamanashi.jp
  nishikatsura.yamanashi.jp
  oshino.yamanashi.jp
  otsuki.yamanashi.jp
  showa.yamanashi.jp
  tabayama.yamanashi.jp
  tsuru.yamanashi.jp
  uenohara.yamanashi.jp
  yamanakako.yamanashi.jp
  yamanashi.yamanashi.jp
  
  // ke : http://www.kenic.or.ke/index.php/en/ke-domains/ke-domains
  ke
  ac.ke
  co.ke
  go.ke
  info.ke
  me.ke
  mobi.ke
  ne.ke
  or.ke
  sc.ke
  
  // kg : http://www.domain.kg/dmn_n.html
  kg
  org.kg
  net.kg
  com.kg
  edu.kg
  gov.kg
  mil.kg
  
  // kh : http://www.mptc.gov.kh/dns_registration.htm
  *.kh
  
  // ki : http://www.ki/dns/index.html
  ki
  edu.ki
  biz.ki
  net.ki
  org.ki
  gov.ki
  info.ki
  com.ki
  
  // km : https://en.wikipedia.org/wiki/.km
  // http://www.domaine.km/documents/charte.doc
  km
  org.km
  nom.km
  gov.km
  prd.km
  tm.km
  edu.km
  mil.km
  ass.km
  com.km
  // These are only mentioned as proposed suggestions at domaine.km, but
  // https://en.wikipedia.org/wiki/.km says they're available for registration:
  coop.km
  asso.km
  presse.km
  medecin.km
  notaires.km
  pharmaciens.km
  veterinaire.km
  gouv.km
  
  // kn : https://en.wikipedia.org/wiki/.kn
  // http://www.dot.kn/domainRules.html
  kn
  net.kn
  org.kn
  edu.kn
  gov.kn
  
  // kp : http://www.kcce.kp/en_index.php
  kp
  com.kp
  edu.kp
  gov.kp
  org.kp
  rep.kp
  tra.kp
  
  // kr : https://en.wikipedia.org/wiki/.kr
  // see also: http://domain.nida.or.kr/eng/registration.jsp
  kr
  ac.kr
  co.kr
  es.kr
  go.kr
  hs.kr
  kg.kr
  mil.kr
  ms.kr
  ne.kr
  or.kr
  pe.kr
  re.kr
  sc.kr
  // kr geographical names
  busan.kr
  chungbuk.kr
  chungnam.kr
  daegu.kr
  daejeon.kr
  gangwon.kr
  gwangju.kr
  gyeongbuk.kr
  gyeonggi.kr
  gyeongnam.kr
  incheon.kr
  jeju.kr
  jeonbuk.kr
  jeonnam.kr
  seoul.kr
  ulsan.kr
  
  // kw : https://www.nic.kw/policies/
  // Confirmed by registry <nic.tech@citra.gov.kw>
  kw
  com.kw
  edu.kw
  emb.kw
  gov.kw
  ind.kw
  net.kw
  org.kw
  
  // ky : http://www.icta.ky/da_ky_reg_dom.php
  // Confirmed by registry <kysupport@perimeterusa.com> 2008-06-17
  ky
  edu.ky
  gov.ky
  com.ky
  org.ky
  net.ky
  
  // kz : https://en.wikipedia.org/wiki/.kz
  // see also: http://www.nic.kz/rules/index.jsp
  kz
  org.kz
  edu.kz
  net.kz
  gov.kz
  mil.kz
  com.kz
  
  // la : https://en.wikipedia.org/wiki/.la
  // Submitted by registry <gavin.brown@nic.la>
  la
  int.la
  net.la
  info.la
  edu.la
  gov.la
  per.la
  com.la
  org.la
  
  // lb : https://en.wikipedia.org/wiki/.lb
  // Submitted by registry <randy@psg.com>
  lb
  com.lb
  edu.lb
  gov.lb
  net.lb
  org.lb
  
  // lc : https://en.wikipedia.org/wiki/.lc
  // see also: http://www.nic.lc/rules.htm
  lc
  com.lc
  net.lc
  co.lc
  org.lc
  edu.lc
  gov.lc
  
  // li : https://en.wikipedia.org/wiki/.li
  li
  
  // lk : http://www.nic.lk/seclevpr.html
  lk
  gov.lk
  sch.lk
  net.lk
  int.lk
  com.lk
  org.lk
  edu.lk
  ngo.lk
  soc.lk
  web.lk
  ltd.lk
  assn.lk
  grp.lk
  hotel.lk
  ac.lk
  
  // lr : http://psg.com/dns/lr/lr.txt
  // Submitted by registry <randy@psg.com>
  lr
  com.lr
  edu.lr
  gov.lr
  org.lr
  net.lr
  
  // ls : http://www.nic.ls/
  // Confirmed by registry <lsadmin@nic.ls>
  ls
  ac.ls
  biz.ls
  co.ls
  edu.ls
  gov.ls
  info.ls
  net.ls
  org.ls
  sc.ls
  
  // lt : https://en.wikipedia.org/wiki/.lt
  lt
  // gov.lt : http://www.gov.lt/index_en.php
  gov.lt
  
  // lu : http://www.dns.lu/en/
  lu
  
  // lv : http://www.nic.lv/DNS/En/generic.php
  lv
  com.lv
  edu.lv
  gov.lv
  org.lv
  mil.lv
  id.lv
  net.lv
  asn.lv
  conf.lv
  
  // ly : http://www.nic.ly/regulations.php
  ly
  com.ly
  net.ly
  gov.ly
  plc.ly
  edu.ly
  sch.ly
  med.ly
  org.ly
  id.ly
  
  // ma : https://en.wikipedia.org/wiki/.ma
  // http://www.anrt.ma/fr/admin/download/upload/file_fr782.pdf
  ma
  co.ma
  net.ma
  gov.ma
  org.ma
  ac.ma
  press.ma
  
  // mc : http://www.nic.mc/
  mc
  tm.mc
  asso.mc
  
  // md : https://en.wikipedia.org/wiki/.md
  md
  
  // me : https://en.wikipedia.org/wiki/.me
  me
  co.me
  net.me
  org.me
  edu.me
  ac.me
  gov.me
  its.me
  priv.me
  
  // mg : http://nic.mg/nicmg/?page_id=39
  mg
  org.mg
  nom.mg
  gov.mg
  prd.mg
  tm.mg
  edu.mg
  mil.mg
  com.mg
  co.mg
  
  // mh : https://en.wikipedia.org/wiki/.mh
  mh
  
  // mil : https://en.wikipedia.org/wiki/.mil
  mil
  
  // mk : https://en.wikipedia.org/wiki/.mk
  // see also: http://dns.marnet.net.mk/postapka.php
  mk
  com.mk
  org.mk
  net.mk
  edu.mk
  gov.mk
  inf.mk
  name.mk
  
  // ml : http://www.gobin.info/domainname/ml-template.doc
  // see also: https://en.wikipedia.org/wiki/.ml
  ml
  com.ml
  edu.ml
  gouv.ml
  gov.ml
  net.ml
  org.ml
  presse.ml
  
  // mm : https://en.wikipedia.org/wiki/.mm
  *.mm
  
  // mn : https://en.wikipedia.org/wiki/.mn
  mn
  gov.mn
  edu.mn
  org.mn
  
  // mo : http://www.monic.net.mo/
  mo
  com.mo
  net.mo
  org.mo
  edu.mo
  gov.mo
  
  // mobi : https://en.wikipedia.org/wiki/.mobi
  mobi
  
  // mp : http://www.dot.mp/
  // Confirmed by registry <dcamacho@saipan.com> 2008-06-17
  mp
  
  // mq : https://en.wikipedia.org/wiki/.mq
  mq
  
  // mr : https://en.wikipedia.org/wiki/.mr
  mr
  gov.mr
  
  // ms : http://www.nic.ms/pdf/MS_Domain_Name_Rules.pdf
  ms
  com.ms
  edu.ms
  gov.ms
  net.ms
  org.ms
  
  // mt : https://www.nic.org.mt/go/policy
  // Submitted by registry <help@nic.org.mt>
  mt
  com.mt
  edu.mt
  net.mt
  org.mt
  
  // mu : https://en.wikipedia.org/wiki/.mu
  mu
  com.mu
  net.mu
  org.mu
  gov.mu
  ac.mu
  co.mu
  or.mu
  
  // museum : http://about.museum/naming/
  // http://index.museum/
  museum
  academy.museum
  agriculture.museum
  air.museum
  airguard.museum
  alabama.museum
  alaska.museum
  amber.museum
  ambulance.museum
  american.museum
  americana.museum
  americanantiques.museum
  americanart.museum
  amsterdam.museum
  and.museum
  annefrank.museum
  anthro.museum
  anthropology.museum
  antiques.museum
  aquarium.museum
  arboretum.museum
  archaeological.museum
  archaeology.museum
  architecture.museum
  art.museum
  artanddesign.museum
  artcenter.museum
  artdeco.museum
  arteducation.museum
  artgallery.museum
  arts.museum
  artsandcrafts.museum
  asmatart.museum
  assassination.museum
  assisi.museum
  association.museum
  astronomy.museum
  atlanta.museum
  austin.museum
  australia.museum
  automotive.museum
  aviation.museum
  axis.museum
  badajoz.museum
  baghdad.museum
  bahn.museum
  bale.museum
  baltimore.museum
  barcelona.museum
  baseball.museum
  basel.museum
  baths.museum
  bauern.museum
  beauxarts.museum
  beeldengeluid.museum
  bellevue.museum
  bergbau.museum
  berkeley.museum
  berlin.museum
  bern.museum
  bible.museum
  bilbao.museum
  bill.museum
  birdart.museum
  birthplace.museum
  bonn.museum
  boston.museum
  botanical.museum
  botanicalgarden.museum
  botanicgarden.museum
  botany.museum
  brandywinevalley.museum
  brasil.museum
  bristol.museum
  british.museum
  britishcolumbia.museum
  broadcast.museum
  brunel.museum
  brussel.museum
  brussels.museum
  bruxelles.museum
  building.museum
  burghof.museum
  bus.museum
  bushey.museum
  cadaques.museum
  california.museum
  cambridge.museum
  can.museum
  canada.museum
  capebreton.museum
  carrier.museum
  cartoonart.museum
  casadelamoneda.museum
  castle.museum
  castres.museum
  celtic.museum
  center.museum
  chattanooga.museum
  cheltenham.museum
  chesapeakebay.museum
  chicago.museum
  children.museum
  childrens.museum
  childrensgarden.museum
  chiropractic.museum
  chocolate.museum
  christiansburg.museum
  cincinnati.museum
  cinema.museum
  circus.museum
  civilisation.museum
  civilization.museum
  civilwar.museum
  clinton.museum
  clock.museum
  coal.museum
  coastaldefence.museum
  cody.museum
  coldwar.museum
  collection.museum
  colonialwilliamsburg.museum
  coloradoplateau.museum
  columbia.museum
  columbus.museum
  communication.museum
  communications.museum
  community.museum
  computer.museum
  computerhistory.museum
  xn--comunicaes-v6a2o.museum
  contemporary.museum
  contemporaryart.museum
  convent.museum
  copenhagen.museum
  corporation.museum
  xn--correios-e-telecomunicaes-ghc29a.museum
  corvette.museum
  costume.museum
  countryestate.museum
  county.museum
  crafts.museum
  cranbrook.museum
  creation.museum
  cultural.museum
  culturalcenter.museum
  culture.museum
  cyber.museum
  cymru.museum
  dali.museum
  dallas.museum
  database.museum
  ddr.museum
  decorativearts.museum
  delaware.museum
  delmenhorst.museum
  denmark.museum
  depot.museum
  design.museum
  detroit.museum
  dinosaur.museum
  discovery.museum
  dolls.museum
  donostia.museum
  durham.museum
  eastafrica.museum
  eastcoast.museum
  education.museum
  educational.museum
  egyptian.museum
  eisenbahn.museum
  elburg.museum
  elvendrell.museum
  embroidery.museum
  encyclopedic.museum
  england.museum
  entomology.museum
  environment.museum
  environmentalconservation.museum
  epilepsy.museum
  essex.museum
  estate.museum
  ethnology.museum
  exeter.museum
  exhibition.museum
  family.museum
  farm.museum
  farmequipment.museum
  farmers.museum
  farmstead.museum
  field.museum
  figueres.museum
  filatelia.museum
  film.museum
  fineart.museum
  finearts.museum
  finland.museum
  flanders.museum
  florida.museum
  force.museum
  fortmissoula.museum
  fortworth.museum
  foundation.museum
  francaise.museum
  frankfurt.museum
  franziskaner.museum
  freemasonry.museum
  freiburg.museum
  fribourg.museum
  frog.museum
  fundacio.museum
  furniture.museum
  gallery.museum
  garden.museum
  gateway.museum
  geelvinck.museum
  gemological.museum
  geology.museum
  georgia.museum
  giessen.museum
  glas.museum
  glass.museum
  gorge.museum
  grandrapids.museum
  graz.museum
  guernsey.museum
  halloffame.museum
  hamburg.museum
  handson.museum
  harvestcelebration.museum
  hawaii.museum
  health.museum
  heimatunduhren.museum
  hellas.museum
  helsinki.museum
  hembygdsforbund.museum
  heritage.museum
  histoire.museum
  historical.museum
  historicalsociety.museum
  historichouses.museum
  historisch.museum
  historisches.museum
  history.museum
  historyofscience.museum
  horology.museum
  house.museum
  humanities.museum
  illustration.museum
  imageandsound.museum
  indian.museum
  indiana.museum
  indianapolis.museum
  indianmarket.museum
  intelligence.museum
  interactive.museum
  iraq.museum
  iron.museum
  isleofman.museum
  jamison.museum
  jefferson.museum
  jerusalem.museum
  jewelry.museum
  jewish.museum
  jewishart.museum
  jfk.museum
  journalism.museum
  judaica.museum
  judygarland.museum
  juedisches.museum
  juif.museum
  karate.museum
  karikatur.museum
  kids.museum
  koebenhavn.museum
  koeln.museum
  kunst.museum
  kunstsammlung.museum
  kunstunddesign.museum
  labor.museum
  labour.museum
  lajolla.museum
  lancashire.museum
  landes.museum
  lans.museum
  xn--lns-qla.museum
  larsson.museum
  lewismiller.museum
  lincoln.museum
  linz.museum
  living.museum
  livinghistory.museum
  localhistory.museum
  london.museum
  losangeles.museum
  louvre.museum
  loyalist.museum
  lucerne.museum
  luxembourg.museum
  luzern.museum
  mad.museum
  madrid.museum
  mallorca.museum
  manchester.museum
  mansion.museum
  mansions.museum
  manx.museum
  marburg.museum
  maritime.museum
  maritimo.museum
  maryland.museum
  marylhurst.museum
  media.museum
  medical.museum
  medizinhistorisches.museum
  meeres.museum
  memorial.museum
  mesaverde.museum
  michigan.museum
  midatlantic.museum
  military.museum
  mill.museum
  miners.museum
  mining.museum
  minnesota.museum
  missile.museum
  missoula.museum
  modern.museum
  moma.museum
  money.museum
  monmouth.museum
  monticello.museum
  montreal.museum
  moscow.museum
  motorcycle.museum
  muenchen.museum
  muenster.museum
  mulhouse.museum
  muncie.museum
  museet.museum
  museumcenter.museum
  museumvereniging.museum
  music.museum
  national.museum
  nationalfirearms.museum
  nationalheritage.museum
  nativeamerican.museum
  naturalhistory.museum
  naturalhistorymuseum.museum
  naturalsciences.museum
  nature.museum
  naturhistorisches.museum
  natuurwetenschappen.museum
  naumburg.museum
  naval.museum
  nebraska.museum
  neues.museum
  newhampshire.museum
  newjersey.museum
  newmexico.museum
  newport.museum
  newspaper.museum
  newyork.museum
  niepce.museum
  norfolk.museum
  north.museum
  nrw.museum
  nuernberg.museum
  nuremberg.museum
  nyc.museum
  nyny.museum
  oceanographic.museum
  oceanographique.museum
  omaha.museum
  online.museum
  ontario.museum
  openair.museum
  oregon.museum
  oregontrail.museum
  otago.museum
  oxford.museum
  pacific.museum
  paderborn.museum
  palace.museum
  paleo.museum
  palmsprings.museum
  panama.museum
  paris.museum
  pasadena.museum
  pharmacy.museum
  philadelphia.museum
  philadelphiaarea.museum
  philately.museum
  phoenix.museum
  photography.museum
  pilots.museum
  pittsburgh.museum
  planetarium.museum
  plantation.museum
  plants.museum
  plaza.museum
  portal.museum
  portland.museum
  portlligat.museum
  posts-and-telecommunications.museum
  preservation.museum
  presidio.museum
  press.museum
  project.museum
  public.museum
  pubol.museum
  quebec.museum
  railroad.museum
  railway.museum
  research.museum
  resistance.museum
  riodejaneiro.museum
  rochester.museum
  rockart.museum
  roma.museum
  russia.museum
  saintlouis.museum
  salem.museum
  salvadordali.museum
  salzburg.museum
  sandiego.museum
  sanfrancisco.museum
  santabarbara.museum
  santacruz.museum
  santafe.museum
  saskatchewan.museum
  satx.museum
  savannahga.museum
  schlesisches.museum
  schoenbrunn.museum
  schokoladen.museum
  school.museum
  schweiz.museum
  science.museum
  scienceandhistory.museum
  scienceandindustry.museum
  sciencecenter.museum
  sciencecenters.museum
  science-fiction.museum
  sciencehistory.museum
  sciences.museum
  sciencesnaturelles.museum
  scotland.museum
  seaport.museum
  settlement.museum
  settlers.museum
  shell.museum
  sherbrooke.museum
  sibenik.museum
  silk.museum
  ski.museum
  skole.museum
  society.museum
  sologne.museum
  soundandvision.museum
  southcarolina.museum
  southwest.museum
  space.museum
  spy.museum
  square.museum
  stadt.museum
  stalbans.museum
  starnberg.museum
  state.museum
  stateofdelaware.museum
  station.museum
  steam.museum
  steiermark.museum
  stjohn.museum
  stockholm.museum
  stpetersburg.museum
  stuttgart.museum
  suisse.museum
  surgeonshall.museum
  surrey.museum
  svizzera.museum
  sweden.museum
  sydney.museum
  tank.museum
  tcm.museum
  technology.museum
  telekommunikation.museum
  television.museum
  texas.museum
  textile.museum
  theater.museum
  time.museum
  timekeeping.museum
  topology.museum
  torino.museum
  touch.museum
  town.museum
  transport.museum
  tree.museum
  trolley.museum
  trust.museum
  trustee.museum
  uhren.museum
  ulm.museum
  undersea.museum
  university.museum
  usa.museum
  usantiques.museum
  usarts.museum
  uscountryestate.museum
  usculture.museum
  usdecorativearts.museum
  usgarden.museum
  ushistory.museum
  ushuaia.museum
  uslivinghistory.museum
  utah.museum
  uvic.museum
  valley.museum
  vantaa.museum
  versailles.museum
  viking.museum
  village.museum
  virginia.museum
  virtual.museum
  virtuel.museum
  vlaanderen.museum
  volkenkunde.museum
  wales.museum
  wallonie.museum
  war.museum
  washingtondc.museum
  watchandclock.museum
  watch-and-clock.museum
  western.museum
  westfalen.museum
  whaling.museum
  wildlife.museum
  williamsburg.museum
  windmill.museum
  workshop.museum
  york.museum
  yorkshire.museum
  yosemite.museum
  youth.museum
  zoological.museum
  zoology.museum
  xn--9dbhblg6di.museum
  xn--h1aegh.museum
  
  // mv : https://en.wikipedia.org/wiki/.mv
  // "mv" included because, contra Wikipedia, google.mv exists.
  mv
  aero.mv
  biz.mv
  com.mv
  coop.mv
  edu.mv
  gov.mv
  info.mv
  int.mv
  mil.mv
  museum.mv
  name.mv
  net.mv
  org.mv
  pro.mv
  
  // mw : http://www.registrar.mw/
  mw
  ac.mw
  biz.mw
  co.mw
  com.mw
  coop.mw
  edu.mw
  gov.mw
  int.mw
  museum.mw
  net.mw
  org.mw
  
  // mx : http://www.nic.mx/
  // Submitted by registry <farias@nic.mx>
  mx
  com.mx
  org.mx
  gob.mx
  edu.mx
  net.mx
  
  // my : http://www.mynic.net.my/
  my
  com.my
  net.my
  org.my
  gov.my
  edu.my
  mil.my
  name.my
  
  // mz : http://www.uem.mz/
  // Submitted by registry <antonio@uem.mz>
  mz
  ac.mz
  adv.mz
  co.mz
  edu.mz
  gov.mz
  mil.mz
  net.mz
  org.mz
  
  // na : http://www.na-nic.com.na/
  // http://www.info.na/domain/
  na
  info.na
  pro.na
  name.na
  school.na
  or.na
  dr.na
  us.na
  mx.na
  ca.na
  in.na
  cc.na
  tv.na
  ws.na
  mobi.na
  co.na
  com.na
  org.na
  
  // name : has 2nd-level tlds, but there's no list of them
  name
  
  // nc : http://www.cctld.nc/
  nc
  asso.nc
  nom.nc
  
  // ne : https://en.wikipedia.org/wiki/.ne
  ne
  
  // net : https://en.wikipedia.org/wiki/.net
  net
  
  // nf : https://en.wikipedia.org/wiki/.nf
  nf
  com.nf
  net.nf
  per.nf
  rec.nf
  web.nf
  arts.nf
  firm.nf
  info.nf
  other.nf
  store.nf
  
  // ng : http://www.nira.org.ng/index.php/join-us/register-ng-domain/189-nira-slds
  ng
  com.ng
  edu.ng
  gov.ng
  i.ng
  mil.ng
  mobi.ng
  name.ng
  net.ng
  org.ng
  sch.ng
  
  // ni : http://www.nic.ni/
  ni
  ac.ni
  biz.ni
  co.ni
  com.ni
  edu.ni
  gob.ni
  in.ni
  info.ni
  int.ni
  mil.ni
  net.ni
  nom.ni
  org.ni
  web.ni
  
  // nl : https://en.wikipedia.org/wiki/.nl
  //      https://www.sidn.nl/
  //      ccTLD for the Netherlands
  nl
  
  // no : http://www.norid.no/regelverk/index.en.html
  // The Norwegian registry has declined to notify us of updates. The web pages
  // referenced below are the official source of the data. There is also an
  // announce mailing list:
  // https://postlister.uninett.no/sympa/info/norid-diskusjon
  no
  // Norid generic domains : http://www.norid.no/regelverk/vedlegg-c.en.html
  fhs.no
  vgs.no
  fylkesbibl.no
  folkebibl.no
  museum.no
  idrett.no
  priv.no
  // Non-Norid generic domains : http://www.norid.no/regelverk/vedlegg-d.en.html
  mil.no
  stat.no
  dep.no
  kommune.no
  herad.no
  // no geographical names : http://www.norid.no/regelverk/vedlegg-b.en.html
  // counties
  aa.no
  ah.no
  bu.no
  fm.no
  hl.no
  hm.no
  jan-mayen.no
  mr.no
  nl.no
  nt.no
  of.no
  ol.no
  oslo.no
  rl.no
  sf.no
  st.no
  svalbard.no
  tm.no
  tr.no
  va.no
  vf.no
  // primary and lower secondary schools per county
  gs.aa.no
  gs.ah.no
  gs.bu.no
  gs.fm.no
  gs.hl.no
  gs.hm.no
  gs.jan-mayen.no
  gs.mr.no
  gs.nl.no
  gs.nt.no
  gs.of.no
  gs.ol.no
  gs.oslo.no
  gs.rl.no
  gs.sf.no
  gs.st.no
  gs.svalbard.no
  gs.tm.no
  gs.tr.no
  gs.va.no
  gs.vf.no
  // cities
  akrehamn.no
  xn--krehamn-dxa.no
  algard.no
  xn--lgrd-poac.no
  arna.no
  brumunddal.no
  bryne.no
  bronnoysund.no
  xn--brnnysund-m8ac.no
  drobak.no
  xn--drbak-wua.no
  egersund.no
  fetsund.no
  floro.no
  xn--flor-jra.no
  fredrikstad.no
  hokksund.no
  honefoss.no
  xn--hnefoss-q1a.no
  jessheim.no
  jorpeland.no
  xn--jrpeland-54a.no
  kirkenes.no
  kopervik.no
  krokstadelva.no
  langevag.no
  xn--langevg-jxa.no
  leirvik.no
  mjondalen.no
  xn--mjndalen-64a.no
  mo-i-rana.no
  mosjoen.no
  xn--mosjen-eya.no
  nesoddtangen.no
  orkanger.no
  osoyro.no
  xn--osyro-wua.no
  raholt.no
  xn--rholt-mra.no
  sandnessjoen.no
  xn--sandnessjen-ogb.no
  skedsmokorset.no
  slattum.no
  spjelkavik.no
  stathelle.no
  stavern.no
  stjordalshalsen.no
  xn--stjrdalshalsen-sqb.no
  tananger.no
  tranby.no
  vossevangen.no
  // communities
  afjord.no
  xn--fjord-lra.no
  agdenes.no
  al.no
  xn--l-1fa.no
  alesund.no
  xn--lesund-hua.no
  alstahaug.no
  alta.no
  xn--lt-liac.no
  alaheadju.no
  xn--laheadju-7ya.no
  alvdal.no
  amli.no
  xn--mli-tla.no
  amot.no
  xn--mot-tla.no
  andebu.no
  andoy.no
  xn--andy-ira.no
  andasuolo.no
  ardal.no
  xn--rdal-poa.no
  aremark.no
  arendal.no
  xn--s-1fa.no
  aseral.no
  xn--seral-lra.no
  asker.no
  askim.no
  askvoll.no
  askoy.no
  xn--asky-ira.no
  asnes.no
  xn--snes-poa.no
  audnedaln.no
  aukra.no
  aure.no
  aurland.no
  aurskog-holand.no
  xn--aurskog-hland-jnb.no
  austevoll.no
  austrheim.no
  averoy.no
  xn--avery-yua.no
  balestrand.no
  ballangen.no
  balat.no
  xn--blt-elab.no
  balsfjord.no
  bahccavuotna.no
  xn--bhccavuotna-k7a.no
  bamble.no
  bardu.no
  beardu.no
  beiarn.no
  bajddar.no
  xn--bjddar-pta.no
  baidar.no
  xn--bidr-5nac.no
  berg.no
  bergen.no
  berlevag.no
  xn--berlevg-jxa.no
  bearalvahki.no
  xn--bearalvhki-y4a.no
  bindal.no
  birkenes.no
  bjarkoy.no
  xn--bjarky-fya.no
  bjerkreim.no
  bjugn.no
  bodo.no
  xn--bod-2na.no
  badaddja.no
  xn--bdddj-mrabd.no
  budejju.no
  bokn.no
  bremanger.no
  bronnoy.no
  xn--brnny-wuac.no
  bygland.no
  bykle.no
  barum.no
  xn--brum-voa.no
  bo.telemark.no
  xn--b-5ga.telemark.no
  bo.nordland.no
  xn--b-5ga.nordland.no
  bievat.no
  xn--bievt-0qa.no
  bomlo.no
  xn--bmlo-gra.no
  batsfjord.no
  xn--btsfjord-9za.no
  bahcavuotna.no
  xn--bhcavuotna-s4a.no
  dovre.no
  drammen.no
  drangedal.no
  dyroy.no
  xn--dyry-ira.no
  donna.no
  xn--dnna-gra.no
  eid.no
  eidfjord.no
  eidsberg.no
  eidskog.no
  eidsvoll.no
  eigersund.no
  elverum.no
  enebakk.no
  engerdal.no
  etne.no
  etnedal.no
  evenes.no
  evenassi.no
  xn--eveni-0qa01ga.no
  evje-og-hornnes.no
  farsund.no
  fauske.no
  fuossko.no
  fuoisku.no
  fedje.no
  fet.no
  finnoy.no
  xn--finny-yua.no
  fitjar.no
  fjaler.no
  fjell.no
  flakstad.no
  flatanger.no
  flekkefjord.no
  flesberg.no
  flora.no
  fla.no
  xn--fl-zia.no
  folldal.no
  forsand.no
  fosnes.no
  frei.no
  frogn.no
  froland.no
  frosta.no
  frana.no
  xn--frna-woa.no
  froya.no
  xn--frya-hra.no
  fusa.no
  fyresdal.no
  forde.no
  xn--frde-gra.no
  gamvik.no
  gangaviika.no
  xn--ggaviika-8ya47h.no
  gaular.no
  gausdal.no
  gildeskal.no
  xn--gildeskl-g0a.no
  giske.no
  gjemnes.no
  gjerdrum.no
  gjerstad.no
  gjesdal.no
  gjovik.no
  xn--gjvik-wua.no
  gloppen.no
  gol.no
  gran.no
  grane.no
  granvin.no
  gratangen.no
  grimstad.no
  grong.no
  kraanghke.no
  xn--kranghke-b0a.no
  grue.no
  gulen.no
  hadsel.no
  halden.no
  halsa.no
  hamar.no
  hamaroy.no
  habmer.no
  xn--hbmer-xqa.no
  hapmir.no
  xn--hpmir-xqa.no
  hammerfest.no
  hammarfeasta.no
  xn--hmmrfeasta-s4ac.no
  haram.no
  hareid.no
  harstad.no
  hasvik.no
  aknoluokta.no
  xn--koluokta-7ya57h.no
  hattfjelldal.no
  aarborte.no
  haugesund.no
  hemne.no
  hemnes.no
  hemsedal.no
  heroy.more-og-romsdal.no
  xn--hery-ira.xn--mre-og-romsdal-qqb.no
  heroy.nordland.no
  xn--hery-ira.nordland.no
  hitra.no
  hjartdal.no
  hjelmeland.no
  hobol.no
  xn--hobl-ira.no
  hof.no
  hol.no
  hole.no
  holmestrand.no
  holtalen.no
  xn--holtlen-hxa.no
  hornindal.no
  horten.no
  hurdal.no
  hurum.no
  hvaler.no
  hyllestad.no
  hagebostad.no
  xn--hgebostad-g3a.no
  hoyanger.no
  xn--hyanger-q1a.no
  hoylandet.no
  xn--hylandet-54a.no
  ha.no
  xn--h-2fa.no
  ibestad.no
  inderoy.no
  xn--indery-fya.no
  iveland.no
  jevnaker.no
  jondal.no
  jolster.no
  xn--jlster-bya.no
  karasjok.no
  karasjohka.no
  xn--krjohka-hwab49j.no
  karlsoy.no
  galsa.no
  xn--gls-elac.no
  karmoy.no
  xn--karmy-yua.no
  kautokeino.no
  guovdageaidnu.no
  klepp.no
  klabu.no
  xn--klbu-woa.no
  kongsberg.no
  kongsvinger.no
  kragero.no
  xn--krager-gya.no
  kristiansand.no
  kristiansund.no
  krodsherad.no
  xn--krdsherad-m8a.no
  kvalsund.no
  rahkkeravju.no
  xn--rhkkervju-01af.no
  kvam.no
  kvinesdal.no
  kvinnherad.no
  kviteseid.no
  kvitsoy.no
  xn--kvitsy-fya.no
  kvafjord.no
  xn--kvfjord-nxa.no
  giehtavuoatna.no
  kvanangen.no
  xn--kvnangen-k0a.no
  navuotna.no
  xn--nvuotna-hwa.no
  kafjord.no
  xn--kfjord-iua.no
  gaivuotna.no
  xn--givuotna-8ya.no
  larvik.no
  lavangen.no
  lavagis.no
  loabat.no
  xn--loabt-0qa.no
  lebesby.no
  davvesiida.no
  leikanger.no
  leirfjord.no
  leka.no
  leksvik.no
  lenvik.no
  leangaviika.no
  xn--leagaviika-52b.no
  lesja.no
  levanger.no
  lier.no
  lierne.no
  lillehammer.no
  lillesand.no
  lindesnes.no
  lindas.no
  xn--linds-pra.no
  lom.no
  loppa.no
  lahppi.no
  xn--lhppi-xqa.no
  lund.no
  lunner.no
  luroy.no
  xn--lury-ira.no
  luster.no
  lyngdal.no
  lyngen.no
  ivgu.no
  lardal.no
  lerdal.no
  xn--lrdal-sra.no
  lodingen.no
  xn--ldingen-q1a.no
  lorenskog.no
  xn--lrenskog-54a.no
  loten.no
  xn--lten-gra.no
  malvik.no
  masoy.no
  xn--msy-ula0h.no
  muosat.no
  xn--muost-0qa.no
  mandal.no
  marker.no
  marnardal.no
  masfjorden.no
  meland.no
  meldal.no
  melhus.no
  meloy.no
  xn--mely-ira.no
  meraker.no
  xn--merker-kua.no
  moareke.no
  xn--moreke-jua.no
  midsund.no
  midtre-gauldal.no
  modalen.no
  modum.no
  molde.no
  moskenes.no
  moss.no
  mosvik.no
  malselv.no
  xn--mlselv-iua.no
  malatvuopmi.no
  xn--mlatvuopmi-s4a.no
  namdalseid.no
  aejrie.no
  namsos.no
  namsskogan.no
  naamesjevuemie.no
  xn--nmesjevuemie-tcba.no
  laakesvuemie.no
  nannestad.no
  narvik.no
  narviika.no
  naustdal.no
  nedre-eiker.no
  nes.akershus.no
  nes.buskerud.no
  nesna.no
  nesodden.no
  nesseby.no
  unjarga.no
  xn--unjrga-rta.no
  nesset.no
  nissedal.no
  nittedal.no
  nord-aurdal.no
  nord-fron.no
  nord-odal.no
  norddal.no
  nordkapp.no
  davvenjarga.no
  xn--davvenjrga-y4a.no
  nordre-land.no
  nordreisa.no
  raisa.no
  xn--risa-5na.no
  nore-og-uvdal.no
  notodden.no
  naroy.no
  xn--nry-yla5g.no
  notteroy.no
  xn--nttery-byae.no
  odda.no
  oksnes.no
  xn--ksnes-uua.no
  oppdal.no
  oppegard.no
  xn--oppegrd-ixa.no
  orkdal.no
  orland.no
  xn--rland-uua.no
  orskog.no
  xn--rskog-uua.no
  orsta.no
  xn--rsta-fra.no
  os.hedmark.no
  os.hordaland.no
  osen.no
  osteroy.no
  xn--ostery-fya.no
  ostre-toten.no
  xn--stre-toten-zcb.no
  overhalla.no
  ovre-eiker.no
  xn--vre-eiker-k8a.no
  oyer.no
  xn--yer-zna.no
  oygarden.no
  xn--ygarden-p1a.no
  oystre-slidre.no
  xn--ystre-slidre-ujb.no
  porsanger.no
  porsangu.no
  xn--porsgu-sta26f.no
  porsgrunn.no
  radoy.no
  xn--rady-ira.no
  rakkestad.no
  rana.no
  ruovat.no
  randaberg.no
  rauma.no
  rendalen.no
  rennebu.no
  rennesoy.no
  xn--rennesy-v1a.no
  rindal.no
  ringebu.no
  ringerike.no
  ringsaker.no
  rissa.no
  risor.no
  xn--risr-ira.no
  roan.no
  rollag.no
  rygge.no
  ralingen.no
  xn--rlingen-mxa.no
  rodoy.no
  xn--rdy-0nab.no
  romskog.no
  xn--rmskog-bya.no
  roros.no
  xn--rros-gra.no
  rost.no
  xn--rst-0na.no
  royken.no
  xn--ryken-vua.no
  royrvik.no
  xn--ryrvik-bya.no
  rade.no
  xn--rde-ula.no
  salangen.no
  siellak.no
  saltdal.no
  salat.no
  xn--slt-elab.no
  xn--slat-5na.no
  samnanger.no
  sande.more-og-romsdal.no
  sande.xn--mre-og-romsdal-qqb.no
  sande.vestfold.no
  sandefjord.no
  sandnes.no
  sandoy.no
  xn--sandy-yua.no
  sarpsborg.no
  sauda.no
  sauherad.no
  sel.no
  selbu.no
  selje.no
  seljord.no
  sigdal.no
  siljan.no
  sirdal.no
  skaun.no
  skedsmo.no
  ski.no
  skien.no
  skiptvet.no
  skjervoy.no
  xn--skjervy-v1a.no
  skierva.no
  xn--skierv-uta.no
  skjak.no
  xn--skjk-soa.no
  skodje.no
  skanland.no
  xn--sknland-fxa.no
  skanit.no
  xn--sknit-yqa.no
  smola.no
  xn--smla-hra.no
  snillfjord.no
  snasa.no
  xn--snsa-roa.no
  snoasa.no
  snaase.no
  xn--snase-nra.no
  sogndal.no
  sokndal.no
  sola.no
  solund.no
  songdalen.no
  sortland.no
  spydeberg.no
  stange.no
  stavanger.no
  steigen.no
  steinkjer.no
  stjordal.no
  xn--stjrdal-s1a.no
  stokke.no
  stor-elvdal.no
  stord.no
  stordal.no
  storfjord.no
  omasvuotna.no
  strand.no
  stranda.no
  stryn.no
  sula.no
  suldal.no
  sund.no
  sunndal.no
  surnadal.no
  sveio.no
  svelvik.no
  sykkylven.no
  sogne.no
  xn--sgne-gra.no
  somna.no
  xn--smna-gra.no
  sondre-land.no
  xn--sndre-land-0cb.no
  sor-aurdal.no
  xn--sr-aurdal-l8a.no
  sor-fron.no
  xn--sr-fron-q1a.no
  sor-odal.no
  xn--sr-odal-q1a.no
  sor-varanger.no
  xn--sr-varanger-ggb.no
  matta-varjjat.no
  xn--mtta-vrjjat-k7af.no
  sorfold.no
  xn--srfold-bya.no
  sorreisa.no
  xn--srreisa-q1a.no
  sorum.no
  xn--srum-gra.no
  tana.no
  deatnu.no
  time.no
  tingvoll.no
  tinn.no
  tjeldsund.no
  dielddanuorri.no
  tjome.no
  xn--tjme-hra.no
  tokke.no
  tolga.no
  torsken.no
  tranoy.no
  xn--trany-yua.no
  tromso.no
  xn--troms-zua.no
  tromsa.no
  romsa.no
  trondheim.no
  troandin.no
  trysil.no
  trana.no
  xn--trna-woa.no
  trogstad.no
  xn--trgstad-r1a.no
  tvedestrand.no
  tydal.no
  tynset.no
  tysfjord.no
  divtasvuodna.no
  divttasvuotna.no
  tysnes.no
  tysvar.no
  xn--tysvr-vra.no
  tonsberg.no
  xn--tnsberg-q1a.no
  ullensaker.no
  ullensvang.no
  ulvik.no
  utsira.no
  vadso.no
  xn--vads-jra.no
  cahcesuolo.no
  xn--hcesuolo-7ya35b.no
  vaksdal.no
  valle.no
  vang.no
  vanylven.no
  vardo.no
  xn--vard-jra.no
  varggat.no
  xn--vrggt-xqad.no
  vefsn.no
  vaapste.no
  vega.no
  vegarshei.no
  xn--vegrshei-c0a.no
  vennesla.no
  verdal.no
  verran.no
  vestby.no
  vestnes.no
  vestre-slidre.no
  vestre-toten.no
  vestvagoy.no
  xn--vestvgy-ixa6o.no
  vevelstad.no
  vik.no
  vikna.no
  vindafjord.no
  volda.no
  voss.no
  varoy.no
  xn--vry-yla5g.no
  vagan.no
  xn--vgan-qoa.no
  voagat.no
  vagsoy.no
  xn--vgsy-qoa0j.no
  vaga.no
  xn--vg-yiab.no
  valer.ostfold.no
  xn--vler-qoa.xn--stfold-9xa.no
  valer.hedmark.no
  xn--vler-qoa.hedmark.no
  
  // np : http://www.mos.com.np/register.html
  *.np
  
  // nr : http://cenpac.net.nr/dns/index.html
  // Submitted by registry <technician@cenpac.net.nr>
  nr
  biz.nr
  info.nr
  gov.nr
  edu.nr
  org.nr
  net.nr
  com.nr
  
  // nu : https://en.wikipedia.org/wiki/.nu
  nu
  
  // nz : https://en.wikipedia.org/wiki/.nz
  // Submitted by registry <jay@nzrs.net.nz>
  nz
  ac.nz
  co.nz
  cri.nz
  geek.nz
  gen.nz
  govt.nz
  health.nz
  iwi.nz
  kiwi.nz
  maori.nz
  mil.nz
  xn--mori-qsa.nz
  net.nz
  org.nz
  parliament.nz
  school.nz
  
  // om : https://en.wikipedia.org/wiki/.om
  om
  co.om
  com.om
  edu.om
  gov.om
  med.om
  museum.om
  net.om
  org.om
  pro.om
  
  // onion : https://tools.ietf.org/html/rfc7686
  onion
  
  // org : https://en.wikipedia.org/wiki/.org
  org
  
  // pa : http://www.nic.pa/
  // Some additional second level "domains" resolve directly as hostnames, such as
  // pannet.pa, so we add a rule for "pa".
  pa
  ac.pa
  gob.pa
  com.pa
  org.pa
  sld.pa
  edu.pa
  net.pa
  ing.pa
  abo.pa
  med.pa
  nom.pa
  
  // pe : https://www.nic.pe/InformeFinalComision.pdf
  pe
  edu.pe
  gob.pe
  nom.pe
  mil.pe
  org.pe
  com.pe
  net.pe
  
  // pf : http://www.gobin.info/domainname/formulaire-pf.pdf
  pf
  com.pf
  org.pf
  edu.pf
  
  // pg : https://en.wikipedia.org/wiki/.pg
  *.pg
  
  // ph : http://www.domains.ph/FAQ2.asp
  // Submitted by registry <jed@email.com.ph>
  ph
  com.ph
  net.ph
  org.ph
  gov.ph
  edu.ph
  ngo.ph
  mil.ph
  i.ph
  
  // pk : http://pk5.pknic.net.pk/pk5/msgNamepk.PK
  pk
  com.pk
  net.pk
  edu.pk
  org.pk
  fam.pk
  biz.pk
  web.pk
  gov.pk
  gob.pk
  gok.pk
  gon.pk
  gop.pk
  gos.pk
  info.pk
  
  // pl http://www.dns.pl/english/index.html
  // Submitted by registry
  pl
  com.pl
  net.pl
  org.pl
  // pl functional domains (http://www.dns.pl/english/index.html)
  aid.pl
  agro.pl
  atm.pl
  auto.pl
  biz.pl
  edu.pl
  gmina.pl
  gsm.pl
  info.pl
  mail.pl
  miasta.pl
  media.pl
  mil.pl
  nieruchomosci.pl
  nom.pl
  pc.pl
  powiat.pl
  priv.pl
  realestate.pl
  rel.pl
  sex.pl
  shop.pl
  sklep.pl
  sos.pl
  szkola.pl
  targi.pl
  tm.pl
  tourism.pl
  travel.pl
  turystyka.pl
  // Government domains
  gov.pl
  ap.gov.pl
  ic.gov.pl
  is.gov.pl
  us.gov.pl
  kmpsp.gov.pl
  kppsp.gov.pl
  kwpsp.gov.pl
  psp.gov.pl
  wskr.gov.pl
  kwp.gov.pl
  mw.gov.pl
  ug.gov.pl
  um.gov.pl
  umig.gov.pl
  ugim.gov.pl
  upow.gov.pl
  uw.gov.pl
  starostwo.gov.pl
  pa.gov.pl
  po.gov.pl
  psse.gov.pl
  pup.gov.pl
  rzgw.gov.pl
  sa.gov.pl
  so.gov.pl
  sr.gov.pl
  wsa.gov.pl
  sko.gov.pl
  uzs.gov.pl
  wiih.gov.pl
  winb.gov.pl
  pinb.gov.pl
  wios.gov.pl
  witd.gov.pl
  wzmiuw.gov.pl
  piw.gov.pl
  wiw.gov.pl
  griw.gov.pl
  wif.gov.pl
  oum.gov.pl
  sdn.gov.pl
  zp.gov.pl
  uppo.gov.pl
  mup.gov.pl
  wuoz.gov.pl
  konsulat.gov.pl
  oirm.gov.pl
  // pl regional domains (http://www.dns.pl/english/index.html)
  augustow.pl
  babia-gora.pl
  bedzin.pl
  beskidy.pl
  bialowieza.pl
  bialystok.pl
  bielawa.pl
  bieszczady.pl
  boleslawiec.pl
  bydgoszcz.pl
  bytom.pl
  cieszyn.pl
  czeladz.pl
  czest.pl
  dlugoleka.pl
  elblag.pl
  elk.pl
  glogow.pl
  gniezno.pl
  gorlice.pl
  grajewo.pl
  ilawa.pl
  jaworzno.pl
  jelenia-gora.pl
  jgora.pl
  kalisz.pl
  kazimierz-dolny.pl
  karpacz.pl
  kartuzy.pl
  kaszuby.pl
  katowice.pl
  kepno.pl
  ketrzyn.pl
  klodzko.pl
  kobierzyce.pl
  kolobrzeg.pl
  konin.pl
  konskowola.pl
  kutno.pl
  lapy.pl
  lebork.pl
  legnica.pl
  lezajsk.pl
  limanowa.pl
  lomza.pl
  lowicz.pl
  lubin.pl
  lukow.pl
  malbork.pl
  malopolska.pl
  mazowsze.pl
  mazury.pl
  mielec.pl
  mielno.pl
  mragowo.pl
  naklo.pl
  nowaruda.pl
  nysa.pl
  olawa.pl
  olecko.pl
  olkusz.pl
  olsztyn.pl
  opoczno.pl
  opole.pl
  ostroda.pl
  ostroleka.pl
  ostrowiec.pl
  ostrowwlkp.pl
  pila.pl
  pisz.pl
  podhale.pl
  podlasie.pl
  polkowice.pl
  pomorze.pl
  pomorskie.pl
  prochowice.pl
  pruszkow.pl
  przeworsk.pl
  pulawy.pl
  radom.pl
  rawa-maz.pl
  rybnik.pl
  rzeszow.pl
  sanok.pl
  sejny.pl
  slask.pl
  slupsk.pl
  sosnowiec.pl
  stalowa-wola.pl
  skoczow.pl
  starachowice.pl
  stargard.pl
  suwalki.pl
  swidnica.pl
  swiebodzin.pl
  swinoujscie.pl
  szczecin.pl
  szczytno.pl
  tarnobrzeg.pl
  tgory.pl
  turek.pl
  tychy.pl
  ustka.pl
  walbrzych.pl
  warmia.pl
  warszawa.pl
  waw.pl
  wegrow.pl
  wielun.pl
  wlocl.pl
  wloclawek.pl
  wodzislaw.pl
  wolomin.pl
  wroclaw.pl
  zachpomor.pl
  zagan.pl
  zarow.pl
  zgora.pl
  zgorzelec.pl
  
  // pm : http://www.afnic.fr/medias/documents/AFNIC-naming-policy2012.pdf
  pm
  
  // pn : http://www.government.pn/PnRegistry/policies.htm
  pn
  gov.pn
  co.pn
  org.pn
  edu.pn
  net.pn
  
  // post : https://en.wikipedia.org/wiki/.post
  post
  
  // pr : http://www.nic.pr/index.asp?f=1
  pr
  com.pr
  net.pr
  org.pr
  gov.pr
  edu.pr
  isla.pr
  pro.pr
  biz.pr
  info.pr
  name.pr
  // these aren't mentioned on nic.pr, but on https://en.wikipedia.org/wiki/.pr
  est.pr
  prof.pr
  ac.pr
  
  // pro : http://registry.pro/get-pro
  pro
  aaa.pro
  aca.pro
  acct.pro
  avocat.pro
  bar.pro
  cpa.pro
  eng.pro
  jur.pro
  law.pro
  med.pro
  recht.pro
  
  // ps : https://en.wikipedia.org/wiki/.ps
  // http://www.nic.ps/registration/policy.html#reg
  ps
  edu.ps
  gov.ps
  sec.ps
  plo.ps
  com.ps
  org.ps
  net.ps
  
  // pt : http://online.dns.pt/dns/start_dns
  pt
  net.pt
  gov.pt
  org.pt
  edu.pt
  int.pt
  publ.pt
  com.pt
  nome.pt
  
  // pw : https://en.wikipedia.org/wiki/.pw
  pw
  co.pw
  ne.pw
  or.pw
  ed.pw
  go.pw
  belau.pw
  
  // py : http://www.nic.py/pautas.html#seccion_9
  // Submitted by registry
  py
  com.py
  coop.py
  edu.py
  gov.py
  mil.py
  net.py
  org.py
  
  // qa : http://domains.qa/en/
  qa
  com.qa
  edu.qa
  gov.qa
  mil.qa
  name.qa
  net.qa
  org.qa
  sch.qa
  
  // re : http://www.afnic.re/obtenir/chartes/nommage-re/annexe-descriptifs
  re
  asso.re
  com.re
  nom.re
  
  // ro : http://www.rotld.ro/
  ro
  arts.ro
  com.ro
  firm.ro
  info.ro
  nom.ro
  nt.ro
  org.ro
  rec.ro
  store.ro
  tm.ro
  www.ro
  
  // rs : https://www.rnids.rs/en/domains/national-domains
  rs
  ac.rs
  co.rs
  edu.rs
  gov.rs
  in.rs
  org.rs
  
  // ru : https://cctld.ru/en/domains/domens_ru/reserved/
  ru
  ac.ru
  edu.ru
  gov.ru
  int.ru
  mil.ru
  test.ru
  
  // rw : http://www.nic.rw/cgi-bin/policy.pl
  rw
  gov.rw
  net.rw
  edu.rw
  ac.rw
  com.rw
  co.rw
  int.rw
  mil.rw
  gouv.rw
  
  // sa : http://www.nic.net.sa/
  sa
  com.sa
  net.sa
  org.sa
  gov.sa
  med.sa
  pub.sa
  edu.sa
  sch.sa
  
  // sb : http://www.sbnic.net.sb/
  // Submitted by registry <lee.humphries@telekom.com.sb>
  sb
  com.sb
  edu.sb
  gov.sb
  net.sb
  org.sb
  
  // sc : http://www.nic.sc/
  sc
  com.sc
  gov.sc
  net.sc
  org.sc
  edu.sc
  
  // sd : http://www.isoc.sd/sudanic.isoc.sd/billing_pricing.htm
  // Submitted by registry <admin@isoc.sd>
  sd
  com.sd
  net.sd
  org.sd
  edu.sd
  med.sd
  tv.sd
  gov.sd
  info.sd
  
  // se : https://en.wikipedia.org/wiki/.se
  // Submitted by registry <patrik.wallstrom@iis.se>
  se
  a.se
  ac.se
  b.se
  bd.se
  brand.se
  c.se
  d.se
  e.se
  f.se
  fh.se
  fhsk.se
  fhv.se
  g.se
  h.se
  i.se
  k.se
  komforb.se
  kommunalforbund.se
  komvux.se
  l.se
  lanbib.se
  m.se
  n.se
  naturbruksgymn.se
  o.se
  org.se
  p.se
  parti.se
  pp.se
  press.se
  r.se
  s.se
  t.se
  tm.se
  u.se
  w.se
  x.se
  y.se
  z.se
  
  // sg : http://www.nic.net.sg/page/registration-policies-procedures-and-guidelines
  sg
  com.sg
  net.sg
  org.sg
  gov.sg
  edu.sg
  per.sg
  
  // sh : http://www.nic.sh/registrar.html
  sh
  com.sh
  net.sh
  gov.sh
  org.sh
  mil.sh
  
  // si : https://en.wikipedia.org/wiki/.si
  si
  
  // sj : No registrations at this time.
  // Submitted by registry <jarle@uninett.no>
  sj
  
  // sk : https://en.wikipedia.org/wiki/.sk
  // list of 2nd level domains ?
  sk
  
  // sl : http://www.nic.sl
  // Submitted by registry <adam@neoip.com>
  sl
  com.sl
  net.sl
  edu.sl
  gov.sl
  org.sl
  
  // sm : https://en.wikipedia.org/wiki/.sm
  sm
  
  // sn : https://en.wikipedia.org/wiki/.sn
  sn
  art.sn
  com.sn
  edu.sn
  gouv.sn
  org.sn
  perso.sn
  univ.sn
  
  // so : http://www.soregistry.com/
  so
  com.so
  net.so
  org.so
  
  // sr : https://en.wikipedia.org/wiki/.sr
  sr
  
  // st : http://www.nic.st/html/policyrules/
  st
  co.st
  com.st
  consulado.st
  edu.st
  embaixada.st
  gov.st
  mil.st
  net.st
  org.st
  principe.st
  saotome.st
  store.st
  
  // su : https://en.wikipedia.org/wiki/.su
  su
  
  // sv : http://www.svnet.org.sv/niveldos.pdf
  sv
  com.sv
  edu.sv
  gob.sv
  org.sv
  red.sv
  
  // sx : https://en.wikipedia.org/wiki/.sx
  // Submitted by registry <jcvignes@openregistry.com>
  sx
  gov.sx
  
  // sy : https://en.wikipedia.org/wiki/.sy
  // see also: http://www.gobin.info/domainname/sy.doc
  sy
  edu.sy
  gov.sy
  net.sy
  mil.sy
  com.sy
  org.sy
  
  // sz : https://en.wikipedia.org/wiki/.sz
  // http://www.sispa.org.sz/
  sz
  co.sz
  ac.sz
  org.sz
  
  // tc : https://en.wikipedia.org/wiki/.tc
  tc
  
  // td : https://en.wikipedia.org/wiki/.td
  td
  
  // tel: https://en.wikipedia.org/wiki/.tel
  // http://www.telnic.org/
  tel
  
  // tf : https://en.wikipedia.org/wiki/.tf
  tf
  
  // tg : https://en.wikipedia.org/wiki/.tg
  // http://www.nic.tg/
  tg
  
  // th : https://en.wikipedia.org/wiki/.th
  // Submitted by registry <krit@thains.co.th>
  th
  ac.th
  co.th
  go.th
  in.th
  mi.th
  net.th
  or.th
  
  // tj : http://www.nic.tj/policy.html
  tj
  ac.tj
  biz.tj
  co.tj
  com.tj
  edu.tj
  go.tj
  gov.tj
  int.tj
  mil.tj
  name.tj
  net.tj
  nic.tj
  org.tj
  test.tj
  web.tj
  
  // tk : https://en.wikipedia.org/wiki/.tk
  tk
  
  // tl : https://en.wikipedia.org/wiki/.tl
  tl
  gov.tl
  
  // tm : http://www.nic.tm/local.html
  tm
  com.tm
  co.tm
  org.tm
  net.tm
  nom.tm
  gov.tm
  mil.tm
  edu.tm
  
  // tn : https://en.wikipedia.org/wiki/.tn
  // http://whois.ati.tn/
  tn
  com.tn
  ens.tn
  fin.tn
  gov.tn
  ind.tn
  intl.tn
  nat.tn
  net.tn
  org.tn
  info.tn
  perso.tn
  tourism.tn
  edunet.tn
  rnrt.tn
  rns.tn
  rnu.tn
  mincom.tn
  agrinet.tn
  defense.tn
  turen.tn
  
  // to : https://en.wikipedia.org/wiki/.to
  // Submitted by registry <egullich@colo.to>
  to
  com.to
  gov.to
  net.to
  org.to
  edu.to
  mil.to
  
  // subTLDs: https://www.nic.tr/forms/eng/policies.pdf
  //     and: https://www.nic.tr/forms/politikalar.pdf
  // Submitted by <mehmetgurevin@gmail.com>
  tr
  com.tr
  info.tr
  biz.tr
  net.tr
  org.tr
  web.tr
  gen.tr
  tv.tr
  av.tr
  dr.tr
  bbs.tr
  name.tr
  tel.tr
  gov.tr
  bel.tr
  pol.tr
  mil.tr
  k12.tr
  edu.tr
  kep.tr
  
  // Used by Northern Cyprus
  nc.tr
  
  // Used by government agencies of Northern Cyprus
  gov.nc.tr
  
  // tt : http://www.nic.tt/
  tt
  co.tt
  com.tt
  org.tt
  net.tt
  biz.tt
  info.tt
  pro.tt
  int.tt
  coop.tt
  jobs.tt
  mobi.tt
  travel.tt
  museum.tt
  aero.tt
  name.tt
  gov.tt
  edu.tt
  
  // tv : https://en.wikipedia.org/wiki/.tv
  // Not listing any 2LDs as reserved since none seem to exist in practice,
  // Wikipedia notwithstanding.
  tv
  
  // tw : https://en.wikipedia.org/wiki/.tw
  tw
  edu.tw
  gov.tw
  mil.tw
  com.tw
  net.tw
  org.tw
  idv.tw
  game.tw
  ebiz.tw
  club.tw
  xn--zf0ao64a.tw
  xn--uc0atv.tw
  xn--czrw28b.tw
  
  // tz : http://www.tznic.or.tz/index.php/domains
  // Submitted by registry <manager@tznic.or.tz>
  tz
  ac.tz
  co.tz
  go.tz
  hotel.tz
  info.tz
  me.tz
  mil.tz
  mobi.tz
  ne.tz
  or.tz
  sc.tz
  tv.tz
  
  // ua : https://hostmaster.ua/policy/?ua
  // Submitted by registry <dk@cctld.ua>
  ua
  // ua 2LD
  com.ua
  edu.ua
  gov.ua
  in.ua
  net.ua
  org.ua
  // ua geographic names
  // https://hostmaster.ua/2ld/
  cherkassy.ua
  cherkasy.ua
  chernigov.ua
  chernihiv.ua
  chernivtsi.ua
  chernovtsy.ua
  ck.ua
  cn.ua
  cr.ua
  crimea.ua
  cv.ua
  dn.ua
  dnepropetrovsk.ua
  dnipropetrovsk.ua
  dominic.ua
  donetsk.ua
  dp.ua
  if.ua
  ivano-frankivsk.ua
  kh.ua
  kharkiv.ua
  kharkov.ua
  kherson.ua
  khmelnitskiy.ua
  khmelnytskyi.ua
  kiev.ua
  kirovograd.ua
  km.ua
  kr.ua
  krym.ua
  ks.ua
  kv.ua
  kyiv.ua
  lg.ua
  lt.ua
  lugansk.ua
  lutsk.ua
  lv.ua
  lviv.ua
  mk.ua
  mykolaiv.ua
  nikolaev.ua
  od.ua
  odesa.ua
  odessa.ua
  pl.ua
  poltava.ua
  rivne.ua
  rovno.ua
  rv.ua
  sb.ua
  sebastopol.ua
  sevastopol.ua
  sm.ua
  sumy.ua
  te.ua
  ternopil.ua
  uz.ua
  uzhgorod.ua
  vinnica.ua
  vinnytsia.ua
  vn.ua
  volyn.ua
  yalta.ua
  zaporizhzhe.ua
  zaporizhzhia.ua
  zhitomir.ua
  zhytomyr.ua
  zp.ua
  zt.ua
  
  // ug : https://www.registry.co.ug/
  ug
  co.ug
  or.ug
  ac.ug
  sc.ug
  go.ug
  ne.ug
  com.ug
  org.ug
  
  // uk : https://en.wikipedia.org/wiki/.uk
  // Submitted by registry <Michael.Daly@nominet.org.uk>
  uk
  ac.uk
  co.uk
  gov.uk
  ltd.uk
  me.uk
  net.uk
  nhs.uk
  org.uk
  plc.uk
  police.uk
  *.sch.uk
  
  // us : https://en.wikipedia.org/wiki/.us
  us
  dni.us
  fed.us
  isa.us
  kids.us
  nsn.us
  // us geographic names
  ak.us
  al.us
  ar.us
  as.us
  az.us
  ca.us
  co.us
  ct.us
  dc.us
  de.us
  fl.us
  ga.us
  gu.us
  hi.us
  ia.us
  id.us
  il.us
  in.us
  ks.us
  ky.us
  la.us
  ma.us
  md.us
  me.us
  mi.us
  mn.us
  mo.us
  ms.us
  mt.us
  nc.us
  nd.us
  ne.us
  nh.us
  nj.us
  nm.us
  nv.us
  ny.us
  oh.us
  ok.us
  or.us
  pa.us
  pr.us
  ri.us
  sc.us
  sd.us
  tn.us
  tx.us
  ut.us
  vi.us
  vt.us
  va.us
  wa.us
  wi.us
  wv.us
  wy.us
  // The registrar notes several more specific domains available in each state,
  // such as state.*.us, dst.*.us, etc., but resolution of these is somewhat
  // haphazard; in some states these domains resolve as addresses, while in others
  // only subdomains are available, or even nothing at all. We include the
  // most common ones where it's clear that different sites are different
  // entities.
  k12.ak.us
  k12.al.us
  k12.ar.us
  k12.as.us
  k12.az.us
  k12.ca.us
  k12.co.us
  k12.ct.us
  k12.dc.us
  k12.de.us
  k12.fl.us
  k12.ga.us
  k12.gu.us
  // k12.hi.us  Bug 614565 - Hawaii has a state-wide DOE login
  k12.ia.us
  k12.id.us
  k12.il.us
  k12.in.us
  k12.ks.us
  k12.ky.us
  k12.la.us
  k12.ma.us
  k12.md.us
  k12.me.us
  k12.mi.us
  k12.mn.us
  k12.mo.us
  k12.ms.us
  k12.mt.us
  k12.nc.us
  // k12.nd.us  Bug 1028347 - Removed at request of Travis Rosso <trossow@nd.gov>
  k12.ne.us
  k12.nh.us
  k12.nj.us
  k12.nm.us
  k12.nv.us
  k12.ny.us
  k12.oh.us
  k12.ok.us
  k12.or.us
  k12.pa.us
  k12.pr.us
  k12.ri.us
  k12.sc.us
  // k12.sd.us  Bug 934131 - Removed at request of James Booze <James.Booze@k12.sd.us>
  k12.tn.us
  k12.tx.us
  k12.ut.us
  k12.vi.us
  k12.vt.us
  k12.va.us
  k12.wa.us
  k12.wi.us
  // k12.wv.us  Bug 947705 - Removed at request of Verne Britton <verne@wvnet.edu>
  k12.wy.us
  cc.ak.us
  cc.al.us
  cc.ar.us
  cc.as.us
  cc.az.us
  cc.ca.us
  cc.co.us
  cc.ct.us
  cc.dc.us
  cc.de.us
  cc.fl.us
  cc.ga.us
  cc.gu.us
  cc.hi.us
  cc.ia.us
  cc.id.us
  cc.il.us
  cc.in.us
  cc.ks.us
  cc.ky.us
  cc.la.us
  cc.ma.us
  cc.md.us
  cc.me.us
  cc.mi.us
  cc.mn.us
  cc.mo.us
  cc.ms.us
  cc.mt.us
  cc.nc.us
  cc.nd.us
  cc.ne.us
  cc.nh.us
  cc.nj.us
  cc.nm.us
  cc.nv.us
  cc.ny.us
  cc.oh.us
  cc.ok.us
  cc.or.us
  cc.pa.us
  cc.pr.us
  cc.ri.us
  cc.sc.us
  cc.sd.us
  cc.tn.us
  cc.tx.us
  cc.ut.us
  cc.vi.us
  cc.vt.us
  cc.va.us
  cc.wa.us
  cc.wi.us
  cc.wv.us
  cc.wy.us
  lib.ak.us
  lib.al.us
  lib.ar.us
  lib.as.us
  lib.az.us
  lib.ca.us
  lib.co.us
  lib.ct.us
  lib.dc.us
  // lib.de.us  Issue #243 - Moved to Private section at request of Ed Moore <Ed.Moore@lib.de.us>
  lib.fl.us
  lib.ga.us
  lib.gu.us
  lib.hi.us
  lib.ia.us
  lib.id.us
  lib.il.us
  lib.in.us
  lib.ks.us
  lib.ky.us
  lib.la.us
  lib.ma.us
  lib.md.us
  lib.me.us
  lib.mi.us
  lib.mn.us
  lib.mo.us
  lib.ms.us
  lib.mt.us
  lib.nc.us
  lib.nd.us
  lib.ne.us
  lib.nh.us
  lib.nj.us
  lib.nm.us
  lib.nv.us
  lib.ny.us
  lib.oh.us
  lib.ok.us
  lib.or.us
  lib.pa.us
  lib.pr.us
  lib.ri.us
  lib.sc.us
  lib.sd.us
  lib.tn.us
  lib.tx.us
  lib.ut.us
  lib.vi.us
  lib.vt.us
  lib.va.us
  lib.wa.us
  lib.wi.us
  // lib.wv.us  Bug 941670 - Removed at request of Larry W Arnold <arnold@wvlc.lib.wv.us>
  lib.wy.us
  // k12.ma.us contains school districts in Massachusetts. The 4LDs are
  //  managed independently except for private (PVT), charter (CHTR) and
  //  parochial (PAROCH) schools.  Those are delegated directly to the
  //  5LD operators.   <k12-ma-hostmaster _ at _ rsuc.gweep.net>
  pvt.k12.ma.us
  chtr.k12.ma.us
  paroch.k12.ma.us
  // Merit Network, Inc. maintains the registry for =~ /(k12|cc|lib).mi.us/ and the following
  //    see also: http://domreg.merit.edu
  //    see also: whois -h whois.domreg.merit.edu help
  ann-arbor.mi.us
  cog.mi.us
  dst.mi.us
  eaton.mi.us
  gen.mi.us
  mus.mi.us
  tec.mi.us
  washtenaw.mi.us
  
  // uy : http://www.nic.org.uy/
  uy
  com.uy
  edu.uy
  gub.uy
  mil.uy
  net.uy
  org.uy
  
  // uz : http://www.reg.uz/
  uz
  co.uz
  com.uz
  net.uz
  org.uz
  
  // va : https://en.wikipedia.org/wiki/.va
  va
  
  // vc : https://en.wikipedia.org/wiki/.vc
  // Submitted by registry <kshah@ca.afilias.info>
  vc
  com.vc
  net.vc
  org.vc
  gov.vc
  mil.vc
  edu.vc
  
  // ve : https://registro.nic.ve/
  // Submitted by registry
  ve
  arts.ve
  co.ve
  com.ve
  e12.ve
  edu.ve
  firm.ve
  gob.ve
  gov.ve
  info.ve
  int.ve
  mil.ve
  net.ve
  org.ve
  rec.ve
  store.ve
  tec.ve
  web.ve
  
  // vg : https://en.wikipedia.org/wiki/.vg
  vg
  
  // vi : http://www.nic.vi/newdomainform.htm
  // http://www.nic.vi/Domain_Rules/body_domain_rules.html indicates some other
  // TLDs are "reserved", such as edu.vi and gov.vi, but doesn't actually say they
  // are available for registration (which they do not seem to be).
  vi
  co.vi
  com.vi
  k12.vi
  net.vi
  org.vi
  
  // vn : https://www.dot.vn/vnnic/vnnic/domainregistration.jsp
  vn
  com.vn
  net.vn
  org.vn
  edu.vn
  gov.vn
  int.vn
  ac.vn
  biz.vn
  info.vn
  name.vn
  pro.vn
  health.vn
  
  // vu : https://en.wikipedia.org/wiki/.vu
  // http://www.vunic.vu/
  vu
  com.vu
  edu.vu
  net.vu
  org.vu
  
  // wf : http://www.afnic.fr/medias/documents/AFNIC-naming-policy2012.pdf
  wf
  
  // ws : https://en.wikipedia.org/wiki/.ws
  // http://samoanic.ws/index.dhtml
  ws
  com.ws
  net.ws
  org.ws
  gov.ws
  edu.ws
  
  // yt : http://www.afnic.fr/medias/documents/AFNIC-naming-policy2012.pdf
  yt
  
  // IDN ccTLDs
  // When submitting patches, please maintain a sort by ISO 3166 ccTLD, then
  // U-label, and follow this format:
  // // A-Label ("<Latin renderings>", <language name>[, variant info]) : <ISO 3166 ccTLD>
  // // [sponsoring org]
  // U-Label
  
  // xn--mgbaam7a8h ("Emerat", Arabic) : AE
  // http://nic.ae/english/arabicdomain/rules.jsp
  xn--mgbaam7a8h
  
  // xn--y9a3aq ("hye", Armenian) : AM
  // ISOC AM (operated by .am Registry)
  xn--y9a3aq
  
  // xn--54b7fta0cc ("Bangla", Bangla) : BD
  xn--54b7fta0cc
  
  // xn--90ae ("bg", Bulgarian) : BG
  xn--90ae
  
  // xn--90ais ("bel", Belarusian/Russian Cyrillic) : BY
  // Operated by .by registry
  xn--90ais
  
  // xn--fiqs8s ("Zhongguo/China", Chinese, Simplified) : CN
  // CNNIC
  // http://cnnic.cn/html/Dir/2005/10/11/3218.htm
  xn--fiqs8s
  
  // xn--fiqz9s ("Zhongguo/China", Chinese, Traditional) : CN
  // CNNIC
  // http://cnnic.cn/html/Dir/2005/10/11/3218.htm
  xn--fiqz9s
  
  // xn--lgbbat1ad8j ("Algeria/Al Jazair", Arabic) : DZ
  xn--lgbbat1ad8j
  
  // xn--wgbh1c ("Egypt/Masr", Arabic) : EG
  // http://www.dotmasr.eg/
  xn--wgbh1c
  
  // xn--e1a4c ("eu", Cyrillic) : EU
  xn--e1a4c
  
  // xn--node ("ge", Georgian Mkhedruli) : GE
  xn--node
  
  // xn--qxam ("el", Greek) : GR
  // Hellenic Ministry of Infrastructure, Transport, and Networks
  xn--qxam
  
  // xn--j6w193g ("Hong Kong", Chinese) : HK
  // https://www.hkirc.hk
  // Submitted by registry <hk.tech@hkirc.hk>
  // https://www.hkirc.hk/content.jsp?id=30#!/34
  xn--j6w193g
  xn--55qx5d.xn--j6w193g
  xn--wcvs22d.xn--j6w193g
  xn--mxtq1m.xn--j6w193g
  xn--gmqw5a.xn--j6w193g
  xn--od0alg.xn--j6w193g
  xn--uc0atv.xn--j6w193g
  
  // xn--2scrj9c ("Bharat", Kannada) : IN
  // India
  xn--2scrj9c
  
  // xn--3hcrj9c ("Bharat", Oriya) : IN
  // India
  xn--3hcrj9c
  
  // xn--45br5cyl ("Bharatam", Assamese) : IN
  // India
  xn--45br5cyl
  
  // xn--h2breg3eve ("Bharatam", Sanskrit) : IN
  // India
  xn--h2breg3eve
  
  // xn--h2brj9c8c ("Bharot", Santali) : IN
  // India
  xn--h2brj9c8c
  
  // xn--mgbgu82a ("Bharat", Sindhi) : IN
  // India
  xn--mgbgu82a
  
  // xn--rvc1e0am3e ("Bharatam", Malayalam) : IN
  // India
  xn--rvc1e0am3e
  
  // xn--h2brj9c ("Bharat", Devanagari) : IN
  // India
  xn--h2brj9c
  
  // xn--mgbbh1a ("Bharat", Kashmiri) : IN
  // India
  xn--mgbbh1a
  
  // xn--mgbbh1a71e ("Bharat", Arabic) : IN
  // India
  xn--mgbbh1a71e
  
  // xn--fpcrj9c3d ("Bharat", Telugu) : IN
  // India
  xn--fpcrj9c3d
  
  // xn--gecrj9c ("Bharat", Gujarati) : IN
  // India
  xn--gecrj9c
  
  // xn--s9brj9c ("Bharat", Gurmukhi) : IN
  // India
  xn--s9brj9c
  
  // xn--45brj9c ("Bharat", Bengali) : IN
  // India
  xn--45brj9c
  
  // xn--xkc2dl3a5ee0h ("India", Tamil) : IN
  // India
  xn--xkc2dl3a5ee0h
  
  // xn--mgba3a4f16a ("Iran", Persian) : IR
  xn--mgba3a4f16a
  
  // xn--mgba3a4fra ("Iran", Arabic) : IR
  xn--mgba3a4fra
  
  // xn--mgbtx2b ("Iraq", Arabic) : IQ
  // Communications and Media Commission
  xn--mgbtx2b
  
  // xn--mgbayh7gpa ("al-Ordon", Arabic) : JO
  // National Information Technology Center (NITC)
  // Royal Scientific Society, Al-Jubeiha
  xn--mgbayh7gpa
  
  // xn--3e0b707e ("Republic of Korea", Hangul) : KR
  xn--3e0b707e
  
  // xn--80ao21a ("Kaz", Kazakh) : KZ
  xn--80ao21a
  
  // xn--fzc2c9e2c ("Lanka", Sinhalese-Sinhala) : LK
  // http://nic.lk
  xn--fzc2c9e2c
  
  // xn--xkc2al3hye2a ("Ilangai", Tamil) : LK
  // http://nic.lk
  xn--xkc2al3hye2a
  
  // xn--mgbc0a9azcg ("Morocco/al-Maghrib", Arabic) : MA
  xn--mgbc0a9azcg
  
  // xn--d1alf ("mkd", Macedonian) : MK
  // MARnet
  xn--d1alf
  
  // xn--l1acc ("mon", Mongolian) : MN
  xn--l1acc
  
  // xn--mix891f ("Macao", Chinese, Traditional) : MO
  // MONIC / HNET Asia (Registry Operator for .mo)
  xn--mix891f
  
  // xn--mix082f ("Macao", Chinese, Simplified) : MO
  xn--mix082f
  
  // xn--mgbx4cd0ab ("Malaysia", Malay) : MY
  xn--mgbx4cd0ab
  
  // xn--mgb9awbf ("Oman", Arabic) : OM
  xn--mgb9awbf
  
  // xn--mgbai9azgqp6j ("Pakistan", Urdu/Arabic) : PK
  xn--mgbai9azgqp6j
  
  // xn--mgbai9a5eva00b ("Pakistan", Urdu/Arabic, variant) : PK
  xn--mgbai9a5eva00b
  
  // xn--ygbi2ammx ("Falasteen", Arabic) : PS
  // The Palestinian National Internet Naming Authority (PNINA)
  // http://www.pnina.ps
  xn--ygbi2ammx
  
  // xn--90a3ac ("srb", Cyrillic) : RS
  // https://www.rnids.rs/en/domains/national-domains
  xn--90a3ac
  xn--o1ac.xn--90a3ac
  xn--c1avg.xn--90a3ac
  xn--90azh.xn--90a3ac
  xn--d1at.xn--90a3ac
  xn--o1ach.xn--90a3ac
  xn--80au.xn--90a3ac
  
  // xn--p1ai ("rf", Russian-Cyrillic) : RU
  // http://www.cctld.ru/en/docs/rulesrf.php
  xn--p1ai
  
  // xn--wgbl6a ("Qatar", Arabic) : QA
  // http://www.ict.gov.qa/
  xn--wgbl6a
  
  // xn--mgberp4a5d4ar ("AlSaudiah", Arabic) : SA
  // http://www.nic.net.sa/
  xn--mgberp4a5d4ar
  
  // xn--mgberp4a5d4a87g ("AlSaudiah", Arabic, variant)  : SA
  xn--mgberp4a5d4a87g
  
  // xn--mgbqly7c0a67fbc ("AlSaudiah", Arabic, variant) : SA
  xn--mgbqly7c0a67fbc
  
  // xn--mgbqly7cvafr ("AlSaudiah", Arabic, variant) : SA
  xn--mgbqly7cvafr
  
  // xn--mgbpl2fh ("sudan", Arabic) : SD
  // Operated by .sd registry
  xn--mgbpl2fh
  
  // xn--yfro4i67o Singapore ("Singapore", Chinese) : SG
  xn--yfro4i67o
  
  // xn--clchc0ea0b2g2a9gcd ("Singapore", Tamil) : SG
  xn--clchc0ea0b2g2a9gcd
  
  // xn--ogbpf8fl ("Syria", Arabic) : SY
  xn--ogbpf8fl
  
  // xn--mgbtf8fl ("Syria", Arabic, variant) : SY
  xn--mgbtf8fl
  
  // xn--o3cw4h ("Thai", Thai) : TH
  // http://www.thnic.co.th
  xn--o3cw4h
  xn--12c1fe0br.xn--o3cw4h
  xn--12co0c3b4eva.xn--o3cw4h
  xn--h3cuzk1di.xn--o3cw4h
  xn--o3cyx2a.xn--o3cw4h
  xn--m3ch0j3a.xn--o3cw4h
  xn--12cfi8ixb8l.xn--o3cw4h
  
  // xn--pgbs0dh ("Tunisia", Arabic) : TN
  // http://nic.tn
  xn--pgbs0dh
  
  // xn--kpry57d ("Taiwan", Chinese, Traditional) : TW
  // http://www.twnic.net/english/dn/dn_07a.htm
  xn--kpry57d
  
  // xn--kprw13d ("Taiwan", Chinese, Simplified) : TW
  // http://www.twnic.net/english/dn/dn_07a.htm
  xn--kprw13d
  
  // xn--nnx388a ("Taiwan", Chinese, variant) : TW
  xn--nnx388a
  
  // xn--j1amh ("ukr", Cyrillic) : UA
  xn--j1amh
  
  // xn--mgb2ddes ("AlYemen", Arabic) : YE
  xn--mgb2ddes
  
  // xxx : http://icmregistry.com
  xxx
  
  // ye : http://www.y.net.ye/services/domain_name.htm
  *.ye
  
  // za : http://www.zadna.org.za/content/page/domain-information
  ac.za
  agric.za
  alt.za
  co.za
  edu.za
  gov.za
  grondar.za
  law.za
  mil.za
  net.za
  ngo.za
  nis.za
  nom.za
  org.za
  school.za
  tm.za
  web.za
  
  // zm : https://zicta.zm/
  // Submitted by registry <info@zicta.zm>
  zm
  ac.zm
  biz.zm
  co.zm
  com.zm
  edu.zm
  gov.zm
  info.zm
  mil.zm
  net.zm
  org.zm
  sch.zm
  
  // zw : https://www.potraz.gov.zw/
  // Confirmed by registry <bmtengwa@potraz.gov.zw> 2017-01-25
  zw
  ac.zw
  co.zw
  gov.zw
  mil.zw
  org.zw
  
  
  // newGTLDs
  // List of new gTLDs imported from https://newgtlds.icann.org/newgtlds.csv on 2018-05-08T19:40:37Z
  // This list is auto-generated, don't edit it manually.
  
  // aaa : 2015-02-26 American Automobile Association, Inc.
  aaa
  
  // aarp : 2015-05-21 AARP
  aarp
  
  // abarth : 2015-07-30 Fiat Chrysler Automobiles N.V.
  abarth
  
  // abb : 2014-10-24 ABB Ltd
  abb
  
  // abbott : 2014-07-24 Abbott Laboratories, Inc.
  abbott
  
  // abbvie : 2015-07-30 AbbVie Inc.
  abbvie
  
  // abc : 2015-07-30 Disney Enterprises, Inc.
  abc
  
  // able : 2015-06-25 Able Inc.
  able
  
  // abogado : 2014-04-24 Minds + Machines Group Limited
  abogado
  
  // abudhabi : 2015-07-30 Abu Dhabi Systems and Information Centre
  abudhabi
  
  // academy : 2013-11-07 Binky Moon, LLC
  academy
  
  // accenture : 2014-08-15 Accenture plc
  accenture
  
  // accountant : 2014-11-20 dot Accountant Limited
  accountant
  
  // accountants : 2014-03-20 Binky Moon, LLC
  accountants
  
  // aco : 2015-01-08 ACO Severin Ahlmann GmbH & Co. KG
  aco
  
  // active : 2014-05-01 Active Network, LLC
  active
  
  // actor : 2013-12-12 United TLD Holdco Ltd.
  actor
  
  // adac : 2015-07-16 Allgemeiner Deutscher Automobil-Club e.V. (ADAC)
  adac
  
  // ads : 2014-12-04 Charleston Road Registry Inc.
  ads
  
  // adult : 2014-10-16 ICM Registry AD LLC
  adult
  
  // aeg : 2015-03-19 Aktiebolaget Electrolux
  aeg
  
  // aetna : 2015-05-21 Aetna Life Insurance Company
  aetna
  
  // afamilycompany : 2015-07-23 Johnson Shareholdings, Inc.
  afamilycompany
  
  // afl : 2014-10-02 Australian Football League
  afl
  
  // africa : 2014-03-24 ZA Central Registry NPC trading as Registry.Africa
  africa
  
  // agakhan : 2015-04-23 Fondation Aga Khan (Aga Khan Foundation)
  agakhan
  
  // agency : 2013-11-14 Binky Moon, LLC
  agency
  
  // aig : 2014-12-18 American International Group, Inc.
  aig
  
  // aigo : 2015-08-06 aigo Digital Technology Co,Ltd.
  aigo
  
  // airbus : 2015-07-30 Airbus S.A.S.
  airbus
  
  // airforce : 2014-03-06 United TLD Holdco Ltd.
  airforce
  
  // airtel : 2014-10-24 Bharti Airtel Limited
  airtel
  
  // akdn : 2015-04-23 Fondation Aga Khan (Aga Khan Foundation)
  akdn
  
  // alfaromeo : 2015-07-31 Fiat Chrysler Automobiles N.V.
  alfaromeo
  
  // alibaba : 2015-01-15 Alibaba Group Holding Limited
  alibaba
  
  // alipay : 2015-01-15 Alibaba Group Holding Limited
  alipay
  
  // allfinanz : 2014-07-03 Allfinanz Deutsche Vermögensberatung Aktiengesellschaft
  allfinanz
  
  // allstate : 2015-07-31 Allstate Fire and Casualty Insurance Company
  allstate
  
  // ally : 2015-06-18 Ally Financial Inc.
  ally
  
  // alsace : 2014-07-02 Region Grand Est
  alsace
  
  // alstom : 2015-07-30 ALSTOM
  alstom
  
  // americanexpress : 2015-07-31 American Express Travel Related Services Company, Inc.
  americanexpress
  
  // americanfamily : 2015-07-23 AmFam, Inc.
  americanfamily
  
  // amex : 2015-07-31 American Express Travel Related Services Company, Inc.
  amex
  
  // amfam : 2015-07-23 AmFam, Inc.
  amfam
  
  // amica : 2015-05-28 Amica Mutual Insurance Company
  amica
  
  // amsterdam : 2014-07-24 Gemeente Amsterdam
  amsterdam
  
  // analytics : 2014-12-18 Campus IP LLC
  analytics
  
  // android : 2014-08-07 Charleston Road Registry Inc.
  android
  
  // anquan : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.
  anquan
  
  // anz : 2015-07-31 Australia and New Zealand Banking Group Limited
  anz
  
  // aol : 2015-09-17 Oath Inc.
  aol
  
  // apartments : 2014-12-11 Binky Moon, LLC
  apartments
  
  // app : 2015-05-14 Charleston Road Registry Inc.
  app
  
  // apple : 2015-05-14 Apple Inc.
  apple
  
  // aquarelle : 2014-07-24 Aquarelle.com
  aquarelle
  
  // arab : 2015-11-12 League of Arab States
  arab
  
  // aramco : 2014-11-20 Aramco Services Company
  aramco
  
  // archi : 2014-02-06 Afilias plc
  archi
  
  // army : 2014-03-06 United TLD Holdco Ltd.
  army
  
  // art : 2016-03-24 UK Creative Ideas Limited
  art
  
  // arte : 2014-12-11 Association Relative à la Télévision Européenne G.E.I.E.
  arte
  
  // asda : 2015-07-31 Wal-Mart Stores, Inc.
  asda
  
  // associates : 2014-03-06 Binky Moon, LLC
  associates
  
  // athleta : 2015-07-30 The Gap, Inc.
  athleta
  
  // attorney : 2014-03-20 United TLD Holdco Ltd.
  attorney
  
  // auction : 2014-03-20 United TLD Holdco Ltd.
  auction
  
  // audi : 2015-05-21 AUDI Aktiengesellschaft
  audi
  
  // audible : 2015-06-25 Amazon Registry Services, Inc.
  audible
  
  // audio : 2014-03-20 Uniregistry, Corp.
  audio
  
  // auspost : 2015-08-13 Australian Postal Corporation
  auspost
  
  // author : 2014-12-18 Amazon Registry Services, Inc.
  author
  
  // auto : 2014-11-13 Cars Registry Limited
  auto
  
  // autos : 2014-01-09 DERAutos, LLC
  autos
  
  // avianca : 2015-01-08 Aerovias del Continente Americano S.A. Avianca
  avianca
  
  // aws : 2015-06-25 Amazon Registry Services, Inc.
  aws
  
  // axa : 2013-12-19 AXA SA
  axa
  
  // azure : 2014-12-18 Microsoft Corporation
  azure
  
  // baby : 2015-04-09 Johnson & Johnson Services, Inc.
  baby
  
  // baidu : 2015-01-08 Baidu, Inc.
  baidu
  
  // banamex : 2015-07-30 Citigroup Inc.
  banamex
  
  // bananarepublic : 2015-07-31 The Gap, Inc.
  bananarepublic
  
  // band : 2014-06-12 United TLD Holdco Ltd.
  band
  
  // bank : 2014-09-25 fTLD Registry Services LLC
  bank
  
  // bar : 2013-12-12 Punto 2012 Sociedad Anonima Promotora de Inversion de Capital Variable
  bar
  
  // barcelona : 2014-07-24 Municipi de Barcelona
  barcelona
  
  // barclaycard : 2014-11-20 Barclays Bank PLC
  barclaycard
  
  // barclays : 2014-11-20 Barclays Bank PLC
  barclays
  
  // barefoot : 2015-06-11 Gallo Vineyards, Inc.
  barefoot
  
  // bargains : 2013-11-14 Binky Moon, LLC
  bargains
  
  // baseball : 2015-10-29 MLB Advanced Media DH, LLC
  baseball
  
  // basketball : 2015-08-20 Fédération Internationale de Basketball (FIBA)
  basketball
  
  // bauhaus : 2014-04-17 Werkhaus GmbH
  bauhaus
  
  // bayern : 2014-01-23 Bayern Connect GmbH
  bayern
  
  // bbc : 2014-12-18 British Broadcasting Corporation
  bbc
  
  // bbt : 2015-07-23 BB&T Corporation
  bbt
  
  // bbva : 2014-10-02 BANCO BILBAO VIZCAYA ARGENTARIA, S.A.
  bbva
  
  // bcg : 2015-04-02 The Boston Consulting Group, Inc.
  bcg
  
  // bcn : 2014-07-24 Municipi de Barcelona
  bcn
  
  // beats : 2015-05-14 Beats Electronics, LLC
  beats
  
  // beauty : 2015-12-03 L'Oréal
  beauty
  
  // beer : 2014-01-09 Minds + Machines Group Limited
  beer
  
  // bentley : 2014-12-18 Bentley Motors Limited
  bentley
  
  // berlin : 2013-10-31 dotBERLIN GmbH & Co. KG
  berlin
  
  // best : 2013-12-19 BestTLD Pty Ltd
  best
  
  // bestbuy : 2015-07-31 BBY Solutions, Inc.
  bestbuy
  
  // bet : 2015-05-07 Afilias plc
  bet
  
  // bharti : 2014-01-09 Bharti Enterprises (Holding) Private Limited
  bharti
  
  // bible : 2014-06-19 American Bible Society
  bible
  
  // bid : 2013-12-19 dot Bid Limited
  bid
  
  // bike : 2013-08-27 Binky Moon, LLC
  bike
  
  // bing : 2014-12-18 Microsoft Corporation
  bing
  
  // bingo : 2014-12-04 Binky Moon, LLC
  bingo
  
  // bio : 2014-03-06 Afilias plc
  bio
  
  // black : 2014-01-16 Afilias plc
  black
  
  // blackfriday : 2014-01-16 Uniregistry, Corp.
  blackfriday
  
  // blockbuster : 2015-07-30 Dish DBS Corporation
  blockbuster
  
  // blog : 2015-05-14 Knock Knock WHOIS There, LLC
  blog
  
  // bloomberg : 2014-07-17 Bloomberg IP Holdings LLC
  bloomberg
  
  // blue : 2013-11-07 Afilias plc
  blue
  
  // bms : 2014-10-30 Bristol-Myers Squibb Company
  bms
  
  // bmw : 2014-01-09 Bayerische Motoren Werke Aktiengesellschaft
  bmw
  
  // bnl : 2014-07-24 Banca Nazionale del Lavoro
  bnl
  
  // bnpparibas : 2014-05-29 BNP Paribas
  bnpparibas
  
  // boats : 2014-12-04 DERBoats, LLC
  boats
  
  // boehringer : 2015-07-09 Boehringer Ingelheim International GmbH
  boehringer
  
  // bofa : 2015-07-31 Bank of America Corporation
  bofa
  
  // bom : 2014-10-16 Núcleo de Informação e Coordenação do Ponto BR - NIC.br
  bom
  
  // bond : 2014-06-05 Bond University Limited
  bond
  
  // boo : 2014-01-30 Charleston Road Registry Inc.
  boo
  
  // book : 2015-08-27 Amazon Registry Services, Inc.
  book
  
  // booking : 2015-07-16 Booking.com B.V.
  booking
  
  // bosch : 2015-06-18 Robert Bosch GMBH
  bosch
  
  // bostik : 2015-05-28 Bostik SA
  bostik
  
  // boston : 2015-12-10 Boston TLD Management, LLC
  boston
  
  // bot : 2014-12-18 Amazon Registry Services, Inc.
  bot
  
  // boutique : 2013-11-14 Binky Moon, LLC
  boutique
  
  // box : 2015-11-12 NS1 Limited
  box
  
  // bradesco : 2014-12-18 Banco Bradesco S.A.
  bradesco
  
  // bridgestone : 2014-12-18 Bridgestone Corporation
  bridgestone
  
  // broadway : 2014-12-22 Celebrate Broadway, Inc.
  broadway
  
  // broker : 2014-12-11 Dotbroker Registry Limited
  broker
  
  // brother : 2015-01-29 Brother Industries, Ltd.
  brother
  
  // brussels : 2014-02-06 DNS.be vzw
  brussels
  
  // budapest : 2013-11-21 Minds + Machines Group Limited
  budapest
  
  // bugatti : 2015-07-23 Bugatti International SA
  bugatti
  
  // build : 2013-11-07 Plan Bee LLC
  build
  
  // builders : 2013-11-07 Binky Moon, LLC
  builders
  
  // business : 2013-11-07 Binky Moon, LLC
  business
  
  // buy : 2014-12-18 Amazon Registry Services, Inc.
  buy
  
  // buzz : 2013-10-02 DOTSTRATEGY CO.
  buzz
  
  // bzh : 2014-02-27 Association www.bzh
  bzh
  
  // cab : 2013-10-24 Binky Moon, LLC
  cab
  
  // cafe : 2015-02-11 Binky Moon, LLC
  cafe
  
  // cal : 2014-07-24 Charleston Road Registry Inc.
  cal
  
  // call : 2014-12-18 Amazon Registry Services, Inc.
  call
  
  // calvinklein : 2015-07-30 PVH gTLD Holdings LLC
  calvinklein
  
  // cam : 2016-04-21 AC Webconnecting Holding B.V.
  cam
  
  // camera : 2013-08-27 Binky Moon, LLC
  camera
  
  // camp : 2013-11-07 Binky Moon, LLC
  camp
  
  // cancerresearch : 2014-05-15 Australian Cancer Research Foundation
  cancerresearch
  
  // canon : 2014-09-12 Canon Inc.
  canon
  
  // capetown : 2014-03-24 ZA Central Registry NPC trading as ZA Central Registry
  capetown
  
  // capital : 2014-03-06 Binky Moon, LLC
  capital
  
  // capitalone : 2015-08-06 Capital One Financial Corporation
  capitalone
  
  // car : 2015-01-22 Cars Registry Limited
  car
  
  // caravan : 2013-12-12 Caravan International, Inc.
  caravan
  
  // cards : 2013-12-05 Binky Moon, LLC
  cards
  
  // care : 2014-03-06 Binky Moon, LLC
  care
  
  // career : 2013-10-09 dotCareer LLC
  career
  
  // careers : 2013-10-02 Binky Moon, LLC
  careers
  
  // cars : 2014-11-13 Cars Registry Limited
  cars
  
  // cartier : 2014-06-23 Richemont DNS Inc.
  cartier
  
  // casa : 2013-11-21 Minds + Machines Group Limited
  casa
  
  // case : 2015-09-03 CNH Industrial N.V.
  case
  
  // caseih : 2015-09-03 CNH Industrial N.V.
  caseih
  
  // cash : 2014-03-06 Binky Moon, LLC
  cash
  
  // casino : 2014-12-18 Binky Moon, LLC
  casino
  
  // catering : 2013-12-05 Binky Moon, LLC
  catering
  
  // catholic : 2015-10-21 Pontificium Consilium de Comunicationibus Socialibus (PCCS) (Pontifical Council for Social Communication)
  catholic
  
  // cba : 2014-06-26 COMMONWEALTH BANK OF AUSTRALIA
  cba
  
  // cbn : 2014-08-22 The Christian Broadcasting Network, Inc.
  cbn
  
  // cbre : 2015-07-02 CBRE, Inc.
  cbre
  
  // cbs : 2015-08-06 CBS Domains Inc.
  cbs
  
  // ceb : 2015-04-09 The Corporate Executive Board Company
  ceb
  
  // center : 2013-11-07 Binky Moon, LLC
  center
  
  // ceo : 2013-11-07 CEOTLD Pty Ltd
  ceo
  
  // cern : 2014-06-05 European Organization for Nuclear Research ("CERN")
  cern
  
  // cfa : 2014-08-28 CFA Institute
  cfa
  
  // cfd : 2014-12-11 DotCFD Registry Limited
  cfd
  
  // chanel : 2015-04-09 Chanel International B.V.
  chanel
  
  // channel : 2014-05-08 Charleston Road Registry Inc.
  channel
  
  // charity : 2018-04-11 Corn Lake, LLC
  charity
  
  // chase : 2015-04-30 JPMorgan Chase Bank, National Association
  chase
  
  // chat : 2014-12-04 Binky Moon, LLC
  chat
  
  // cheap : 2013-11-14 Binky Moon, LLC
  cheap
  
  // chintai : 2015-06-11 CHINTAI Corporation
  chintai
  
  // christmas : 2013-11-21 Uniregistry, Corp.
  christmas
  
  // chrome : 2014-07-24 Charleston Road Registry Inc.
  chrome
  
  // chrysler : 2015-07-30 FCA US LLC.
  chrysler
  
  // church : 2014-02-06 Binky Moon, LLC
  church
  
  // cipriani : 2015-02-19 Hotel Cipriani Srl
  cipriani
  
  // circle : 2014-12-18 Amazon Registry Services, Inc.
  circle
  
  // cisco : 2014-12-22 Cisco Technology, Inc.
  cisco
  
  // citadel : 2015-07-23 Citadel Domain LLC
  citadel
  
  // citi : 2015-07-30 Citigroup Inc.
  citi
  
  // citic : 2014-01-09 CITIC Group Corporation
  citic
  
  // city : 2014-05-29 Binky Moon, LLC
  city
  
  // cityeats : 2014-12-11 Lifestyle Domain Holdings, Inc.
  cityeats
  
  // claims : 2014-03-20 Binky Moon, LLC
  claims
  
  // cleaning : 2013-12-05 Binky Moon, LLC
  cleaning
  
  // click : 2014-06-05 Uniregistry, Corp.
  click
  
  // clinic : 2014-03-20 Binky Moon, LLC
  clinic
  
  // clinique : 2015-10-01 The Estée Lauder Companies Inc.
  clinique
  
  // clothing : 2013-08-27 Binky Moon, LLC
  clothing
  
  // cloud : 2015-04-16 Aruba PEC S.p.A.
  cloud
  
  // club : 2013-11-08 .CLUB DOMAINS, LLC
  club
  
  // clubmed : 2015-06-25 Club Méditerranée S.A.
  clubmed
  
  // coach : 2014-10-09 Binky Moon, LLC
  coach
  
  // codes : 2013-10-31 Binky Moon, LLC
  codes
  
  // coffee : 2013-10-17 Binky Moon, LLC
  coffee
  
  // college : 2014-01-16 XYZ.COM LLC
  college
  
  // cologne : 2014-02-05 punkt.wien GmbH
  cologne
  
  // comcast : 2015-07-23 Comcast IP Holdings I, LLC
  comcast
  
  // commbank : 2014-06-26 COMMONWEALTH BANK OF AUSTRALIA
  commbank
  
  // community : 2013-12-05 Binky Moon, LLC
  community
  
  // company : 2013-11-07 Binky Moon, LLC
  company
  
  // compare : 2015-10-08 iSelect Ltd
  compare
  
  // computer : 2013-10-24 Binky Moon, LLC
  computer
  
  // comsec : 2015-01-08 VeriSign, Inc.
  comsec
  
  // condos : 2013-12-05 Binky Moon, LLC
  condos
  
  // construction : 2013-09-16 Binky Moon, LLC
  construction
  
  // consulting : 2013-12-05 United TLD Holdco Ltd.
  consulting
  
  // contact : 2015-01-08 Top Level Spectrum, Inc.
  contact
  
  // contractors : 2013-09-10 Binky Moon, LLC
  contractors
  
  // cooking : 2013-11-21 Minds + Machines Group Limited
  cooking
  
  // cookingchannel : 2015-07-02 Lifestyle Domain Holdings, Inc.
  cookingchannel
  
  // cool : 2013-11-14 Binky Moon, LLC
  cool
  
  // corsica : 2014-09-25 Collectivité de Corse
  corsica
  
  // country : 2013-12-19 DotCountry LLC
  country
  
  // coupon : 2015-02-26 Amazon Registry Services, Inc.
  coupon
  
  // coupons : 2015-03-26 Binky Moon, LLC
  coupons
  
  // courses : 2014-12-04 OPEN UNIVERSITIES AUSTRALIA PTY LTD
  courses
  
  // credit : 2014-03-20 Binky Moon, LLC
  credit
  
  // creditcard : 2014-03-20 Binky Moon, LLC
  creditcard
  
  // creditunion : 2015-01-22 CUNA Performance Resources, LLC
  creditunion
  
  // cricket : 2014-10-09 dot Cricket Limited
  cricket
  
  // crown : 2014-10-24 Crown Equipment Corporation
  crown
  
  // crs : 2014-04-03 Federated Co-operatives Limited
  crs
  
  // cruise : 2015-12-10 Viking River Cruises (Bermuda) Ltd.
  cruise
  
  // cruises : 2013-12-05 Binky Moon, LLC
  cruises
  
  // csc : 2014-09-25 Alliance-One Services, Inc.
  csc
  
  // cuisinella : 2014-04-03 SALM S.A.S.
  cuisinella
  
  // cymru : 2014-05-08 Nominet UK
  cymru
  
  // cyou : 2015-01-22 Beijing Gamease Age Digital Technology Co., Ltd.
  cyou
  
  // dabur : 2014-02-06 Dabur India Limited
  dabur
  
  // dad : 2014-01-23 Charleston Road Registry Inc.
  dad
  
  // dance : 2013-10-24 United TLD Holdco Ltd.
  dance
  
  // data : 2016-06-02 Dish DBS Corporation
  data
  
  // date : 2014-11-20 dot Date Limited
  date
  
  // dating : 2013-12-05 Binky Moon, LLC
  dating
  
  // datsun : 2014-03-27 NISSAN MOTOR CO., LTD.
  datsun
  
  // day : 2014-01-30 Charleston Road Registry Inc.
  day
  
  // dclk : 2014-11-20 Charleston Road Registry Inc.
  dclk
  
  // dds : 2015-05-07 Minds + Machines Group Limited
  dds
  
  // deal : 2015-06-25 Amazon Registry Services, Inc.
  deal
  
  // dealer : 2014-12-22 Dealer Dot Com, Inc.
  dealer
  
  // deals : 2014-05-22 Binky Moon, LLC
  deals
  
  // degree : 2014-03-06 United TLD Holdco Ltd.
  degree
  
  // delivery : 2014-09-11 Binky Moon, LLC
  delivery
  
  // dell : 2014-10-24 Dell Inc.
  dell
  
  // deloitte : 2015-07-31 Deloitte Touche Tohmatsu
  deloitte
  
  // delta : 2015-02-19 Delta Air Lines, Inc.
  delta
  
  // democrat : 2013-10-24 United TLD Holdco Ltd.
  democrat
  
  // dental : 2014-03-20 Binky Moon, LLC
  dental
  
  // dentist : 2014-03-20 United TLD Holdco Ltd.
  dentist
  
  // desi : 2013-11-14 Desi Networks LLC
  desi
  
  // design : 2014-11-07 Top Level Design, LLC
  design
  
  // dev : 2014-10-16 Charleston Road Registry Inc.
  dev
  
  // dhl : 2015-07-23 Deutsche Post AG
  dhl
  
  // diamonds : 2013-09-22 Binky Moon, LLC
  diamonds
  
  // diet : 2014-06-26 Uniregistry, Corp.
  diet
  
  // digital : 2014-03-06 Binky Moon, LLC
  digital
  
  // direct : 2014-04-10 Binky Moon, LLC
  direct
  
  // directory : 2013-09-20 Binky Moon, LLC
  directory
  
  // discount : 2014-03-06 Binky Moon, LLC
  discount
  
  // discover : 2015-07-23 Discover Financial Services
  discover
  
  // dish : 2015-07-30 Dish DBS Corporation
  dish
  
  // diy : 2015-11-05 Lifestyle Domain Holdings, Inc.
  diy
  
  // dnp : 2013-12-13 Dai Nippon Printing Co., Ltd.
  dnp
  
  // docs : 2014-10-16 Charleston Road Registry Inc.
  docs
  
  // doctor : 2016-06-02 Binky Moon, LLC
  doctor
  
  // dodge : 2015-07-30 FCA US LLC.
  dodge
  
  // dog : 2014-12-04 Binky Moon, LLC
  dog
  
  // doha : 2014-09-18 Communications Regulatory Authority (CRA)
  doha
  
  // domains : 2013-10-17 Binky Moon, LLC
  domains
  
  // dot : 2015-05-21 Dish DBS Corporation
  dot
  
  // download : 2014-11-20 dot Support Limited
  download
  
  // drive : 2015-03-05 Charleston Road Registry Inc.
  drive
  
  // dtv : 2015-06-04 Dish DBS Corporation
  dtv
  
  // dubai : 2015-01-01 Dubai Smart Government Department
  dubai
  
  // duck : 2015-07-23 Johnson Shareholdings, Inc.
  duck
  
  // dunlop : 2015-07-02 The Goodyear Tire & Rubber Company
  dunlop
  
  // duns : 2015-08-06 The Dun & Bradstreet Corporation
  duns
  
  // dupont : 2015-06-25 E. I. du Pont de Nemours and Company
  dupont
  
  // durban : 2014-03-24 ZA Central Registry NPC trading as ZA Central Registry
  durban
  
  // dvag : 2014-06-23 Deutsche Vermögensberatung Aktiengesellschaft DVAG
  dvag
  
  // dvr : 2016-05-26 Hughes Satellite Systems Corporation
  dvr
  
  // earth : 2014-12-04 Interlink Co., Ltd.
  earth
  
  // eat : 2014-01-23 Charleston Road Registry Inc.
  eat
  
  // eco : 2016-07-08 Big Room Inc.
  eco
  
  // edeka : 2014-12-18 EDEKA Verband kaufmännischer Genossenschaften e.V.
  edeka
  
  // education : 2013-11-07 Binky Moon, LLC
  education
  
  // email : 2013-10-31 Binky Moon, LLC
  email
  
  // emerck : 2014-04-03 Merck KGaA
  emerck
  
  // energy : 2014-09-11 Binky Moon, LLC
  energy
  
  // engineer : 2014-03-06 United TLD Holdco Ltd.
  engineer
  
  // engineering : 2014-03-06 Binky Moon, LLC
  engineering
  
  // enterprises : 2013-09-20 Binky Moon, LLC
  enterprises
  
  // epson : 2014-12-04 Seiko Epson Corporation
  epson
  
  // equipment : 2013-08-27 Binky Moon, LLC
  equipment
  
  // ericsson : 2015-07-09 Telefonaktiebolaget L M Ericsson
  ericsson
  
  // erni : 2014-04-03 ERNI Group Holding AG
  erni
  
  // esq : 2014-05-08 Charleston Road Registry Inc.
  esq
  
  // estate : 2013-08-27 Binky Moon, LLC
  estate
  
  // esurance : 2015-07-23 Esurance Insurance Company
  esurance
  
  // etisalat : 2015-09-03 Emirates Telecommunications Corporation (trading as Etisalat)
  etisalat
  
  // eurovision : 2014-04-24 European Broadcasting Union (EBU)
  eurovision
  
  // eus : 2013-12-12 Puntueus Fundazioa
  eus
  
  // events : 2013-12-05 Binky Moon, LLC
  events
  
  // everbank : 2014-05-15 EverBank
  everbank
  
  // exchange : 2014-03-06 Binky Moon, LLC
  exchange
  
  // expert : 2013-11-21 Binky Moon, LLC
  expert
  
  // exposed : 2013-12-05 Binky Moon, LLC
  exposed
  
  // express : 2015-02-11 Binky Moon, LLC
  express
  
  // extraspace : 2015-05-14 Extra Space Storage LLC
  extraspace
  
  // fage : 2014-12-18 Fage International S.A.
  fage
  
  // fail : 2014-03-06 Binky Moon, LLC
  fail
  
  // fairwinds : 2014-11-13 FairWinds Partners, LLC
  fairwinds
  
  // faith : 2014-11-20 dot Faith Limited
  faith
  
  // family : 2015-04-02 United TLD Holdco Ltd.
  family
  
  // fan : 2014-03-06 Asiamix Digital Limited
  fan
  
  // fans : 2014-11-07 Asiamix Digital Limited
  fans
  
  // farm : 2013-11-07 Binky Moon, LLC
  farm
  
  // farmers : 2015-07-09 Farmers Insurance Exchange
  farmers
  
  // fashion : 2014-07-03 Minds + Machines Group Limited
  fashion
  
  // fast : 2014-12-18 Amazon Registry Services, Inc.
  fast
  
  // fedex : 2015-08-06 Federal Express Corporation
  fedex
  
  // feedback : 2013-12-19 Top Level Spectrum, Inc.
  feedback
  
  // ferrari : 2015-07-31 Fiat Chrysler Automobiles N.V.
  ferrari
  
  // ferrero : 2014-12-18 Ferrero Trading Lux S.A.
  ferrero
  
  // fiat : 2015-07-31 Fiat Chrysler Automobiles N.V.
  fiat
  
  // fidelity : 2015-07-30 Fidelity Brokerage Services LLC
  fidelity
  
  // fido : 2015-08-06 Rogers Communications Canada Inc.
  fido
  
  // film : 2015-01-08 Motion Picture Domain Registry Pty Ltd
  film
  
  // final : 2014-10-16 Núcleo de Informação e Coordenação do Ponto BR - NIC.br
  final
  
  // finance : 2014-03-20 Binky Moon, LLC
  finance
  
  // financial : 2014-03-06 Binky Moon, LLC
  financial
  
  // fire : 2015-06-25 Amazon Registry Services, Inc.
  fire
  
  // firestone : 2014-12-18 Bridgestone Licensing Services, Inc
  firestone
  
  // firmdale : 2014-03-27 Firmdale Holdings Limited
  firmdale
  
  // fish : 2013-12-12 Binky Moon, LLC
  fish
  
  // fishing : 2013-11-21 Minds + Machines Group Limited
  fishing
  
  // fit : 2014-11-07 Minds + Machines Group Limited
  fit
  
  // fitness : 2014-03-06 Binky Moon, LLC
  fitness
  
  // flickr : 2015-04-02 Yahoo! Domain Services Inc.
  flickr
  
  // flights : 2013-12-05 Binky Moon, LLC
  flights
  
  // flir : 2015-07-23 FLIR Systems, Inc.
  flir
  
  // florist : 2013-11-07 Binky Moon, LLC
  florist
  
  // flowers : 2014-10-09 Uniregistry, Corp.
  flowers
  
  // fly : 2014-05-08 Charleston Road Registry Inc.
  fly
  
  // foo : 2014-01-23 Charleston Road Registry Inc.
  foo
  
  // food : 2016-04-21 Lifestyle Domain Holdings, Inc.
  food
  
  // foodnetwork : 2015-07-02 Lifestyle Domain Holdings, Inc.
  foodnetwork
  
  // football : 2014-12-18 Binky Moon, LLC
  football
  
  // ford : 2014-11-13 Ford Motor Company
  ford
  
  // forex : 2014-12-11 Dotforex Registry Limited
  forex
  
  // forsale : 2014-05-22 United TLD Holdco Ltd.
  forsale
  
  // forum : 2015-04-02 Fegistry, LLC
  forum
  
  // foundation : 2013-12-05 Binky Moon, LLC
  foundation
  
  // fox : 2015-09-11 FOX Registry, LLC
  fox
  
  // free : 2015-12-10 Amazon Registry Services, Inc.
  free
  
  // fresenius : 2015-07-30 Fresenius Immobilien-Verwaltungs-GmbH
  fresenius
  
  // frl : 2014-05-15 FRLregistry B.V.
  frl
  
  // frogans : 2013-12-19 OP3FT
  frogans
  
  // frontdoor : 2015-07-02 Lifestyle Domain Holdings, Inc.
  frontdoor
  
  // frontier : 2015-02-05 Frontier Communications Corporation
  frontier
  
  // ftr : 2015-07-16 Frontier Communications Corporation
  ftr
  
  // fujitsu : 2015-07-30 Fujitsu Limited
  fujitsu
  
  // fujixerox : 2015-07-23 Xerox DNHC LLC
  fujixerox
  
  // fun : 2016-01-14 DotSpace Inc.
  fun
  
  // fund : 2014-03-20 Binky Moon, LLC
  fund
  
  // furniture : 2014-03-20 Binky Moon, LLC
  furniture
  
  // futbol : 2013-09-20 United TLD Holdco Ltd.
  futbol
  
  // fyi : 2015-04-02 Binky Moon, LLC
  fyi
  
  // gal : 2013-11-07 Asociación puntoGAL
  gal
  
  // gallery : 2013-09-13 Binky Moon, LLC
  gallery
  
  // gallo : 2015-06-11 Gallo Vineyards, Inc.
  gallo
  
  // gallup : 2015-02-19 Gallup, Inc.
  gallup
  
  // game : 2015-05-28 Uniregistry, Corp.
  game
  
  // games : 2015-05-28 United TLD Holdco Ltd.
  games
  
  // gap : 2015-07-31 The Gap, Inc.
  gap
  
  // garden : 2014-06-26 Minds + Machines Group Limited
  garden
  
  // gbiz : 2014-07-17 Charleston Road Registry Inc.
  gbiz
  
  // gdn : 2014-07-31 Joint Stock Company "Navigation-information systems"
  gdn
  
  // gea : 2014-12-04 GEA Group Aktiengesellschaft
  gea
  
  // gent : 2014-01-23 COMBELL NV
  gent
  
  // genting : 2015-03-12 Resorts World Inc Pte. Ltd.
  genting
  
  // george : 2015-07-31 Wal-Mart Stores, Inc.
  george
  
  // ggee : 2014-01-09 GMO Internet, Inc.
  ggee
  
  // gift : 2013-10-17 DotGift, LLC
  gift
  
  // gifts : 2014-07-03 Binky Moon, LLC
  gifts
  
  // gives : 2014-03-06 United TLD Holdco Ltd.
  gives
  
  // giving : 2014-11-13 Giving Limited
  giving
  
  // glade : 2015-07-23 Johnson Shareholdings, Inc.
  glade
  
  // glass : 2013-11-07 Binky Moon, LLC
  glass
  
  // gle : 2014-07-24 Charleston Road Registry Inc.
  gle
  
  // global : 2014-04-17 Dot Global Domain Registry Limited
  global
  
  // globo : 2013-12-19 Globo Comunicação e Participações S.A
  globo
  
  // gmail : 2014-05-01 Charleston Road Registry Inc.
  gmail
  
  // gmbh : 2016-01-29 Binky Moon, LLC
  gmbh
  
  // gmo : 2014-01-09 GMO Internet Pte. Ltd.
  gmo
  
  // gmx : 2014-04-24 1&1 Mail & Media GmbH
  gmx
  
  // godaddy : 2015-07-23 Go Daddy East, LLC
  godaddy
  
  // gold : 2015-01-22 Binky Moon, LLC
  gold
  
  // goldpoint : 2014-11-20 YODOBASHI CAMERA CO.,LTD.
  goldpoint
  
  // golf : 2014-12-18 Binky Moon, LLC
  golf
  
  // goo : 2014-12-18 NTT Resonant Inc.
  goo
  
  // goodyear : 2015-07-02 The Goodyear Tire & Rubber Company
  goodyear
  
  // goog : 2014-11-20 Charleston Road Registry Inc.
  goog
  
  // google : 2014-07-24 Charleston Road Registry Inc.
  google
  
  // gop : 2014-01-16 Republican State Leadership Committee, Inc.
  gop
  
  // got : 2014-12-18 Amazon Registry Services, Inc.
  got
  
  // grainger : 2015-05-07 Grainger Registry Services, LLC
  grainger
  
  // graphics : 2013-09-13 Binky Moon, LLC
  graphics
  
  // gratis : 2014-03-20 Binky Moon, LLC
  gratis
  
  // green : 2014-05-08 Afilias plc
  green
  
  // gripe : 2014-03-06 Binky Moon, LLC
  gripe
  
  // grocery : 2016-06-16 Wal-Mart Stores, Inc.
  grocery
  
  // group : 2014-08-15 Binky Moon, LLC
  group
  
  // guardian : 2015-07-30 The Guardian Life Insurance Company of America
  guardian
  
  // gucci : 2014-11-13 Guccio Gucci S.p.a.
  gucci
  
  // guge : 2014-08-28 Charleston Road Registry Inc.
  guge
  
  // guide : 2013-09-13 Binky Moon, LLC
  guide
  
  // guitars : 2013-11-14 Uniregistry, Corp.
  guitars
  
  // guru : 2013-08-27 Binky Moon, LLC
  guru
  
  // hair : 2015-12-03 L'Oréal
  hair
  
  // hamburg : 2014-02-20 Hamburg Top-Level-Domain GmbH
  hamburg
  
  // hangout : 2014-11-13 Charleston Road Registry Inc.
  hangout
  
  // haus : 2013-12-05 United TLD Holdco Ltd.
  haus
  
  // hbo : 2015-07-30 HBO Registry Services, Inc.
  hbo
  
  // hdfc : 2015-07-30 HOUSING DEVELOPMENT FINANCE CORPORATION LIMITED
  hdfc
  
  // hdfcbank : 2015-02-12 HDFC Bank Limited
  hdfcbank
  
  // health : 2015-02-11 DotHealth, LLC
  health
  
  // healthcare : 2014-06-12 Binky Moon, LLC
  healthcare
  
  // help : 2014-06-26 Uniregistry, Corp.
  help
  
  // helsinki : 2015-02-05 City of Helsinki
  helsinki
  
  // here : 2014-02-06 Charleston Road Registry Inc.
  here
  
  // hermes : 2014-07-10 HERMES INTERNATIONAL
  hermes
  
  // hgtv : 2015-07-02 Lifestyle Domain Holdings, Inc.
  hgtv
  
  // hiphop : 2014-03-06 Uniregistry, Corp.
  hiphop
  
  // hisamitsu : 2015-07-16 Hisamitsu Pharmaceutical Co.,Inc.
  hisamitsu
  
  // hitachi : 2014-10-31 Hitachi, Ltd.
  hitachi
  
  // hiv : 2014-03-13 Uniregistry, Corp.
  hiv
  
  // hkt : 2015-05-14 PCCW-HKT DataCom Services Limited
  hkt
  
  // hockey : 2015-03-19 Binky Moon, LLC
  hockey
  
  // holdings : 2013-08-27 Binky Moon, LLC
  holdings
  
  // holiday : 2013-11-07 Binky Moon, LLC
  holiday
  
  // homedepot : 2015-04-02 Home Depot Product Authority, LLC
  homedepot
  
  // homegoods : 2015-07-16 The TJX Companies, Inc.
  homegoods
  
  // homes : 2014-01-09 DERHomes, LLC
  homes
  
  // homesense : 2015-07-16 The TJX Companies, Inc.
  homesense
  
  // honda : 2014-12-18 Honda Motor Co., Ltd.
  honda
  
  // honeywell : 2015-07-23 Honeywell GTLD LLC
  honeywell
  
  // horse : 2013-11-21 Minds + Machines Group Limited
  horse
  
  // hospital : 2016-10-20 Binky Moon, LLC
  hospital
  
  // host : 2014-04-17 DotHost Inc.
  host
  
  // hosting : 2014-05-29 Uniregistry, Corp.
  hosting
  
  // hot : 2015-08-27 Amazon Registry Services, Inc.
  hot
  
  // hoteles : 2015-03-05 Travel Reservations SRL
  hoteles
  
  // hotels : 2016-04-07 Booking.com B.V.
  hotels
  
  // hotmail : 2014-12-18 Microsoft Corporation
  hotmail
  
  // house : 2013-11-07 Binky Moon, LLC
  house
  
  // how : 2014-01-23 Charleston Road Registry Inc.
  how
  
  // hsbc : 2014-10-24 HSBC Global Services (UK) Limited
  hsbc
  
  // hughes : 2015-07-30 Hughes Satellite Systems Corporation
  hughes
  
  // hyatt : 2015-07-30 Hyatt GTLD, L.L.C.
  hyatt
  
  // hyundai : 2015-07-09 Hyundai Motor Company
  hyundai
  
  // ibm : 2014-07-31 International Business Machines Corporation
  ibm
  
  // icbc : 2015-02-19 Industrial and Commercial Bank of China Limited
  icbc
  
  // ice : 2014-10-30 IntercontinentalExchange, Inc.
  ice
  
  // icu : 2015-01-08 ShortDot SA
  icu
  
  // ieee : 2015-07-23 IEEE Global LLC
  ieee
  
  // ifm : 2014-01-30 ifm electronic gmbh
  ifm
  
  // ikano : 2015-07-09 Ikano S.A.
  ikano
  
  // imamat : 2015-08-06 Fondation Aga Khan (Aga Khan Foundation)
  imamat
  
  // imdb : 2015-06-25 Amazon Registry Services, Inc.
  imdb
  
  // immo : 2014-07-10 Binky Moon, LLC
  immo
  
  // immobilien : 2013-11-07 United TLD Holdco Ltd.
  immobilien
  
  // inc : 2018-03-10 GTLD Limited
  inc
  
  // industries : 2013-12-05 Binky Moon, LLC
  industries
  
  // infiniti : 2014-03-27 NISSAN MOTOR CO., LTD.
  infiniti
  
  // ing : 2014-01-23 Charleston Road Registry Inc.
  ing
  
  // ink : 2013-12-05 Top Level Design, LLC
  ink
  
  // institute : 2013-11-07 Binky Moon, LLC
  institute
  
  // insurance : 2015-02-19 fTLD Registry Services LLC
  insurance
  
  // insure : 2014-03-20 Binky Moon, LLC
  insure
  
  // intel : 2015-08-06 Intel Corporation
  intel
  
  // international : 2013-11-07 Binky Moon, LLC
  international
  
  // intuit : 2015-07-30 Intuit Administrative Services, Inc.
  intuit
  
  // investments : 2014-03-20 Binky Moon, LLC
  investments
  
  // ipiranga : 2014-08-28 Ipiranga Produtos de Petroleo S.A.
  ipiranga
  
  // irish : 2014-08-07 Binky Moon, LLC
  irish
  
  // iselect : 2015-02-11 iSelect Ltd
  iselect
  
  // ismaili : 2015-08-06 Fondation Aga Khan (Aga Khan Foundation)
  ismaili
  
  // ist : 2014-08-28 Istanbul Metropolitan Municipality
  ist
  
  // istanbul : 2014-08-28 Istanbul Metropolitan Municipality
  istanbul
  
  // itau : 2014-10-02 Itau Unibanco Holding S.A.
  itau
  
  // itv : 2015-07-09 ITV Services Limited
  itv
  
  // iveco : 2015-09-03 CNH Industrial N.V.
  iveco
  
  // jaguar : 2014-11-13 Jaguar Land Rover Ltd
  jaguar
  
  // java : 2014-06-19 Oracle Corporation
  java
  
  // jcb : 2014-11-20 JCB Co., Ltd.
  jcb
  
  // jcp : 2015-04-23 JCP Media, Inc.
  jcp
  
  // jeep : 2015-07-30 FCA US LLC.
  jeep
  
  // jetzt : 2014-01-09 Binky Moon, LLC
  jetzt
  
  // jewelry : 2015-03-05 Binky Moon, LLC
  jewelry
  
  // jio : 2015-04-02 Reliance Industries Limited
  jio
  
  // jll : 2015-04-02 Jones Lang LaSalle Incorporated
  jll
  
  // jmp : 2015-03-26 Matrix IP LLC
  jmp
  
  // jnj : 2015-06-18 Johnson & Johnson Services, Inc.
  jnj
  
  // joburg : 2014-03-24 ZA Central Registry NPC trading as ZA Central Registry
  joburg
  
  // jot : 2014-12-18 Amazon Registry Services, Inc.
  jot
  
  // joy : 2014-12-18 Amazon Registry Services, Inc.
  joy
  
  // jpmorgan : 2015-04-30 JPMorgan Chase Bank, National Association
  jpmorgan
  
  // jprs : 2014-09-18 Japan Registry Services Co., Ltd.
  jprs
  
  // juegos : 2014-03-20 Uniregistry, Corp.
  juegos
  
  // juniper : 2015-07-30 JUNIPER NETWORKS, INC.
  juniper
  
  // kaufen : 2013-11-07 United TLD Holdco Ltd.
  kaufen
  
  // kddi : 2014-09-12 KDDI CORPORATION
  kddi
  
  // kerryhotels : 2015-04-30 Kerry Trading Co. Limited
  kerryhotels
  
  // kerrylogistics : 2015-04-09 Kerry Trading Co. Limited
  kerrylogistics
  
  // kerryproperties : 2015-04-09 Kerry Trading Co. Limited
  kerryproperties
  
  // kfh : 2014-12-04 Kuwait Finance House
  kfh
  
  // kia : 2015-07-09 KIA MOTORS CORPORATION
  kia
  
  // kim : 2013-09-23 Afilias plc
  kim
  
  // kinder : 2014-11-07 Ferrero Trading Lux S.A.
  kinder
  
  // kindle : 2015-06-25 Amazon Registry Services, Inc.
  kindle
  
  // kitchen : 2013-09-20 Binky Moon, LLC
  kitchen
  
  // kiwi : 2013-09-20 DOT KIWI LIMITED
  kiwi
  
  // koeln : 2014-01-09 punkt.wien GmbH
  koeln
  
  // komatsu : 2015-01-08 Komatsu Ltd.
  komatsu
  
  // kosher : 2015-08-20 Kosher Marketing Assets LLC
  kosher
  
  // kpmg : 2015-04-23 KPMG International Cooperative (KPMG International Genossenschaft)
  kpmg
  
  // kpn : 2015-01-08 Koninklijke KPN N.V.
  kpn
  
  // krd : 2013-12-05 KRG Department of Information Technology
  krd
  
  // kred : 2013-12-19 KredTLD Pty Ltd
  kred
  
  // kuokgroup : 2015-04-09 Kerry Trading Co. Limited
  kuokgroup
  
  // kyoto : 2014-11-07 Academic Institution: Kyoto Jyoho Gakuen
  kyoto
  
  // lacaixa : 2014-01-09 Fundación Bancaria Caixa d’Estalvis i Pensions de Barcelona, “la Caixa”
  lacaixa
  
  // ladbrokes : 2015-08-06 LADBROKES INTERNATIONAL PLC
  ladbrokes
  
  // lamborghini : 2015-06-04 Automobili Lamborghini S.p.A.
  lamborghini
  
  // lamer : 2015-10-01 The Estée Lauder Companies Inc.
  lamer
  
  // lancaster : 2015-02-12 LANCASTER
  lancaster
  
  // lancia : 2015-07-31 Fiat Chrysler Automobiles N.V.
  lancia
  
  // lancome : 2015-07-23 L'Oréal
  lancome
  
  // land : 2013-09-10 Binky Moon, LLC
  land
  
  // landrover : 2014-11-13 Jaguar Land Rover Ltd
  landrover
  
  // lanxess : 2015-07-30 LANXESS Corporation
  lanxess
  
  // lasalle : 2015-04-02 Jones Lang LaSalle Incorporated
  lasalle
  
  // lat : 2014-10-16 ECOM-LAC Federaciòn de Latinoamèrica y el Caribe para Internet y el Comercio Electrònico
  lat
  
  // latino : 2015-07-30 Dish DBS Corporation
  latino
  
  // latrobe : 2014-06-16 La Trobe University
  latrobe
  
  // law : 2015-01-22 Minds + Machines Group Limited
  law
  
  // lawyer : 2014-03-20 United TLD Holdco Ltd.
  lawyer
  
  // lds : 2014-03-20 IRI Domain Management, LLC ("Applicant")
  lds
  
  // lease : 2014-03-06 Binky Moon, LLC
  lease
  
  // leclerc : 2014-08-07 A.C.D. LEC Association des Centres Distributeurs Edouard Leclerc
  leclerc
  
  // lefrak : 2015-07-16 LeFrak Organization, Inc.
  lefrak
  
  // legal : 2014-10-16 Binky Moon, LLC
  legal
  
  // lego : 2015-07-16 LEGO Juris A/S
  lego
  
  // lexus : 2015-04-23 TOYOTA MOTOR CORPORATION
  lexus
  
  // lgbt : 2014-05-08 Afilias plc
  lgbt
  
  // liaison : 2014-10-02 Liaison Technologies, Incorporated
  liaison
  
  // lidl : 2014-09-18 Schwarz Domains und Services GmbH & Co. KG
  lidl
  
  // life : 2014-02-06 Binky Moon, LLC
  life
  
  // lifeinsurance : 2015-01-15 American Council of Life Insurers
  lifeinsurance
  
  // lifestyle : 2014-12-11 Lifestyle Domain Holdings, Inc.
  lifestyle
  
  // lighting : 2013-08-27 Binky Moon, LLC
  lighting
  
  // like : 2014-12-18 Amazon Registry Services, Inc.
  like
  
  // lilly : 2015-07-31 Eli Lilly and Company
  lilly
  
  // limited : 2014-03-06 Binky Moon, LLC
  limited
  
  // limo : 2013-10-17 Binky Moon, LLC
  limo
  
  // lincoln : 2014-11-13 Ford Motor Company
  lincoln
  
  // linde : 2014-12-04 Linde Aktiengesellschaft
  linde
  
  // link : 2013-11-14 Uniregistry, Corp.
  link
  
  // lipsy : 2015-06-25 Lipsy Ltd
  lipsy
  
  // live : 2014-12-04 United TLD Holdco Ltd.
  live
  
  // living : 2015-07-30 Lifestyle Domain Holdings, Inc.
  living
  
  // lixil : 2015-03-19 LIXIL Group Corporation
  lixil
  
  // llc : 2017-12-14 Afilias plc
  llc
  
  // loan : 2014-11-20 dot Loan Limited
  loan
  
  // loans : 2014-03-20 Binky Moon, LLC
  loans
  
  // locker : 2015-06-04 Dish DBS Corporation
  locker
  
  // locus : 2015-06-25 Locus Analytics LLC
  locus
  
  // loft : 2015-07-30 Annco, Inc.
  loft
  
  // lol : 2015-01-30 Uniregistry, Corp.
  lol
  
  // london : 2013-11-14 Dot London Domains Limited
  london
  
  // lotte : 2014-11-07 Lotte Holdings Co., Ltd.
  lotte
  
  // lotto : 2014-04-10 Afilias plc
  lotto
  
  // love : 2014-12-22 Merchant Law Group LLP
  love
  
  // lpl : 2015-07-30 LPL Holdings, Inc.
  lpl
  
  // lplfinancial : 2015-07-30 LPL Holdings, Inc.
  lplfinancial
  
  // ltd : 2014-09-25 Binky Moon, LLC
  ltd
  
  // ltda : 2014-04-17 InterNetX, Corp
  ltda
  
  // lundbeck : 2015-08-06 H. Lundbeck A/S
  lundbeck
  
  // lupin : 2014-11-07 LUPIN LIMITED
  lupin
  
  // luxe : 2014-01-09 Minds + Machines Group Limited
  luxe
  
  // luxury : 2013-10-17 Luxury Partners, LLC
  luxury
  
  // macys : 2015-07-31 Macys, Inc.
  macys
  
  // madrid : 2014-05-01 Comunidad de Madrid
  madrid
  
  // maif : 2014-10-02 Mutuelle Assurance Instituteur France (MAIF)
  maif
  
  // maison : 2013-12-05 Binky Moon, LLC
  maison
  
  // makeup : 2015-01-15 L'Oréal
  makeup
  
  // man : 2014-12-04 MAN SE
  man
  
  // management : 2013-11-07 Binky Moon, LLC
  management
  
  // mango : 2013-10-24 PUNTO FA S.L.
  mango
  
  // map : 2016-06-09 Charleston Road Registry Inc.
  map
  
  // market : 2014-03-06 United TLD Holdco Ltd.
  market
  
  // marketing : 2013-11-07 Binky Moon, LLC
  marketing
  
  // markets : 2014-12-11 Dotmarkets Registry Limited
  markets
  
  // marriott : 2014-10-09 Marriott Worldwide Corporation
  marriott
  
  // marshalls : 2015-07-16 The TJX Companies, Inc.
  marshalls
  
  // maserati : 2015-07-31 Fiat Chrysler Automobiles N.V.
  maserati
  
  // mattel : 2015-08-06 Mattel Sites, Inc.
  mattel
  
  // mba : 2015-04-02 Binky Moon, LLC
  mba
  
  // mckinsey : 2015-07-31 McKinsey Holdings, Inc.
  mckinsey
  
  // med : 2015-08-06 Medistry LLC
  med
  
  // media : 2014-03-06 Binky Moon, LLC
  media
  
  // meet : 2014-01-16 Charleston Road Registry Inc.
  meet
  
  // melbourne : 2014-05-29 The Crown in right of the State of Victoria, represented by its Department of State Development, Business and Innovation
  melbourne
  
  // meme : 2014-01-30 Charleston Road Registry Inc.
  meme
  
  // memorial : 2014-10-16 Dog Beach, LLC
  memorial
  
  // men : 2015-02-26 Exclusive Registry Limited
  men
  
  // menu : 2013-09-11 Wedding TLD2, LLC
  menu
  
  // merckmsd : 2016-07-14 MSD Registry Holdings, Inc.
  merckmsd
  
  // metlife : 2015-05-07 MetLife Services and Solutions, LLC
  metlife
  
  // miami : 2013-12-19 Minds + Machines Group Limited
  miami
  
  // microsoft : 2014-12-18 Microsoft Corporation
  microsoft
  
  // mini : 2014-01-09 Bayerische Motoren Werke Aktiengesellschaft
  mini
  
  // mint : 2015-07-30 Intuit Administrative Services, Inc.
  mint
  
  // mit : 2015-07-02 Massachusetts Institute of Technology
  mit
  
  // mitsubishi : 2015-07-23 Mitsubishi Corporation
  mitsubishi
  
  // mlb : 2015-05-21 MLB Advanced Media DH, LLC
  mlb
  
  // mls : 2015-04-23 The Canadian Real Estate Association
  mls
  
  // mma : 2014-11-07 MMA IARD
  mma
  
  // mobile : 2016-06-02 Dish DBS Corporation
  mobile
  
  // mobily : 2014-12-18 GreenTech Consultancy Company W.L.L.
  mobily
  
  // moda : 2013-11-07 United TLD Holdco Ltd.
  moda
  
  // moe : 2013-11-13 Interlink Co., Ltd.
  moe
  
  // moi : 2014-12-18 Amazon Registry Services, Inc.
  moi
  
  // mom : 2015-04-16 Uniregistry, Corp.
  mom
  
  // monash : 2013-09-30 Monash University
  monash
  
  // money : 2014-10-16 Binky Moon, LLC
  money
  
  // monster : 2015-09-11 Monster Worldwide, Inc.
  monster
  
  // mopar : 2015-07-30 FCA US LLC.
  mopar
  
  // mormon : 2013-12-05 IRI Domain Management, LLC ("Applicant")
  mormon
  
  // mortgage : 2014-03-20 United TLD Holdco Ltd.
  mortgage
  
  // moscow : 2013-12-19 Foundation for Assistance for Internet Technologies and Infrastructure Development (FAITID)
  moscow
  
  // moto : 2015-06-04 Motorola Trademark Holdings, LLC
  moto
  
  // motorcycles : 2014-01-09 DERMotorcycles, LLC
  motorcycles
  
  // mov : 2014-01-30 Charleston Road Registry Inc.
  mov
  
  // movie : 2015-02-05 Binky Moon, LLC
  movie
  
  // movistar : 2014-10-16 Telefónica S.A.
  movistar
  
  // msd : 2015-07-23 MSD Registry Holdings, Inc.
  msd
  
  // mtn : 2014-12-04 MTN Dubai Limited
  mtn
  
  // mtr : 2015-03-12 MTR Corporation Limited
  mtr
  
  // mutual : 2015-04-02 Northwestern Mutual MU TLD Registry, LLC
  mutual
  
  // nab : 2015-08-20 National Australia Bank Limited
  nab
  
  // nadex : 2014-12-11 Nadex Domains, Inc.
  nadex
  
  // nagoya : 2013-10-24 GMO Registry, Inc.
  nagoya
  
  // nationwide : 2015-07-23 Nationwide Mutual Insurance Company
  nationwide
  
  // natura : 2015-03-12 NATURA COSMÉTICOS S.A.
  natura
  
  // navy : 2014-03-06 United TLD Holdco Ltd.
  navy
  
  // nba : 2015-07-31 NBA REGISTRY, LLC
  nba
  
  // nec : 2015-01-08 NEC Corporation
  nec
  
  // netbank : 2014-06-26 COMMONWEALTH BANK OF AUSTRALIA
  netbank
  
  // netflix : 2015-06-18 Netflix, Inc.
  netflix
  
  // network : 2013-11-14 Binky Moon, LLC
  network
  
  // neustar : 2013-12-05 Registry Services, LLC
  neustar
  
  // new : 2014-01-30 Charleston Road Registry Inc.
  new
  
  // newholland : 2015-09-03 CNH Industrial N.V.
  newholland
  
  // news : 2014-12-18 United TLD Holdco Ltd.
  news
  
  // next : 2015-06-18 Next plc
  next
  
  // nextdirect : 2015-06-18 Next plc
  nextdirect
  
  // nexus : 2014-07-24 Charleston Road Registry Inc.
  nexus
  
  // nfl : 2015-07-23 NFL Reg Ops LLC
  nfl
  
  // ngo : 2014-03-06 Public Interest Registry
  ngo
  
  // nhk : 2014-02-13 Japan Broadcasting Corporation (NHK)
  nhk
  
  // nico : 2014-12-04 DWANGO Co., Ltd.
  nico
  
  // nike : 2015-07-23 NIKE, Inc.
  nike
  
  // nikon : 2015-05-21 NIKON CORPORATION
  nikon
  
  // ninja : 2013-11-07 United TLD Holdco Ltd.
  ninja
  
  // nissan : 2014-03-27 NISSAN MOTOR CO., LTD.
  nissan
  
  // nissay : 2015-10-29 Nippon Life Insurance Company
  nissay
  
  // nokia : 2015-01-08 Nokia Corporation
  nokia
  
  // northwesternmutual : 2015-06-18 Northwestern Mutual Registry, LLC
  northwesternmutual
  
  // norton : 2014-12-04 Symantec Corporation
  norton
  
  // now : 2015-06-25 Amazon Registry Services, Inc.
  now
  
  // nowruz : 2014-09-04 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  nowruz
  
  // nowtv : 2015-05-14 Starbucks (HK) Limited
  nowtv
  
  // nra : 2014-05-22 NRA Holdings Company, INC.
  nra
  
  // nrw : 2013-11-21 Minds + Machines GmbH
  nrw
  
  // ntt : 2014-10-31 NIPPON TELEGRAPH AND TELEPHONE CORPORATION
  ntt
  
  // nyc : 2014-01-23 The City of New York by and through the New York City Department of Information Technology & Telecommunications
  nyc
  
  // obi : 2014-09-25 OBI Group Holding SE & Co. KGaA
  obi
  
  // observer : 2015-04-30 Top Level Spectrum, Inc.
  observer
  
  // off : 2015-07-23 Johnson Shareholdings, Inc.
  off
  
  // office : 2015-03-12 Microsoft Corporation
  office
  
  // okinawa : 2013-12-05 BRregistry, Inc.
  okinawa
  
  // olayan : 2015-05-14 Crescent Holding GmbH
  olayan
  
  // olayangroup : 2015-05-14 Crescent Holding GmbH
  olayangroup
  
  // oldnavy : 2015-07-31 The Gap, Inc.
  oldnavy
  
  // ollo : 2015-06-04 Dish DBS Corporation
  ollo
  
  // omega : 2015-01-08 The Swatch Group Ltd
  omega
  
  // one : 2014-11-07 One.com A/S
  one
  
  // ong : 2014-03-06 Public Interest Registry
  ong
  
  // onl : 2013-09-16 I-Registry Ltd.
  onl
  
  // online : 2015-01-15 DotOnline Inc.
  online
  
  // onyourside : 2015-07-23 Nationwide Mutual Insurance Company
  onyourside
  
  // ooo : 2014-01-09 INFIBEAM INCORPORATION LIMITED
  ooo
  
  // open : 2015-07-31 American Express Travel Related Services Company, Inc.
  open
  
  // oracle : 2014-06-19 Oracle Corporation
  oracle
  
  // orange : 2015-03-12 Orange Brand Services Limited
  orange
  
  // organic : 2014-03-27 Afilias plc
  organic
  
  // origins : 2015-10-01 The Estée Lauder Companies Inc.
  origins
  
  // osaka : 2014-09-04 Osaka Registry Co., Ltd.
  osaka
  
  // otsuka : 2013-10-11 Otsuka Holdings Co., Ltd.
  otsuka
  
  // ott : 2015-06-04 Dish DBS Corporation
  ott
  
  // ovh : 2014-01-16 OVH SAS
  ovh
  
  // page : 2014-12-04 Charleston Road Registry Inc.
  page
  
  // panasonic : 2015-07-30 Panasonic Corporation
  panasonic
  
  // paris : 2014-01-30 City of Paris
  paris
  
  // pars : 2014-09-04 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  pars
  
  // partners : 2013-12-05 Binky Moon, LLC
  partners
  
  // parts : 2013-12-05 Binky Moon, LLC
  parts
  
  // party : 2014-09-11 Blue Sky Registry Limited
  party
  
  // passagens : 2015-03-05 Travel Reservations SRL
  passagens
  
  // pay : 2015-08-27 Amazon Registry Services, Inc.
  pay
  
  // pccw : 2015-05-14 PCCW Enterprises Limited
  pccw
  
  // pet : 2015-05-07 Afilias plc
  pet
  
  // pfizer : 2015-09-11 Pfizer Inc.
  pfizer
  
  // pharmacy : 2014-06-19 National Association of Boards of Pharmacy
  pharmacy
  
  // phd : 2016-07-28 Charleston Road Registry Inc.
  phd
  
  // philips : 2014-11-07 Koninklijke Philips N.V.
  philips
  
  // phone : 2016-06-02 Dish DBS Corporation
  phone
  
  // photo : 2013-11-14 Uniregistry, Corp.
  photo
  
  // photography : 2013-09-20 Binky Moon, LLC
  photography
  
  // photos : 2013-10-17 Binky Moon, LLC
  photos
  
  // physio : 2014-05-01 PhysBiz Pty Ltd
  physio
  
  // piaget : 2014-10-16 Richemont DNS Inc.
  piaget
  
  // pics : 2013-11-14 Uniregistry, Corp.
  pics
  
  // pictet : 2014-06-26 Pictet Europe S.A.
  pictet
  
  // pictures : 2014-03-06 Binky Moon, LLC
  pictures
  
  // pid : 2015-01-08 Top Level Spectrum, Inc.
  pid
  
  // pin : 2014-12-18 Amazon Registry Services, Inc.
  pin
  
  // ping : 2015-06-11 Ping Registry Provider, Inc.
  ping
  
  // pink : 2013-10-01 Afilias plc
  pink
  
  // pioneer : 2015-07-16 Pioneer Corporation
  pioneer
  
  // pizza : 2014-06-26 Binky Moon, LLC
  pizza
  
  // place : 2014-04-24 Binky Moon, LLC
  place
  
  // play : 2015-03-05 Charleston Road Registry Inc.
  play
  
  // playstation : 2015-07-02 Sony Computer Entertainment Inc.
  playstation
  
  // plumbing : 2013-09-10 Binky Moon, LLC
  plumbing
  
  // plus : 2015-02-05 Binky Moon, LLC
  plus
  
  // pnc : 2015-07-02 PNC Domain Co., LLC
  pnc
  
  // pohl : 2014-06-23 Deutsche Vermögensberatung Aktiengesellschaft DVAG
  pohl
  
  // poker : 2014-07-03 Afilias plc
  poker
  
  // politie : 2015-08-20 Politie Nederland
  politie
  
  // porn : 2014-10-16 ICM Registry PN LLC
  porn
  
  // pramerica : 2015-07-30 Prudential Financial, Inc.
  pramerica
  
  // praxi : 2013-12-05 Praxi S.p.A.
  praxi
  
  // press : 2014-04-03 DotPress Inc.
  press
  
  // prime : 2015-06-25 Amazon Registry Services, Inc.
  prime
  
  // prod : 2014-01-23 Charleston Road Registry Inc.
  prod
  
  // productions : 2013-12-05 Binky Moon, LLC
  productions
  
  // prof : 2014-07-24 Charleston Road Registry Inc.
  prof
  
  // progressive : 2015-07-23 Progressive Casualty Insurance Company
  progressive
  
  // promo : 2014-12-18 Afilias plc
  promo
  
  // properties : 2013-12-05 Binky Moon, LLC
  properties
  
  // property : 2014-05-22 Uniregistry, Corp.
  property
  
  // protection : 2015-04-23 XYZ.COM LLC
  protection
  
  // pru : 2015-07-30 Prudential Financial, Inc.
  pru
  
  // prudential : 2015-07-30 Prudential Financial, Inc.
  prudential
  
  // pub : 2013-12-12 United TLD Holdco Ltd.
  pub
  
  // pwc : 2015-10-29 PricewaterhouseCoopers LLP
  pwc
  
  // qpon : 2013-11-14 dotCOOL, Inc.
  qpon
  
  // quebec : 2013-12-19 PointQuébec Inc
  quebec
  
  // quest : 2015-03-26 Quest ION Limited
  quest
  
  // qvc : 2015-07-30 QVC, Inc.
  qvc
  
  // racing : 2014-12-04 Premier Registry Limited
  racing
  
  // radio : 2016-07-21 European Broadcasting Union (EBU)
  radio
  
  // raid : 2015-07-23 Johnson Shareholdings, Inc.
  raid
  
  // read : 2014-12-18 Amazon Registry Services, Inc.
  read
  
  // realestate : 2015-09-11 dotRealEstate LLC
  realestate
  
  // realtor : 2014-05-29 Real Estate Domains LLC
  realtor
  
  // realty : 2015-03-19 Fegistry, LLC
  realty
  
  // recipes : 2013-10-17 Binky Moon, LLC
  recipes
  
  // red : 2013-11-07 Afilias plc
  red
  
  // redstone : 2014-10-31 Redstone Haute Couture Co., Ltd.
  redstone
  
  // redumbrella : 2015-03-26 Travelers TLD, LLC
  redumbrella
  
  // rehab : 2014-03-06 United TLD Holdco Ltd.
  rehab
  
  // reise : 2014-03-13 Binky Moon, LLC
  reise
  
  // reisen : 2014-03-06 Binky Moon, LLC
  reisen
  
  // reit : 2014-09-04 National Association of Real Estate Investment Trusts, Inc.
  reit
  
  // reliance : 2015-04-02 Reliance Industries Limited
  reliance
  
  // ren : 2013-12-12 Beijing Qianxiang Wangjing Technology Development Co., Ltd.
  ren
  
  // rent : 2014-12-04 XYZ.COM LLC
  rent
  
  // rentals : 2013-12-05 Binky Moon, LLC
  rentals
  
  // repair : 2013-11-07 Binky Moon, LLC
  repair
  
  // report : 2013-12-05 Binky Moon, LLC
  report
  
  // republican : 2014-03-20 United TLD Holdco Ltd.
  republican
  
  // rest : 2013-12-19 Punto 2012 Sociedad Anonima Promotora de Inversion de Capital Variable
  rest
  
  // restaurant : 2014-07-03 Binky Moon, LLC
  restaurant
  
  // review : 2014-11-20 dot Review Limited
  review
  
  // reviews : 2013-09-13 United TLD Holdco Ltd.
  reviews
  
  // rexroth : 2015-06-18 Robert Bosch GMBH
  rexroth
  
  // rich : 2013-11-21 I-Registry Ltd.
  rich
  
  // richardli : 2015-05-14 Pacific Century Asset Management (HK) Limited
  richardli
  
  // ricoh : 2014-11-20 Ricoh Company, Ltd.
  ricoh
  
  // rightathome : 2015-07-23 Johnson Shareholdings, Inc.
  rightathome
  
  // ril : 2015-04-02 Reliance Industries Limited
  ril
  
  // rio : 2014-02-27 Empresa Municipal de Informática SA - IPLANRIO
  rio
  
  // rip : 2014-07-10 United TLD Holdco Ltd.
  rip
  
  // rmit : 2015-11-19 Royal Melbourne Institute of Technology
  rmit
  
  // rocher : 2014-12-18 Ferrero Trading Lux S.A.
  rocher
  
  // rocks : 2013-11-14 United TLD Holdco Ltd.
  rocks
  
  // rodeo : 2013-12-19 Minds + Machines Group Limited
  rodeo
  
  // rogers : 2015-08-06 Rogers Communications Canada Inc.
  rogers
  
  // room : 2014-12-18 Amazon Registry Services, Inc.
  room
  
  // rsvp : 2014-05-08 Charleston Road Registry Inc.
  rsvp
  
  // rugby : 2016-12-15 World Rugby Strategic Developments Limited
  rugby
  
  // ruhr : 2013-10-02 regiodot GmbH & Co. KG
  ruhr
  
  // run : 2015-03-19 Binky Moon, LLC
  run
  
  // rwe : 2015-04-02 RWE AG
  rwe
  
  // ryukyu : 2014-01-09 BRregistry, Inc.
  ryukyu
  
  // saarland : 2013-12-12 dotSaarland GmbH
  saarland
  
  // safe : 2014-12-18 Amazon Registry Services, Inc.
  safe
  
  // safety : 2015-01-08 Safety Registry Services, LLC.
  safety
  
  // sakura : 2014-12-18 SAKURA Internet Inc.
  sakura
  
  // sale : 2014-10-16 United TLD Holdco Ltd.
  sale
  
  // salon : 2014-12-11 Binky Moon, LLC
  salon
  
  // samsclub : 2015-07-31 Wal-Mart Stores, Inc.
  samsclub
  
  // samsung : 2014-04-03 SAMSUNG SDS CO., LTD
  samsung
  
  // sandvik : 2014-11-13 Sandvik AB
  sandvik
  
  // sandvikcoromant : 2014-11-07 Sandvik AB
  sandvikcoromant
  
  // sanofi : 2014-10-09 Sanofi
  sanofi
  
  // sap : 2014-03-27 SAP AG
  sap
  
  // sarl : 2014-07-03 Binky Moon, LLC
  sarl
  
  // sas : 2015-04-02 Research IP LLC
  sas
  
  // save : 2015-06-25 Amazon Registry Services, Inc.
  save
  
  // saxo : 2014-10-31 Saxo Bank A/S
  saxo
  
  // sbi : 2015-03-12 STATE BANK OF INDIA
  sbi
  
  // sbs : 2014-11-07 SPECIAL BROADCASTING SERVICE CORPORATION
  sbs
  
  // sca : 2014-03-13 SVENSKA CELLULOSA AKTIEBOLAGET SCA (publ)
  sca
  
  // scb : 2014-02-20 The Siam Commercial Bank Public Company Limited ("SCB")
  scb
  
  // schaeffler : 2015-08-06 Schaeffler Technologies AG & Co. KG
  schaeffler
  
  // schmidt : 2014-04-03 SALM S.A.S.
  schmidt
  
  // scholarships : 2014-04-24 Scholarships.com, LLC
  scholarships
  
  // school : 2014-12-18 Binky Moon, LLC
  school
  
  // schule : 2014-03-06 Binky Moon, LLC
  schule
  
  // schwarz : 2014-09-18 Schwarz Domains und Services GmbH & Co. KG
  schwarz
  
  // science : 2014-09-11 dot Science Limited
  science
  
  // scjohnson : 2015-07-23 Johnson Shareholdings, Inc.
  scjohnson
  
  // scor : 2014-10-31 SCOR SE
  scor
  
  // scot : 2014-01-23 Dot Scot Registry Limited
  scot
  
  // search : 2016-06-09 Charleston Road Registry Inc.
  search
  
  // seat : 2014-05-22 SEAT, S.A. (Sociedad Unipersonal)
  seat
  
  // secure : 2015-08-27 Amazon Registry Services, Inc.
  secure
  
  // security : 2015-05-14 XYZ.COM LLC
  security
  
  // seek : 2014-12-04 Seek Limited
  seek
  
  // select : 2015-10-08 iSelect Ltd
  select
  
  // sener : 2014-10-24 Sener Ingeniería y Sistemas, S.A.
  sener
  
  // services : 2014-02-27 Binky Moon, LLC
  services
  
  // ses : 2015-07-23 SES
  ses
  
  // seven : 2015-08-06 Seven West Media Ltd
  seven
  
  // sew : 2014-07-17 SEW-EURODRIVE GmbH & Co KG
  sew
  
  // sex : 2014-11-13 ICM Registry SX LLC
  sex
  
  // sexy : 2013-09-11 Uniregistry, Corp.
  sexy
  
  // sfr : 2015-08-13 Societe Francaise du Radiotelephone - SFR
  sfr
  
  // shangrila : 2015-09-03 Shangri‐La International Hotel Management Limited
  shangrila
  
  // sharp : 2014-05-01 Sharp Corporation
  sharp
  
  // shaw : 2015-04-23 Shaw Cablesystems G.P.
  shaw
  
  // shell : 2015-07-30 Shell Information Technology International Inc
  shell
  
  // shia : 2014-09-04 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  shia
  
  // shiksha : 2013-11-14 Afilias plc
  shiksha
  
  // shoes : 2013-10-02 Binky Moon, LLC
  shoes
  
  // shop : 2016-04-08 GMO Registry, Inc.
  shop
  
  // shopping : 2016-03-31 Binky Moon, LLC
  shopping
  
  // shouji : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.
  shouji
  
  // show : 2015-03-05 Binky Moon, LLC
  show
  
  // showtime : 2015-08-06 CBS Domains Inc.
  showtime
  
  // shriram : 2014-01-23 Shriram Capital Ltd.
  shriram
  
  // silk : 2015-06-25 Amazon Registry Services, Inc.
  silk
  
  // sina : 2015-03-12 Sina Corporation
  sina
  
  // singles : 2013-08-27 Binky Moon, LLC
  singles
  
  // site : 2015-01-15 DotSite Inc.
  site
  
  // ski : 2015-04-09 Afilias plc
  ski
  
  // skin : 2015-01-15 L'Oréal
  skin
  
  // sky : 2014-06-19 Sky International AG
  sky
  
  // skype : 2014-12-18 Microsoft Corporation
  skype
  
  // sling : 2015-07-30 Hughes Satellite Systems Corporation
  sling
  
  // smart : 2015-07-09 Smart Communications, Inc. (SMART)
  smart
  
  // smile : 2014-12-18 Amazon Registry Services, Inc.
  smile
  
  // sncf : 2015-02-19 Société Nationale des Chemins de fer Francais S N C F
  sncf
  
  // soccer : 2015-03-26 Binky Moon, LLC
  soccer
  
  // social : 2013-11-07 United TLD Holdco Ltd.
  social
  
  // softbank : 2015-07-02 SoftBank Corp.
  softbank
  
  // software : 2014-03-20 United TLD Holdco Ltd.
  software
  
  // sohu : 2013-12-19 Sohu.com Limited
  sohu
  
  // solar : 2013-11-07 Binky Moon, LLC
  solar
  
  // solutions : 2013-11-07 Binky Moon, LLC
  solutions
  
  // song : 2015-02-26 Amazon Registry Services, Inc.
  song
  
  // sony : 2015-01-08 Sony Corporation
  sony
  
  // soy : 2014-01-23 Charleston Road Registry Inc.
  soy
  
  // space : 2014-04-03 DotSpace Inc.
  space
  
  // sport : 2017-11-16 Global Association of International Sports Federations (GAISF)
  sport
  
  // spot : 2015-02-26 Amazon Registry Services, Inc.
  spot
  
  // spreadbetting : 2014-12-11 Dotspreadbetting Registry Limited
  spreadbetting
  
  // srl : 2015-05-07 InterNetX, Corp
  srl
  
  // srt : 2015-07-30 FCA US LLC.
  srt
  
  // stada : 2014-11-13 STADA Arzneimittel AG
  stada
  
  // staples : 2015-07-30 Staples, Inc.
  staples
  
  // star : 2015-01-08 Star India Private Limited
  star
  
  // starhub : 2015-02-05 StarHub Ltd
  starhub
  
  // statebank : 2015-03-12 STATE BANK OF INDIA
  statebank
  
  // statefarm : 2015-07-30 State Farm Mutual Automobile Insurance Company
  statefarm
  
  // stc : 2014-10-09 Saudi Telecom Company
  stc
  
  // stcgroup : 2014-10-09 Saudi Telecom Company
  stcgroup
  
  // stockholm : 2014-12-18 Stockholms kommun
  stockholm
  
  // storage : 2014-12-22 XYZ.COM LLC
  storage
  
  // store : 2015-04-09 DotStore Inc.
  store
  
  // stream : 2016-01-08 dot Stream Limited
  stream
  
  // studio : 2015-02-11 United TLD Holdco Ltd.
  studio
  
  // study : 2014-12-11 OPEN UNIVERSITIES AUSTRALIA PTY LTD
  study
  
  // style : 2014-12-04 Binky Moon, LLC
  style
  
  // sucks : 2014-12-22 Vox Populi Registry Ltd.
  sucks
  
  // supplies : 2013-12-19 Binky Moon, LLC
  supplies
  
  // supply : 2013-12-19 Binky Moon, LLC
  supply
  
  // support : 2013-10-24 Binky Moon, LLC
  support
  
  // surf : 2014-01-09 Minds + Machines Group Limited
  surf
  
  // surgery : 2014-03-20 Binky Moon, LLC
  surgery
  
  // suzuki : 2014-02-20 SUZUKI MOTOR CORPORATION
  suzuki
  
  // swatch : 2015-01-08 The Swatch Group Ltd
  swatch
  
  // swiftcover : 2015-07-23 Swiftcover Insurance Services Limited
  swiftcover
  
  // swiss : 2014-10-16 Swiss Confederation
  swiss
  
  // sydney : 2014-09-18 State of New South Wales, Department of Premier and Cabinet
  sydney
  
  // symantec : 2014-12-04 Symantec Corporation
  symantec
  
  // systems : 2013-11-07 Binky Moon, LLC
  systems
  
  // tab : 2014-12-04 Tabcorp Holdings Limited
  tab
  
  // taipei : 2014-07-10 Taipei City Government
  taipei
  
  // talk : 2015-04-09 Amazon Registry Services, Inc.
  talk
  
  // taobao : 2015-01-15 Alibaba Group Holding Limited
  taobao
  
  // target : 2015-07-31 Target Domain Holdings, LLC
  target
  
  // tatamotors : 2015-03-12 Tata Motors Ltd
  tatamotors
  
  // tatar : 2014-04-24 Limited Liability Company "Coordination Center of Regional Domain of Tatarstan Republic"
  tatar
  
  // tattoo : 2013-08-30 Uniregistry, Corp.
  tattoo
  
  // tax : 2014-03-20 Binky Moon, LLC
  tax
  
  // taxi : 2015-03-19 Binky Moon, LLC
  taxi
  
  // tci : 2014-09-12 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  tci
  
  // tdk : 2015-06-11 TDK Corporation
  tdk
  
  // team : 2015-03-05 Binky Moon, LLC
  team
  
  // tech : 2015-01-30 Personals TLD Inc.
  tech
  
  // technology : 2013-09-13 Binky Moon, LLC
  technology
  
  // telefonica : 2014-10-16 Telefónica S.A.
  telefonica
  
  // temasek : 2014-08-07 Temasek Holdings (Private) Limited
  temasek
  
  // tennis : 2014-12-04 Binky Moon, LLC
  tennis
  
  // teva : 2015-07-02 Teva Pharmaceutical Industries Limited
  teva
  
  // thd : 2015-04-02 Home Depot Product Authority, LLC
  thd
  
  // theater : 2015-03-19 Binky Moon, LLC
  theater
  
  // theatre : 2015-05-07 XYZ.COM LLC
  theatre
  
  // tiaa : 2015-07-23 Teachers Insurance and Annuity Association of America
  tiaa
  
  // tickets : 2015-02-05 Accent Media Limited
  tickets
  
  // tienda : 2013-11-14 Binky Moon, LLC
  tienda
  
  // tiffany : 2015-01-30 Tiffany and Company
  tiffany
  
  // tips : 2013-09-20 Binky Moon, LLC
  tips
  
  // tires : 2014-11-07 Binky Moon, LLC
  tires
  
  // tirol : 2014-04-24 punkt Tirol GmbH
  tirol
  
  // tjmaxx : 2015-07-16 The TJX Companies, Inc.
  tjmaxx
  
  // tjx : 2015-07-16 The TJX Companies, Inc.
  tjx
  
  // tkmaxx : 2015-07-16 The TJX Companies, Inc.
  tkmaxx
  
  // tmall : 2015-01-15 Alibaba Group Holding Limited
  tmall
  
  // today : 2013-09-20 Binky Moon, LLC
  today
  
  // tokyo : 2013-11-13 GMO Registry, Inc.
  tokyo
  
  // tools : 2013-11-21 Binky Moon, LLC
  tools
  
  // top : 2014-03-20 .TOP Registry
  top
  
  // toray : 2014-12-18 Toray Industries, Inc.
  toray
  
  // toshiba : 2014-04-10 TOSHIBA Corporation
  toshiba
  
  // total : 2015-08-06 Total SA
  total
  
  // tours : 2015-01-22 Binky Moon, LLC
  tours
  
  // town : 2014-03-06 Binky Moon, LLC
  town
  
  // toyota : 2015-04-23 TOYOTA MOTOR CORPORATION
  toyota
  
  // toys : 2014-03-06 Binky Moon, LLC
  toys
  
  // trade : 2014-01-23 Elite Registry Limited
  trade
  
  // trading : 2014-12-11 Dottrading Registry Limited
  trading
  
  // training : 2013-11-07 Binky Moon, LLC
  training
  
  // travel :  Dog Beach, LLC
  travel
  
  // travelchannel : 2015-07-02 Lifestyle Domain Holdings, Inc.
  travelchannel
  
  // travelers : 2015-03-26 Travelers TLD, LLC
  travelers
  
  // travelersinsurance : 2015-03-26 Travelers TLD, LLC
  travelersinsurance
  
  // trust : 2014-10-16 NCC Group Inc.
  trust
  
  // trv : 2015-03-26 Travelers TLD, LLC
  trv
  
  // tube : 2015-06-11 Latin American Telecom LLC
  tube
  
  // tui : 2014-07-03 TUI AG
  tui
  
  // tunes : 2015-02-26 Amazon Registry Services, Inc.
  tunes
  
  // tushu : 2014-12-18 Amazon Registry Services, Inc.
  tushu
  
  // tvs : 2015-02-19 T V SUNDRAM IYENGAR  & SONS LIMITED
  tvs
  
  // ubank : 2015-08-20 National Australia Bank Limited
  ubank
  
  // ubs : 2014-12-11 UBS AG
  ubs
  
  // uconnect : 2015-07-30 FCA US LLC.
  uconnect
  
  // unicom : 2015-10-15 China United Network Communications Corporation Limited
  unicom
  
  // university : 2014-03-06 Binky Moon, LLC
  university
  
  // uno : 2013-09-11 Dot Latin LLC
  uno
  
  // uol : 2014-05-01 UBN INTERNET LTDA.
  uol
  
  // ups : 2015-06-25 UPS Market Driver, Inc.
  ups
  
  // vacations : 2013-12-05 Binky Moon, LLC
  vacations
  
  // vana : 2014-12-11 Lifestyle Domain Holdings, Inc.
  vana
  
  // vanguard : 2015-09-03 The Vanguard Group, Inc.
  vanguard
  
  // vegas : 2014-01-16 Dot Vegas, Inc.
  vegas
  
  // ventures : 2013-08-27 Binky Moon, LLC
  ventures
  
  // verisign : 2015-08-13 VeriSign, Inc.
  verisign
  
  // versicherung : 2014-03-20 TLD-BOX Registrydienstleistungen GmbH
  versicherung
  
  // vet : 2014-03-06 United TLD Holdco Ltd.
  vet
  
  // viajes : 2013-10-17 Binky Moon, LLC
  viajes
  
  // video : 2014-10-16 United TLD Holdco Ltd.
  video
  
  // vig : 2015-05-14 VIENNA INSURANCE GROUP AG Wiener Versicherung Gruppe
  vig
  
  // viking : 2015-04-02 Viking River Cruises (Bermuda) Ltd.
  viking
  
  // villas : 2013-12-05 Binky Moon, LLC
  villas
  
  // vin : 2015-06-18 Binky Moon, LLC
  vin
  
  // vip : 2015-01-22 Minds + Machines Group Limited
  vip
  
  // virgin : 2014-09-25 Virgin Enterprises Limited
  virgin
  
  // visa : 2015-07-30 Visa Worldwide Pte. Limited
  visa
  
  // vision : 2013-12-05 Binky Moon, LLC
  vision
  
  // vistaprint : 2014-09-18 Vistaprint Limited
  vistaprint
  
  // viva : 2014-11-07 Saudi Telecom Company
  viva
  
  // vivo : 2015-07-31 Telefonica Brasil S.A.
  vivo
  
  // vlaanderen : 2014-02-06 DNS.be vzw
  vlaanderen
  
  // vodka : 2013-12-19 Minds + Machines Group Limited
  vodka
  
  // volkswagen : 2015-05-14 Volkswagen Group of America Inc.
  volkswagen
  
  // volvo : 2015-11-12 Volvo Holding Sverige Aktiebolag
  volvo
  
  // vote : 2013-11-21 Monolith Registry LLC
  vote
  
  // voting : 2013-11-13 Valuetainment Corp.
  voting
  
  // voto : 2013-11-21 Monolith Registry LLC
  voto
  
  // voyage : 2013-08-27 Binky Moon, LLC
  voyage
  
  // vuelos : 2015-03-05 Travel Reservations SRL
  vuelos
  
  // wales : 2014-05-08 Nominet UK
  wales
  
  // walmart : 2015-07-31 Wal-Mart Stores, Inc.
  walmart
  
  // walter : 2014-11-13 Sandvik AB
  walter
  
  // wang : 2013-10-24 Zodiac Wang Limited
  wang
  
  // wanggou : 2014-12-18 Amazon Registry Services, Inc.
  wanggou
  
  // warman : 2015-06-18 Weir Group IP Limited
  warman
  
  // watch : 2013-11-14 Binky Moon, LLC
  watch
  
  // watches : 2014-12-22 Richemont DNS Inc.
  watches
  
  // weather : 2015-01-08 International Business Machines Corporation
  weather
  
  // weatherchannel : 2015-03-12 International Business Machines Corporation
  weatherchannel
  
  // webcam : 2014-01-23 dot Webcam Limited
  webcam
  
  // weber : 2015-06-04 Saint-Gobain Weber SA
  weber
  
  // website : 2014-04-03 DotWebsite Inc.
  website
  
  // wed : 2013-10-01 Atgron, Inc.
  wed
  
  // wedding : 2014-04-24 Minds + Machines Group Limited
  wedding
  
  // weibo : 2015-03-05 Sina Corporation
  weibo
  
  // weir : 2015-01-29 Weir Group IP Limited
  weir
  
  // whoswho : 2014-02-20 Who's Who Registry
  whoswho
  
  // wien : 2013-10-28 punkt.wien GmbH
  wien
  
  // wiki : 2013-11-07 Top Level Design, LLC
  wiki
  
  // williamhill : 2014-03-13 William Hill Organization Limited
  williamhill
  
  // win : 2014-11-20 First Registry Limited
  win
  
  // windows : 2014-12-18 Microsoft Corporation
  windows
  
  // wine : 2015-06-18 Binky Moon, LLC
  wine
  
  // winners : 2015-07-16 The TJX Companies, Inc.
  winners
  
  // wme : 2014-02-13 William Morris Endeavor Entertainment, LLC
  wme
  
  // wolterskluwer : 2015-08-06 Wolters Kluwer N.V.
  wolterskluwer
  
  // woodside : 2015-07-09 Woodside Petroleum Limited
  woodside
  
  // work : 2013-12-19 Minds + Machines Group Limited
  work
  
  // works : 2013-11-14 Binky Moon, LLC
  works
  
  // world : 2014-06-12 Binky Moon, LLC
  world
  
  // wow : 2015-10-08 Amazon Registry Services, Inc.
  wow
  
  // wtc : 2013-12-19 World Trade Centers Association, Inc.
  wtc
  
  // wtf : 2014-03-06 Binky Moon, LLC
  wtf
  
  // xbox : 2014-12-18 Microsoft Corporation
  xbox
  
  // xerox : 2014-10-24 Xerox DNHC LLC
  xerox
  
  // xfinity : 2015-07-09 Comcast IP Holdings I, LLC
  xfinity
  
  // xihuan : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.
  xihuan
  
  // xin : 2014-12-11 Elegant Leader Limited
  xin
  
  // xn--11b4c3d : 2015-01-15 VeriSign Sarl
  xn--11b4c3d
  
  // xn--1ck2e1b : 2015-02-26 Amazon Registry Services, Inc.
  xn--1ck2e1b
  
  // xn--1qqw23a : 2014-01-09 Guangzhou YU Wei Information Technology Co., Ltd.
  xn--1qqw23a
  
  // xn--30rr7y : 2014-06-12 Excellent First Limited
  xn--30rr7y
  
  // xn--3bst00m : 2013-09-13 Eagle Horizon Limited
  xn--3bst00m
  
  // xn--3ds443g : 2013-09-08 TLD REGISTRY LIMITED
  xn--3ds443g
  
  // xn--3oq18vl8pn36a : 2015-07-02 Volkswagen (China) Investment Co., Ltd.
  xn--3oq18vl8pn36a
  
  // xn--3pxu8k : 2015-01-15 VeriSign Sarl
  xn--3pxu8k
  
  // xn--42c2d9a : 2015-01-15 VeriSign Sarl
  xn--42c2d9a
  
  // xn--45q11c : 2013-11-21 Zodiac Gemini Ltd
  xn--45q11c
  
  // xn--4gbrim : 2013-10-04 Suhub Electronic Establishment
  xn--4gbrim
  
  // xn--55qw42g : 2013-11-08 China Organizational Name Administration Center
  xn--55qw42g
  
  // xn--55qx5d : 2013-11-14 China Internet Network Information Center (CNNIC)
  xn--55qx5d
  
  // xn--5su34j936bgsg : 2015-09-03 Shangri‐La International Hotel Management Limited
  xn--5su34j936bgsg
  
  // xn--5tzm5g : 2014-12-22 Global Website TLD Asia Limited
  xn--5tzm5g
  
  // xn--6frz82g : 2013-09-23 Afilias plc
  xn--6frz82g
  
  // xn--6qq986b3xl : 2013-09-13 Tycoon Treasure Limited
  xn--6qq986b3xl
  
  // xn--80adxhks : 2013-12-19 Foundation for Assistance for Internet Technologies and Infrastructure Development (FAITID)
  xn--80adxhks
  
  // xn--80aqecdr1a : 2015-10-21 Pontificium Consilium de Comunicationibus Socialibus (PCCS) (Pontifical Council for Social Communication)
  xn--80aqecdr1a
  
  // xn--80asehdb : 2013-07-14 CORE Association
  xn--80asehdb
  
  // xn--80aswg : 2013-07-14 CORE Association
  xn--80aswg
  
  // xn--8y0a063a : 2015-03-26 China United Network Communications Corporation Limited
  xn--8y0a063a
  
  // xn--9dbq2a : 2015-01-15 VeriSign Sarl
  xn--9dbq2a
  
  // xn--9et52u : 2014-06-12 RISE VICTORY LIMITED
  xn--9et52u
  
  // xn--9krt00a : 2015-03-12 Sina Corporation
  xn--9krt00a
  
  // xn--b4w605ferd : 2014-08-07 Temasek Holdings (Private) Limited
  xn--b4w605ferd
  
  // xn--bck1b9a5dre4c : 2015-02-26 Amazon Registry Services, Inc.
  xn--bck1b9a5dre4c
  
  // xn--c1avg : 2013-11-14 Public Interest Registry
  xn--c1avg
  
  // xn--c2br7g : 2015-01-15 VeriSign Sarl
  xn--c2br7g
  
  // xn--cck2b3b : 2015-02-26 Amazon Registry Services, Inc.
  xn--cck2b3b
  
  // xn--cg4bki : 2013-09-27 SAMSUNG SDS CO., LTD
  xn--cg4bki
  
  // xn--czr694b : 2014-01-16 Dot Trademark TLD Holding Company Limited
  xn--czr694b
  
  // xn--czrs0t : 2013-12-19 Binky Moon, LLC
  xn--czrs0t
  
  // xn--czru2d : 2013-11-21 Zodiac Aquarius Limited
  xn--czru2d
  
  // xn--d1acj3b : 2013-11-20 The Foundation for Network Initiatives “The Smart Internet”
  xn--d1acj3b
  
  // xn--eckvdtc9d : 2014-12-18 Amazon Registry Services, Inc.
  xn--eckvdtc9d
  
  // xn--efvy88h : 2014-08-22 Guangzhou YU Wei Information Technology Co., Ltd.
  xn--efvy88h
  
  // xn--estv75g : 2015-02-19 Industrial and Commercial Bank of China Limited
  xn--estv75g
  
  // xn--fct429k : 2015-04-09 Amazon Registry Services, Inc.
  xn--fct429k
  
  // xn--fhbei : 2015-01-15 VeriSign Sarl
  xn--fhbei
  
  // xn--fiq228c5hs : 2013-09-08 TLD REGISTRY LIMITED
  xn--fiq228c5hs
  
  // xn--fiq64b : 2013-10-14 CITIC Group Corporation
  xn--fiq64b
  
  // xn--fjq720a : 2014-05-22 Binky Moon, LLC
  xn--fjq720a
  
  // xn--flw351e : 2014-07-31 Charleston Road Registry Inc.
  xn--flw351e
  
  // xn--fzys8d69uvgm : 2015-05-14 PCCW Enterprises Limited
  xn--fzys8d69uvgm
  
  // xn--g2xx48c : 2015-01-30 Minds + Machines Group Limited
  xn--g2xx48c
  
  // xn--gckr3f0f : 2015-02-26 Amazon Registry Services, Inc.
  xn--gckr3f0f
  
  // xn--gk3at1e : 2015-10-08 Amazon Registry Services, Inc.
  xn--gk3at1e
  
  // xn--hxt814e : 2014-05-15 Zodiac Taurus Limited
  xn--hxt814e
  
  // xn--i1b6b1a6a2e : 2013-11-14 Public Interest Registry
  xn--i1b6b1a6a2e
  
  // xn--imr513n : 2014-12-11 Dot Trademark TLD Holding Company Limited
  xn--imr513n
  
  // xn--io0a7i : 2013-11-14 China Internet Network Information Center (CNNIC)
  xn--io0a7i
  
  // xn--j1aef : 2015-01-15 VeriSign Sarl
  xn--j1aef
  
  // xn--jlq61u9w7b : 2015-01-08 Nokia Corporation
  xn--jlq61u9w7b
  
  // xn--jvr189m : 2015-02-26 Amazon Registry Services, Inc.
  xn--jvr189m
  
  // xn--kcrx77d1x4a : 2014-11-07 Koninklijke Philips N.V.
  xn--kcrx77d1x4a
  
  // xn--kpu716f : 2014-12-22 Richemont DNS Inc.
  xn--kpu716f
  
  // xn--kput3i : 2014-02-13 Beijing RITT-Net Technology Development Co., Ltd
  xn--kput3i
  
  // xn--mgba3a3ejt : 2014-11-20 Aramco Services Company
  xn--mgba3a3ejt
  
  // xn--mgba7c0bbn0a : 2015-05-14 Crescent Holding GmbH
  xn--mgba7c0bbn0a
  
  // xn--mgbaakc7dvf : 2015-09-03 Emirates Telecommunications Corporation (trading as Etisalat)
  xn--mgbaakc7dvf
  
  // xn--mgbab2bd : 2013-10-31 CORE Association
  xn--mgbab2bd
  
  // xn--mgbb9fbpob : 2014-12-18 GreenTech Consultancy Company W.L.L.
  xn--mgbb9fbpob
  
  // xn--mgbca7dzdo : 2015-07-30 Abu Dhabi Systems and Information Centre
  xn--mgbca7dzdo
  
  // xn--mgbi4ecexp : 2015-10-21 Pontificium Consilium de Comunicationibus Socialibus (PCCS) (Pontifical Council for Social Communication)
  xn--mgbi4ecexp
  
  // xn--mgbt3dhd : 2014-09-04 Asia Green IT System Bilgisayar San. ve Tic. Ltd. Sti.
  xn--mgbt3dhd
  
  // xn--mk1bu44c : 2015-01-15 VeriSign Sarl
  xn--mk1bu44c
  
  // xn--mxtq1m : 2014-03-06 Net-Chinese Co., Ltd.
  xn--mxtq1m
  
  // xn--ngbc5azd : 2013-07-13 International Domain Registry Pty. Ltd.
  xn--ngbc5azd
  
  // xn--ngbe9e0a : 2014-12-04 Kuwait Finance House
  xn--ngbe9e0a
  
  // xn--ngbrx : 2015-11-12 League of Arab States
  xn--ngbrx
  
  // xn--nqv7f : 2013-11-14 Public Interest Registry
  xn--nqv7f
  
  // xn--nqv7fs00ema : 2013-11-14 Public Interest Registry
  xn--nqv7fs00ema
  
  // xn--nyqy26a : 2014-11-07 Stable Tone Limited
  xn--nyqy26a
  
  // xn--otu796d : 2017-08-06 Dot Trademark TLD Holding Company Limited
  xn--otu796d
  
  // xn--p1acf : 2013-12-12 Rusnames Limited
  xn--p1acf
  
  // xn--pbt977c : 2014-12-22 Richemont DNS Inc.
  xn--pbt977c
  
  // xn--pssy2u : 2015-01-15 VeriSign Sarl
  xn--pssy2u
  
  // xn--q9jyb4c : 2013-09-17 Charleston Road Registry Inc.
  xn--q9jyb4c
  
  // xn--qcka1pmc : 2014-07-31 Charleston Road Registry Inc.
  xn--qcka1pmc
  
  // xn--rhqv96g : 2013-09-11 Stable Tone Limited
  xn--rhqv96g
  
  // xn--rovu88b : 2015-02-26 Amazon Registry Services, Inc.
  xn--rovu88b
  
  // xn--ses554g : 2014-01-16 KNET Co., Ltd.
  xn--ses554g
  
  // xn--t60b56a : 2015-01-15 VeriSign Sarl
  xn--t60b56a
  
  // xn--tckwe : 2015-01-15 VeriSign Sarl
  xn--tckwe
  
  // xn--tiq49xqyj : 2015-10-21 Pontificium Consilium de Comunicationibus Socialibus (PCCS) (Pontifical Council for Social Communication)
  xn--tiq49xqyj
  
  // xn--unup4y : 2013-07-14 Binky Moon, LLC
  xn--unup4y
  
  // xn--vermgensberater-ctb : 2014-06-23 Deutsche Vermögensberatung Aktiengesellschaft DVAG
  xn--vermgensberater-ctb
  
  // xn--vermgensberatung-pwb : 2014-06-23 Deutsche Vermögensberatung Aktiengesellschaft DVAG
  xn--vermgensberatung-pwb
  
  // xn--vhquv : 2013-08-27 Binky Moon, LLC
  xn--vhquv
  
  // xn--vuq861b : 2014-10-16 Beijing Tele-info Network Technology Co., Ltd.
  xn--vuq861b
  
  // xn--w4r85el8fhu5dnra : 2015-04-30 Kerry Trading Co. Limited
  xn--w4r85el8fhu5dnra
  
  // xn--w4rs40l : 2015-07-30 Kerry Trading Co. Limited
  xn--w4rs40l
  
  // xn--xhq521b : 2013-11-14 Guangzhou YU Wei Information Technology Co., Ltd.
  xn--xhq521b
  
  // xn--zfr164b : 2013-11-08 China Organizational Name Administration Center
  xn--zfr164b
  
  // xyz : 2013-12-05 XYZ.COM LLC
  xyz
  
  // yachts : 2014-01-09 DERYachts, LLC
  yachts
  
  // yahoo : 2015-04-02 Yahoo! Domain Services Inc.
  yahoo
  
  // yamaxun : 2014-12-18 Amazon Registry Services, Inc.
  yamaxun
  
  // yandex : 2014-04-10 YANDEX, LLC
  yandex
  
  // yodobashi : 2014-11-20 YODOBASHI CAMERA CO.,LTD.
  yodobashi
  
  // yoga : 2014-05-29 Minds + Machines Group Limited
  yoga
  
  // yokohama : 2013-12-12 GMO Registry, Inc.
  yokohama
  
  // you : 2015-04-09 Amazon Registry Services, Inc.
  you
  
  // youtube : 2014-05-01 Charleston Road Registry Inc.
  youtube
  
  // yun : 2015-01-08 QIHOO 360 TECHNOLOGY CO. LTD.
  yun
  
  // zappos : 2015-06-25 Amazon Registry Services, Inc.
  zappos
  
  // zara : 2014-11-07 Industria de Diseño Textil, S.A. (INDITEX, S.A.)
  zara
  
  // zero : 2014-12-18 Amazon Registry Services, Inc.
  zero
  
  // zip : 2014-05-08 Charleston Road Registry Inc.
  zip
  
  // zone : 2013-11-14 Binky Moon, LLC
  zone
  
  // zuerich : 2014-11-07 Kanton Zürich (Canton of Zurich)
  zuerich
  
  
  // ===END ICANN DOMAINS===
  // ===BEGIN PRIVATE DOMAINS===
  // (Note: these are in alphabetical order by company name)
  
  // 1GB LLC : https://www.1gb.ua/
  // Submitted by 1GB LLC <noc@1gb.com.ua>
  cc.ua
  inf.ua
  ltd.ua
  
  // Agnat sp. z o.o. : https://domena.pl
  // Submitted by Przemyslaw Plewa <it-admin@domena.pl>
  beep.pl
  
  // Alces Software Ltd : http://alces-software.com
  // Submitted by Mark J. Titorenko <mark.titorenko@alces-software.com>
  *.compute.estate
  *.alces.network
  
  // alwaysdata : https://www.alwaysdata.com
  // Submitted by Cyril <admin@alwaysdata.com>
  alwaysdata.net
  
  // Amazon CloudFront : https://aws.amazon.com/cloudfront/
  // Submitted by Donavan Miller <donavanm@amazon.com>
  cloudfront.net
  
  // Amazon Elastic Compute Cloud : https://aws.amazon.com/ec2/
  // Submitted by Luke Wells <psl-maintainers@amazon.com>
  *.compute.amazonaws.com
  *.compute-1.amazonaws.com
  *.compute.amazonaws.com.cn
  us-east-1.amazonaws.com
  
  // Amazon Elastic Beanstalk : https://aws.amazon.com/elasticbeanstalk/
  // Submitted by Luke Wells <psl-maintainers@amazon.com>
  cn-north-1.eb.amazonaws.com.cn
  cn-northwest-1.eb.amazonaws.com.cn
  elasticbeanstalk.com
  ap-northeast-1.elasticbeanstalk.com
  ap-northeast-2.elasticbeanstalk.com
  ap-northeast-3.elasticbeanstalk.com
  ap-south-1.elasticbeanstalk.com
  ap-southeast-1.elasticbeanstalk.com
  ap-southeast-2.elasticbeanstalk.com
  ca-central-1.elasticbeanstalk.com
  eu-central-1.elasticbeanstalk.com
  eu-west-1.elasticbeanstalk.com
  eu-west-2.elasticbeanstalk.com
  eu-west-3.elasticbeanstalk.com
  sa-east-1.elasticbeanstalk.com
  us-east-1.elasticbeanstalk.com
  us-east-2.elasticbeanstalk.com
  us-gov-west-1.elasticbeanstalk.com
  us-west-1.elasticbeanstalk.com
  us-west-2.elasticbeanstalk.com
  
  // Amazon Elastic Load Balancing : https://aws.amazon.com/elasticloadbalancing/
  // Submitted by Luke Wells <psl-maintainers@amazon.com>
  *.elb.amazonaws.com
  *.elb.amazonaws.com.cn
  
  // Amazon S3 : https://aws.amazon.com/s3/
  // Submitted by Luke Wells <psl-maintainers@amazon.com>
  s3.amazonaws.com
  s3-ap-northeast-1.amazonaws.com
  s3-ap-northeast-2.amazonaws.com
  s3-ap-south-1.amazonaws.com
  s3-ap-southeast-1.amazonaws.com
  s3-ap-southeast-2.amazonaws.com
  s3-ca-central-1.amazonaws.com
  s3-eu-central-1.amazonaws.com
  s3-eu-west-1.amazonaws.com
  s3-eu-west-2.amazonaws.com
  s3-eu-west-3.amazonaws.com
  s3-external-1.amazonaws.com
  s3-fips-us-gov-west-1.amazonaws.com
  s3-sa-east-1.amazonaws.com
  s3-us-gov-west-1.amazonaws.com
  s3-us-east-2.amazonaws.com
  s3-us-west-1.amazonaws.com
  s3-us-west-2.amazonaws.com
  s3.ap-northeast-2.amazonaws.com
  s3.ap-south-1.amazonaws.com
  s3.cn-north-1.amazonaws.com.cn
  s3.ca-central-1.amazonaws.com
  s3.eu-central-1.amazonaws.com
  s3.eu-west-2.amazonaws.com
  s3.eu-west-3.amazonaws.com
  s3.us-east-2.amazonaws.com
  s3.dualstack.ap-northeast-1.amazonaws.com
  s3.dualstack.ap-northeast-2.amazonaws.com
  s3.dualstack.ap-south-1.amazonaws.com
  s3.dualstack.ap-southeast-1.amazonaws.com
  s3.dualstack.ap-southeast-2.amazonaws.com
  s3.dualstack.ca-central-1.amazonaws.com
  s3.dualstack.eu-central-1.amazonaws.com
  s3.dualstack.eu-west-1.amazonaws.com
  s3.dualstack.eu-west-2.amazonaws.com
  s3.dualstack.eu-west-3.amazonaws.com
  s3.dualstack.sa-east-1.amazonaws.com
  s3.dualstack.us-east-1.amazonaws.com
  s3.dualstack.us-east-2.amazonaws.com
  s3-website-us-east-1.amazonaws.com
  s3-website-us-west-1.amazonaws.com
  s3-website-us-west-2.amazonaws.com
  s3-website-ap-northeast-1.amazonaws.com
  s3-website-ap-southeast-1.amazonaws.com
  s3-website-ap-southeast-2.amazonaws.com
  s3-website-eu-west-1.amazonaws.com
  s3-website-sa-east-1.amazonaws.com
  s3-website.ap-northeast-2.amazonaws.com
  s3-website.ap-south-1.amazonaws.com
  s3-website.ca-central-1.amazonaws.com
  s3-website.eu-central-1.amazonaws.com
  s3-website.eu-west-2.amazonaws.com
  s3-website.eu-west-3.amazonaws.com
  s3-website.us-east-2.amazonaws.com
  
  // Amune : https://amune.org/
  // Submitted by Team Amune <cert@amune.org>
  t3l3p0rt.net
  tele.amune.org
  
  // Apigee : https://apigee.com/
  // Submitted by Apigee Security Team <security@apigee.com>
  apigee.io
  
  // Aptible : https://www.aptible.com/
  // Submitted by Thomas Orozco <thomas@aptible.com>
  on-aptible.com
  
  // Asociación Amigos de la Informática "Euskalamiga" : http://encounter.eus/
  // Submitted by Hector Martin <marcan@euskalencounter.org>
  user.party.eus
  
  // Association potager.org : https://potager.org/
  // Submitted by Lunar <jardiniers@potager.org>
  pimienta.org
  poivron.org
  potager.org
  sweetpepper.org
  
  // ASUSTOR Inc. : http://www.asustor.com
  // Submitted by Vincent Tseng <vincenttseng@asustor.com>
  myasustor.com
  
  // Automattic Inc. : https://automattic.com/
  // Submitted by Alex Concha <alex.concha@automattic.com>
  go-vip.co
  wpcomstaging.com
  
  // AVM : https://avm.de
  // Submitted by Andreas Weise <a.weise@avm.de>
  myfritz.net
  
  // AW AdvisorWebsites.com Software Inc : https://advisorwebsites.com
  // Submitted by James Kennedy <domains@advisorwebsites.com>
  *.awdev.ca
  *.advisor.ws
  
  // backplane : https://www.backplane.io
  // Submitted by Anthony Voutas <anthony@backplane.io>
  backplaneapp.io
  
  // BetaInABox
  // Submitted by Adrian <adrian@betainabox.com>
  betainabox.com
  
  // BinaryLane : http://www.binarylane.com
  // Submitted by Nathan O'Sullivan <nathan@mammoth.com.au>
  bnr.la
  
  // Blackbaud, Inc. : https://www.blackbaud.com
  // Submitted by Paul Crowder <paul.crowder@blackbaud.com>
  blackbaudcdn.net
  
  // Boomla : https://boomla.com
  // Submitted by Tibor Halter <thalter@boomla.com>
  boomla.net
  
  // Boxfuse : https://boxfuse.com
  // Submitted by Axel Fontaine <axel@boxfuse.com>
  boxfuse.io
  
  // bplaced : https://www.bplaced.net/
  // Submitted by Miroslav Bozic <security@bplaced.net>
  square7.ch
  bplaced.com
  bplaced.de
  square7.de
  bplaced.net
  square7.net
  
  // BrowserSafetyMark
  // Submitted by Dave Tharp <browsersafetymark.io@quicinc.com>
  browsersafetymark.io
  
  // Bytemark Hosting : https://www.bytemark.co.uk
  // Submitted by Paul Cammish <paul.cammish@bytemark.co.uk>
  dh.bytemark.co.uk
  vm.bytemark.co.uk
  
  // callidomus : https://www.callidomus.com/
  // Submitted by Marcus Popp <admin@callidomus.com>
  mycd.eu
  
  // CentralNic : http://www.centralnic.com/names/domains
  // Submitted by registry <gavin.brown@centralnic.com>
  ae.org
  ar.com
  br.com
  cn.com
  com.de
  com.se
  de.com
  eu.com
  gb.com
  gb.net
  hu.com
  hu.net
  jp.net
  jpn.com
  kr.com
  mex.com
  no.com
  qc.com
  ru.com
  sa.com
  se.net
  uk.com
  uk.net
  us.com
  uy.com
  za.bz
  za.com
  
  // Africa.com Web Solutions Ltd : https://registry.africa.com
  // Submitted by Gavin Brown <gavin.brown@centralnic.com>
  africa.com
  
  // iDOT Services Limited : http://www.domain.gr.com
  // Submitted by Gavin Brown <gavin.brown@centralnic.com>
  gr.com
  
  // Radix FZC : http://domains.in.net
  // Submitted by Gavin Brown <gavin.brown@centralnic.com>
  in.net
  
  // US REGISTRY LLC : http://us.org
  // Submitted by Gavin Brown <gavin.brown@centralnic.com>
  us.org
  
  // co.com Registry, LLC : https://registry.co.com
  // Submitted by Gavin Brown <gavin.brown@centralnic.com>
  co.com
  
  // c.la : http://www.c.la/
  c.la
  
  // certmgr.org : https://certmgr.org
  // Submitted by B. Blechschmidt <hostmaster@certmgr.org>
  certmgr.org
  
  // Citrix : https://citrix.com
  // Submitted by Alex Stoddard <alex.stoddard@citrix.com>
  xenapponazure.com
  
  // ClearVox : http://www.clearvox.nl/
  // Submitted by Leon Rowland <leon@clearvox.nl>
  virtueeldomein.nl
  
  // Clever Cloud : https://www.clever-cloud.com/
  // Submitted by Quentin Adam <noc@clever-cloud.com>
  cleverapps.io
  
  // Cloud66 : https://www.cloud66.com/
  // Submitted by Khash Sajadi <khash@cloud66.com>
  c66.me
  cloud66.ws
  
  // CloudAccess.net : https://www.cloudaccess.net/
  // Submitted by Pawel Panek <noc@cloudaccess.net>
  jdevcloud.com
  wpdevcloud.com
  cloudaccess.host
  freesite.host
  cloudaccess.net
  
  // cloudControl : https://www.cloudcontrol.com/
  // Submitted by Tobias Wilken <tw@cloudcontrol.com>
  cloudcontrolled.com
  cloudcontrolapp.com
  
  // co.ca : http://registry.co.ca/
  co.ca
  
  // Co & Co : https://co-co.nl/
  // Submitted by Govert Versluis <govert@co-co.nl>
  *.otap.co
  
  // i-registry s.r.o. : http://www.i-registry.cz/
  // Submitted by Martin Semrad <semrad@i-registry.cz>
  co.cz
  
  // CDN77.com : http://www.cdn77.com
  // Submitted by Jan Krpes <jan.krpes@cdn77.com>
  c.cdn77.org
  cdn77-ssl.net
  r.cdn77.net
  rsc.cdn77.org
  ssl.origin.cdn77-secure.org
  
  // Cloud DNS Ltd : http://www.cloudns.net
  // Submitted by Aleksander Hristov <noc@cloudns.net>
  cloudns.asia
  cloudns.biz
  cloudns.club
  cloudns.cc
  cloudns.eu
  cloudns.in
  cloudns.info
  cloudns.org
  cloudns.pro
  cloudns.pw
  cloudns.us
  
  // Cloudeity Inc : https://cloudeity.com
  // Submitted by Stefan Dimitrov <contact@cloudeity.com>
  cloudeity.net
  
  // CNPY : https://cnpy.gdn
  // Submitted by Angelo Gladding <angelo@lahacker.net>
  cnpy.gdn
  
  // CoDNS B.V.
  co.nl
  co.no
  
  // Combell.com : https://www.combell.com
  // Submitted by Thomas Wouters <thomas.wouters@combellgroup.com>
  webhosting.be
  hosting-cluster.nl
  
  // COSIMO GmbH : http://www.cosimo.de
  // Submitted by Rene Marticke <rmarticke@cosimo.de>
  dyn.cosidns.de
  dynamisches-dns.de
  dnsupdater.de
  internet-dns.de
  l-o-g-i-n.de
  dynamic-dns.info
  feste-ip.net
  knx-server.net
  static-access.net
  
  // Craynic, s.r.o. : http://www.craynic.com/
  // Submitted by Ales Krajnik <ales.krajnik@craynic.com>
  realm.cz
  
  // Cryptonomic : https://cryptonomic.net/
  // Submitted by Andrew Cady <public-suffix-list@cryptonomic.net>
  *.cryptonomic.net
  
  // Cupcake : https://cupcake.io/
  // Submitted by Jonathan Rudenberg <jonathan@cupcake.io>
  cupcake.is
  
  // cyon GmbH : https://www.cyon.ch/
  // Submitted by Dominic Luechinger <dol@cyon.ch>
  cyon.link
  cyon.site
  
  // Daplie, Inc : https://daplie.com
  // Submitted by AJ ONeal <aj@daplie.com>
  daplie.me
  localhost.daplie.me
  
  // Datto, Inc. : https://www.datto.com/
  // Submitted by Philipp Heckel <ph@datto.com>
  dattolocal.com
  dattorelay.com
  dattoweb.com
  mydatto.com
  dattolocal.net
  mydatto.net
  
  // Dansk.net : http://www.dansk.net/
  // Submitted by Anani Voule <digital@digital.co.dk>
  biz.dk
  co.dk
  firm.dk
  reg.dk
  store.dk
  
  // dapps.earth : https://dapps.earth/
  // Submitted by Daniil Burdakov <icqkill@gmail.com>
  *.dapps.earth
  *.bzz.dapps.earth
  
  // Debian : https://www.debian.org/
  // Submitted by Peter Palfrader / Debian Sysadmin Team <dsa-publicsuffixlist@debian.org>
  debian.net
  
  // deSEC : https://desec.io/
  // Submitted by Peter Thomassen <peter@desec.io>
  dedyn.io
  
  // DNShome : https://www.dnshome.de/
  // Submitted by Norbert Auler <mail@dnshome.de>
  dnshome.de
  
  // DotArai : https://www.dotarai.com/
  // Submitted by Atsadawat Netcharadsang <atsadawat@dotarai.co.th>
  online.th
  shop.th
  
  // DrayTek Corp. : https://www.draytek.com/
  // Submitted by Paul Fang <mis@draytek.com>
  drayddns.com
  
  // DreamHost : http://www.dreamhost.com/
  // Submitted by Andrew Farmer <andrew.farmer@dreamhost.com>
  dreamhosters.com
  
  // Drobo : http://www.drobo.com/
  // Submitted by Ricardo Padilha <rpadilha@drobo.com>
  mydrobo.com
  
  // Drud Holdings, LLC. : https://www.drud.com/
  // Submitted by Kevin Bridges <kevin@drud.com>
  drud.io
  drud.us
  
  // DuckDNS : http://www.duckdns.org/
  // Submitted by Richard Harper <richard@duckdns.org>
  duckdns.org
  
  // dy.fi : http://dy.fi/
  // Submitted by Heikki Hannikainen <hessu@hes.iki.fi>
  dy.fi
  tunk.org
  
  // DynDNS.com : http://www.dyndns.com/services/dns/dyndns/
  dyndns-at-home.com
  dyndns-at-work.com
  dyndns-blog.com
  dyndns-free.com
  dyndns-home.com
  dyndns-ip.com
  dyndns-mail.com
  dyndns-office.com
  dyndns-pics.com
  dyndns-remote.com
  dyndns-server.com
  dyndns-web.com
  dyndns-wiki.com
  dyndns-work.com
  dyndns.biz
  dyndns.info
  dyndns.org
  dyndns.tv
  at-band-camp.net
  ath.cx
  barrel-of-knowledge.info
  barrell-of-knowledge.info
  better-than.tv
  blogdns.com
  blogdns.net
  blogdns.org
  blogsite.org
  boldlygoingnowhere.org
  broke-it.net
  buyshouses.net
  cechire.com
  dnsalias.com
  dnsalias.net
  dnsalias.org
  dnsdojo.com
  dnsdojo.net
  dnsdojo.org
  does-it.net
  doesntexist.com
  doesntexist.org
  dontexist.com
  dontexist.net
  dontexist.org
  doomdns.com
  doomdns.org
  dvrdns.org
  dyn-o-saur.com
  dynalias.com
  dynalias.net
  dynalias.org
  dynathome.net
  dyndns.ws
  endofinternet.net
  endofinternet.org
  endoftheinternet.org
  est-a-la-maison.com
  est-a-la-masion.com
  est-le-patron.com
  est-mon-blogueur.com
  for-better.biz
  for-more.biz
  for-our.info
  for-some.biz
  for-the.biz
  forgot.her.name
  forgot.his.name
  from-ak.com
  from-al.com
  from-ar.com
  from-az.net
  from-ca.com
  from-co.net
  from-ct.com
  from-dc.com
  from-de.com
  from-fl.com
  from-ga.com
  from-hi.com
  from-ia.com
  from-id.com
  from-il.com
  from-in.com
  from-ks.com
  from-ky.com
  from-la.net
  from-ma.com
  from-md.com
  from-me.org
  from-mi.com
  from-mn.com
  from-mo.com
  from-ms.com
  from-mt.com
  from-nc.com
  from-nd.com
  from-ne.com
  from-nh.com
  from-nj.com
  from-nm.com
  from-nv.com
  from-ny.net
  from-oh.com
  from-ok.com
  from-or.com
  from-pa.com
  from-pr.com
  from-ri.com
  from-sc.com
  from-sd.com
  from-tn.com
  from-tx.com
  from-ut.com
  from-va.com
  from-vt.com
  from-wa.com
  from-wi.com
  from-wv.com
  from-wy.com
  ftpaccess.cc
  fuettertdasnetz.de
  game-host.org
  game-server.cc
  getmyip.com
  gets-it.net
  go.dyndns.org
  gotdns.com
  gotdns.org
  groks-the.info
  groks-this.info
  ham-radio-op.net
  here-for-more.info
  hobby-site.com
  hobby-site.org
  home.dyndns.org
  homedns.org
  homeftp.net
  homeftp.org
  homeip.net
  homelinux.com
  homelinux.net
  homelinux.org
  homeunix.com
  homeunix.net
  homeunix.org
  iamallama.com
  in-the-band.net
  is-a-anarchist.com
  is-a-blogger.com
  is-a-bookkeeper.com
  is-a-bruinsfan.org
  is-a-bulls-fan.com
  is-a-candidate.org
  is-a-caterer.com
  is-a-celticsfan.org
  is-a-chef.com
  is-a-chef.net
  is-a-chef.org
  is-a-conservative.com
  is-a-cpa.com
  is-a-cubicle-slave.com
  is-a-democrat.com
  is-a-designer.com
  is-a-doctor.com
  is-a-financialadvisor.com
  is-a-geek.com
  is-a-geek.net
  is-a-geek.org
  is-a-green.com
  is-a-guru.com
  is-a-hard-worker.com
  is-a-hunter.com
  is-a-knight.org
  is-a-landscaper.com
  is-a-lawyer.com
  is-a-liberal.com
  is-a-libertarian.com
  is-a-linux-user.org
  is-a-llama.com
  is-a-musician.com
  is-a-nascarfan.com
  is-a-nurse.com
  is-a-painter.com
  is-a-patsfan.org
  is-a-personaltrainer.com
  is-a-photographer.com
  is-a-player.com
  is-a-republican.com
  is-a-rockstar.com
  is-a-socialist.com
  is-a-soxfan.org
  is-a-student.com
  is-a-teacher.com
  is-a-techie.com
  is-a-therapist.com
  is-an-accountant.com
  is-an-actor.com
  is-an-actress.com
  is-an-anarchist.com
  is-an-artist.com
  is-an-engineer.com
  is-an-entertainer.com
  is-by.us
  is-certified.com
  is-found.org
  is-gone.com
  is-into-anime.com
  is-into-cars.com
  is-into-cartoons.com
  is-into-games.com
  is-leet.com
  is-lost.org
  is-not-certified.com
  is-saved.org
  is-slick.com
  is-uberleet.com
  is-very-bad.org
  is-very-evil.org
  is-very-good.org
  is-very-nice.org
  is-very-sweet.org
  is-with-theband.com
  isa-geek.com
  isa-geek.net
  isa-geek.org
  isa-hockeynut.com
  issmarterthanyou.com
  isteingeek.de
  istmein.de
  kicks-ass.net
  kicks-ass.org
  knowsitall.info
  land-4-sale.us
  lebtimnetz.de
  leitungsen.de
  likes-pie.com
  likescandy.com
  merseine.nu
  mine.nu
  misconfused.org
  mypets.ws
  myphotos.cc
  neat-url.com
  office-on-the.net
  on-the-web.tv
  podzone.net
  podzone.org
  readmyblog.org
  saves-the-whales.com
  scrapper-site.net
  scrapping.cc
  selfip.biz
  selfip.com
  selfip.info
  selfip.net
  selfip.org
  sells-for-less.com
  sells-for-u.com
  sells-it.net
  sellsyourhome.org
  servebbs.com
  servebbs.net
  servebbs.org
  serveftp.net
  serveftp.org
  servegame.org
  shacknet.nu
  simple-url.com
  space-to-rent.com
  stuff-4-sale.org
  stuff-4-sale.us
  teaches-yoga.com
  thruhere.net
  traeumtgerade.de
  webhop.biz
  webhop.info
  webhop.net
  webhop.org
  worse-than.tv
  writesthisblog.com
  
  // ddnss.de : https://www.ddnss.de/
  // Submitted by Robert Niedziela <webmaster@ddnss.de>
  ddnss.de
  dyn.ddnss.de
  dyndns.ddnss.de
  dyndns1.de
  dyn-ip24.de
  home-webserver.de
  dyn.home-webserver.de
  myhome-server.de
  ddnss.org
  
  // Definima : http://www.definima.com/
  // Submitted by Maxence Bitterli <maxence@definima.com>
  definima.net
  definima.io
  
  // dnstrace.pro : https://dnstrace.pro/
  // Submitted by Chris Partridge <chris@partridge.tech>
  bci.dnstrace.pro
  
  // Dynu.com : https://www.dynu.com/
  // Submitted by Sue Ye <sue@dynu.com>
  ddnsfree.com
  ddnsgeek.com
  giize.com
  gleeze.com
  kozow.com
  loseyourip.com
  ooguy.com
  theworkpc.com
  casacam.net
  dynu.net
  accesscam.org
  camdvr.org
  freeddns.org
  mywire.org
  webredirect.org
  myddns.rocks
  blogsite.xyz
  
  // dynv6 : https://dynv6.com
  // Submitted by Dominik Menke <dom@digineo.de>
  dynv6.net
  
  // E4YOU spol. s.r.o. : https://e4you.cz/
  // Submitted by Vladimir Dudr <info@e4you.cz>
  e4.cz
  
  // Enalean SAS: https://www.enalean.com
  // Submitted by Thomas Cottier <thomas.cottier@enalean.com>
  mytuleap.com
  
  // Enonic : http://enonic.com/
  // Submitted by Erik Kaareng-Sunde <esu@enonic.com>
  enonic.io
  customer.enonic.io
  
  // EU.org https://eu.org/
  // Submitted by Pierre Beyssac <hostmaster@eu.org>
  eu.org
  al.eu.org
  asso.eu.org
  at.eu.org
  au.eu.org
  be.eu.org
  bg.eu.org
  ca.eu.org
  cd.eu.org
  ch.eu.org
  cn.eu.org
  cy.eu.org
  cz.eu.org
  de.eu.org
  dk.eu.org
  edu.eu.org
  ee.eu.org
  es.eu.org
  fi.eu.org
  fr.eu.org
  gr.eu.org
  hr.eu.org
  hu.eu.org
  ie.eu.org
  il.eu.org
  in.eu.org
  int.eu.org
  is.eu.org
  it.eu.org
  jp.eu.org
  kr.eu.org
  lt.eu.org
  lu.eu.org
  lv.eu.org
  mc.eu.org
  me.eu.org
  mk.eu.org
  mt.eu.org
  my.eu.org
  net.eu.org
  ng.eu.org
  nl.eu.org
  no.eu.org
  nz.eu.org
  paris.eu.org
  pl.eu.org
  pt.eu.org
  q-a.eu.org
  ro.eu.org
  ru.eu.org
  se.eu.org
  si.eu.org
  sk.eu.org
  tr.eu.org
  uk.eu.org
  us.eu.org
  
  // Evennode : http://www.evennode.com/
  // Submitted by Michal Kralik <support@evennode.com>
  eu-1.evennode.com
  eu-2.evennode.com
  eu-3.evennode.com
  eu-4.evennode.com
  us-1.evennode.com
  us-2.evennode.com
  us-3.evennode.com
  us-4.evennode.com
  
  // eDirect Corp. : https://hosting.url.com.tw/
  // Submitted by C.S. chang <cschang@corp.url.com.tw>
  twmail.cc
  twmail.net
  twmail.org
  mymailer.com.tw
  url.tw
  
  // Facebook, Inc.
  // Submitted by Peter Ruibal <public-suffix@fb.com>
  apps.fbsbx.com
  
  // FAITID : https://faitid.org/
  // Submitted by Maxim Alzoba <tech.contact@faitid.org>
  // https://www.flexireg.net/stat_info
  ru.net
  adygeya.ru
  bashkiria.ru
  bir.ru
  cbg.ru
  com.ru
  dagestan.ru
  grozny.ru
  kalmykia.ru
  kustanai.ru
  marine.ru
  mordovia.ru
  msk.ru
  mytis.ru
  nalchik.ru
  nov.ru
  pyatigorsk.ru
  spb.ru
  vladikavkaz.ru
  vladimir.ru
  abkhazia.su
  adygeya.su
  aktyubinsk.su
  arkhangelsk.su
  armenia.su
  ashgabad.su
  azerbaijan.su
  balashov.su
  bashkiria.su
  bryansk.su
  bukhara.su
  chimkent.su
  dagestan.su
  east-kazakhstan.su
  exnet.su
  georgia.su
  grozny.su
  ivanovo.su
  jambyl.su
  kalmykia.su
  kaluga.su
  karacol.su
  karaganda.su
  karelia.su
  khakassia.su
  krasnodar.su
  kurgan.su
  kustanai.su
  lenug.su
  mangyshlak.su
  mordovia.su
  msk.su
  murmansk.su
  nalchik.su
  navoi.su
  north-kazakhstan.su
  nov.su
  obninsk.su
  penza.su
  pokrovsk.su
  sochi.su
  spb.su
  tashkent.su
  termez.su
  togliatti.su
  troitsk.su
  tselinograd.su
  tula.su
  tuva.su
  vladikavkaz.su
  vladimir.su
  vologda.su
  
  // Fancy Bits, LLC : http://getchannels.com
  // Submitted by Aman Gupta <aman@getchannels.com>
  channelsdvr.net
  
  // Fastly Inc. : http://www.fastly.com/
  // Submitted by Fastly Security <security@fastly.com>
  fastly-terrarium.com
  fastlylb.net
  map.fastlylb.net
  freetls.fastly.net
  map.fastly.net
  a.prod.fastly.net
  global.prod.fastly.net
  a.ssl.fastly.net
  b.ssl.fastly.net
  global.ssl.fastly.net
  
  // FASTVPS EESTI OU : https://fastvps.ru/
  // Submitted by Likhachev Vasiliy <lihachev@fastvps.ru>
  fastpanel.direct
  fastvps-server.com
  
  // Featherhead : https://featherhead.xyz/
  // Submitted by Simon Menke <simon@featherhead.xyz>
  fhapp.xyz
  
  // Fedora : https://fedoraproject.org/
  // submitted by Patrick Uiterwijk <puiterwijk@fedoraproject.org>
  fedorainfracloud.org
  fedorapeople.org
  cloud.fedoraproject.org
  app.os.fedoraproject.org
  app.os.stg.fedoraproject.org
  
  // Fermax : https://fermax.com/
  // submitted by Koen Van Isterdael <k.vanisterdael@fermax.be>
  mydobiss.com
  
  // Filegear Inc. : https://www.filegear.com
  // Submitted by Jason Zhu <jason@owtware.com>
  filegear.me
  filegear-au.me
  filegear-de.me
  filegear-gb.me
  filegear-ie.me
  filegear-jp.me
  filegear-sg.me
  
  // Firebase, Inc.
  // Submitted by Chris Raynor <chris@firebase.com>
  firebaseapp.com
  
  // Flynn : https://flynn.io
  // Submitted by Jonathan Rudenberg <jonathan@flynn.io>
  flynnhub.com
  flynnhosting.net
  
  // Freebox : http://www.freebox.fr
  // Submitted by Romain Fliedel <rfliedel@freebox.fr>
  freebox-os.com
  freeboxos.com
  fbx-os.fr
  fbxos.fr
  freebox-os.fr
  freeboxos.fr
  
  // freedesktop.org : https://www.freedesktop.org
  // Submitted by Daniel Stone <daniel@fooishbar.org>
  freedesktop.org
  
  // Futureweb OG : http://www.futureweb.at
  // Submitted by Andreas Schnederle-Wagner <schnederle@futureweb.at>
  *.futurecms.at
  *.ex.futurecms.at
  *.in.futurecms.at
  futurehosting.at
  futuremailing.at
  *.ex.ortsinfo.at
  *.kunden.ortsinfo.at
  *.statics.cloud
  
  // GDS : https://www.gov.uk/service-manual/operations/operating-servicegovuk-subdomains
  // Submitted by David Illsley <david.illsley@digital.cabinet-office.gov.uk>
  service.gov.uk
  
  // GitHub, Inc.
  // Submitted by Patrick Toomey <security@github.com>
  github.io
  githubusercontent.com
  
  // GitLab, Inc.
  // Submitted by Alex Hanselka <alex@gitlab.com>
  gitlab.io
  
  // UKHomeOffice : https://www.gov.uk/government/organisations/home-office
  // Submitted by Jon Shanks <jon.shanks@digital.homeoffice.gov.uk>
  homeoffice.gov.uk
  
  // GlobeHosting, Inc.
  // Submitted by Zoltan Egresi <egresi@globehosting.com>
  ro.im
  shop.ro
  
  // GoIP DNS Services : http://www.goip.de
  // Submitted by Christian Poulter <milchstrasse@goip.de>
  goip.de
  
  // Google, Inc.
  // Submitted by Eduardo Vela <evn@google.com>
  run.app
  a.run.app
  *.0emm.com
  appspot.com
  blogspot.ae
  blogspot.al
  blogspot.am
  blogspot.ba
  blogspot.be
  blogspot.bg
  blogspot.bj
  blogspot.ca
  blogspot.cf
  blogspot.ch
  blogspot.cl
  blogspot.co.at
  blogspot.co.id
  blogspot.co.il
  blogspot.co.ke
  blogspot.co.nz
  blogspot.co.uk
  blogspot.co.za
  blogspot.com
  blogspot.com.ar
  blogspot.com.au
  blogspot.com.br
  blogspot.com.by
  blogspot.com.co
  blogspot.com.cy
  blogspot.com.ee
  blogspot.com.eg
  blogspot.com.es
  blogspot.com.mt
  blogspot.com.ng
  blogspot.com.tr
  blogspot.com.uy
  blogspot.cv
  blogspot.cz
  blogspot.de
  blogspot.dk
  blogspot.fi
  blogspot.fr
  blogspot.gr
  blogspot.hk
  blogspot.hr
  blogspot.hu
  blogspot.ie
  blogspot.in
  blogspot.is
  blogspot.it
  blogspot.jp
  blogspot.kr
  blogspot.li
  blogspot.lt
  blogspot.lu
  blogspot.md
  blogspot.mk
  blogspot.mr
  blogspot.mx
  blogspot.my
  blogspot.nl
  blogspot.no
  blogspot.pe
  blogspot.pt
  blogspot.qa
  blogspot.re
  blogspot.ro
  blogspot.rs
  blogspot.ru
  blogspot.se
  blogspot.sg
  blogspot.si
  blogspot.sk
  blogspot.sn
  blogspot.td
  blogspot.tw
  blogspot.ug
  blogspot.vn
  cloudfunctions.net
  cloud.goog
  codespot.com
  googleapis.com
  googlecode.com
  pagespeedmobilizer.com
  publishproxy.com
  withgoogle.com
  withyoutube.com
  
  // Hashbang : https://hashbang.sh
  hashbang.sh
  
  // Hasura : https://hasura.io
  // Submitted by Shahidh K Muhammed <shahidh@hasura.io>
  hasura.app
  hasura-app.io
  
  // Hepforge : https://www.hepforge.org
  // Submitted by David Grellscheid <admin@hepforge.org>
  hepforge.org
  
  // Heroku : https://www.heroku.com/
  // Submitted by Tom Maher <tmaher@heroku.com>
  herokuapp.com
  herokussl.com
  
  // Hibernating Rhinos
  // Submitted by Oren Eini <oren@ravendb.net>
  myravendb.com
  ravendb.community
  ravendb.me
  development.run
  ravendb.run
  
  // Ici la Lune : http://www.icilalune.com/
  // Submitted by Simon Morvan <simon@icilalune.com>
  moonscale.net
  
  // iki.fi
  // Submitted by Hannu Aronsson <haa@iki.fi>
  iki.fi
  
  // Individual Network Berlin e.V. : https://www.in-berlin.de/
  // Submitted by Christian Seitz <chris@in-berlin.de>
  dyn-berlin.de
  in-berlin.de
  in-brb.de
  in-butter.de
  in-dsl.de
  in-dsl.net
  in-dsl.org
  in-vpn.de
  in-vpn.net
  in-vpn.org
  
  // info.at : http://www.info.at/
  biz.at
  info.at
  
  // info.cx : http://info.cx
  // Submitted by Jacob Slater <whois@igloo.to>
  info.cx
  
  // Interlegis : http://www.interlegis.leg.br
  // Submitted by Gabriel Ferreira <registrobr@interlegis.leg.br>
  ac.leg.br
  al.leg.br
  am.leg.br
  ap.leg.br
  ba.leg.br
  ce.leg.br
  df.leg.br
  es.leg.br
  go.leg.br
  ma.leg.br
  mg.leg.br
  ms.leg.br
  mt.leg.br
  pa.leg.br
  pb.leg.br
  pe.leg.br
  pi.leg.br
  pr.leg.br
  rj.leg.br
  rn.leg.br
  ro.leg.br
  rr.leg.br
  rs.leg.br
  sc.leg.br
  se.leg.br
  sp.leg.br
  to.leg.br
  
  // intermetrics GmbH : https://pixolino.com/
  // Submitted by Wolfgang Schwarz <admin@intermetrics.de>
  pixolino.com
  
  // IPiFony Systems, Inc. : https://www.ipifony.com/
  // Submitted by Matthew Hardeman <mhardeman@ipifony.com>
  ipifony.net
  
  // IServ GmbH : https://iserv.eu
  // Submitted by Kim-Alexander Brodowski <kim.brodowski@iserv.eu>
  mein-iserv.de
  test-iserv.de
  
  // Jino : https://www.jino.ru
  // Submitted by Sergey Ulyashin <ulyashin@jino.ru>
  myjino.ru
  *.hosting.myjino.ru
  *.landing.myjino.ru
  *.spectrum.myjino.ru
  *.vps.myjino.ru
  
  // Joyent : https://www.joyent.com/
  // Submitted by Brian Bennett <brian.bennett@joyent.com>
  *.triton.zone
  *.cns.joyent.com
  
  // JS.ORG : http://dns.js.org
  // Submitted by Stefan Keim <admin@js.org>
  js.org
  
  // Keyweb AG : https://www.keyweb.de
  // Submitted by Martin Dannehl <postmaster@keymachine.de>
  keymachine.de
  
  // KnightPoint Systems, LLC : http://www.knightpoint.com/
  // Submitted by Roy Keene <rkeene@knightpoint.com>
  knightpoint.systems
  
  // .KRD : http://nic.krd/data/krd/Registration%20Policy.pdf
  co.krd
  edu.krd
  
  // LCube - Professional hosting e.K. : https://www.lcube-webhosting.de
  // Submitted by Lars Laehn <info@lcube.de>
  git-repos.de
  lcube-server.de
  svn-repos.de
  
  // Leadpages : https://www.leadpages.net
  // Submitted by Greg Dallavalle <domains@leadpages.net>
  leadpages.co
  lpages.co
  lpusercontent.com
  
  // Lifetime Hosting : https://Lifetime.Hosting/
  // Submitted by Mike Fillator <support@lifetime.hosting>
  co.business
  co.education
  co.events
  co.financial
  co.network
  co.place
  co.technology
  
  // Lightmaker Property Manager, Inc. : https://app.lmpm.com/
  // Submitted by Greg Holland <greg.holland@lmpm.com>
  app.lmpm.com
  
  // Linki Tools UG : https://linki.tools
  // Submitted by Paulo Matos <pmatos@linki.tools>
  linkitools.space
  
  // linkyard ldt: https://www.linkyard.ch/
  // Submitted by Mario Siegenthaler <mario.siegenthaler@linkyard.ch>
  linkyard.cloud
  linkyard-cloud.ch
  
  // LiquidNet Ltd : http://www.liquidnetlimited.com/
  // Submitted by Victor Velchev <admin@liquidnetlimited.com>
  we.bs
  
  // LubMAN UMCS Sp. z o.o : https://lubman.pl/
  // Submitted by Ireneusz Maliszewski <ireneusz.maliszewski@lubman.pl>
  krasnik.pl
  leczna.pl
  lubartow.pl
  lublin.pl
  poniatowa.pl
  swidnik.pl
  
  // Lug.org.uk : https://lug.org.uk
  // Submitted by Jon Spriggs <admin@lug.org.uk>
  uklugs.org
  glug.org.uk
  lug.org.uk
  lugs.org.uk
  
  // Lukanet Ltd : https://lukanet.com
  // Submitted by Anton Avramov <register@lukanet.com>
  barsy.bg
  barsy.co.uk
  barsyonline.co.uk
  barsycenter.com
  barsyonline.com
  barsy.club
  barsy.de
  barsy.eu
  barsy.in
  barsy.info
  barsy.io
  barsy.me
  barsy.menu
  barsy.mobi
  barsy.net
  barsy.online
  barsy.org
  barsy.pro
  barsy.pub
  barsy.shop
  barsy.site
  barsy.support
  barsy.uk
  
  // Magento Commerce
  // Submitted by Damien Tournoud <dtournoud@magento.cloud>
  *.magentosite.cloud
  
  // May First - People Link : https://mayfirst.org/
  // Submitted by Jamie McClelland <info@mayfirst.org>
  mayfirst.info
  mayfirst.org
  
  // Mail.Ru Group : https://hb.cldmail.ru
  // Submitted by Ilya Zaretskiy <zaretskiy@corp.mail.ru>
  hb.cldmail.ru
  
  // Memset hosting : https://www.memset.com
  // Submitted by Tom Whitwell <domains@memset.com>
  miniserver.com
  memset.net
  
  // MetaCentrum, CESNET z.s.p.o. : https://www.metacentrum.cz/en/
  // Submitted by Zdeněk Šustr <zdenek.sustr@cesnet.cz>
  cloud.metacentrum.cz
  custom.metacentrum.cz
  
  // MetaCentrum, CESNET z.s.p.o. : https://www.metacentrum.cz/en/
  // Submitted by Radim Janča <janca@cesnet.cz>
  flt.cloud.muni.cz
  usr.cloud.muni.cz
  
  // Meteor Development Group : https://www.meteor.com/hosting
  // Submitted by Pierre Carrier <pierre@meteor.com>
  meteorapp.com
  eu.meteorapp.com
  
  // Michau Enterprises Limited : http://www.co.pl/
  co.pl
  
  // Microsoft Corporation : http://microsoft.com
  // Submitted by Justin Luk <juluk@microsoft.com>
  azurecontainer.io
  azurewebsites.net
  azure-mobile.net
  cloudapp.net
  
  // Mozilla Corporation : https://mozilla.com
  // Submitted by Ben Francis <bfrancis@mozilla.com>
  mozilla-iot.org
  
  // Mozilla Foundation : https://mozilla.org/
  // Submitted by glob <glob@mozilla.com>
  bmoattachments.org
  
  // MSK-IX : https://www.msk-ix.ru/
  // Submitted by Khannanov Roman <r.khannanov@msk-ix.ru>
  net.ru
  org.ru
  pp.ru
  
  // Netlify : https://www.netlify.com
  // Submitted by Jessica Parsons <jessica@netlify.com>
  bitballoon.com
  netlify.com
  
  // Neustar Inc.
  // Submitted by Trung Tran <Trung.Tran@neustar.biz>
  4u.com
  
  // ngrok : https://ngrok.com/
  // Submitted by Alan Shreve <alan@ngrok.com>
  ngrok.io
  
  // Nimbus Hosting Ltd. : https://www.nimbushosting.co.uk/
  // Submitted by Nicholas Ford <nick@nimbushosting.co.uk>
  nh-serv.co.uk
  
  // NFSN, Inc. : https://www.NearlyFreeSpeech.NET/
  // Submitted by Jeff Wheelhouse <support@nearlyfreespeech.net>
  nfshost.com
  
  // Now-DNS : https://now-dns.com
  // Submitted by Steve Russell <steve@now-dns.com>
  dnsking.ch
  mypi.co
  n4t.co
  001www.com
  ddnslive.com
  myiphost.com
  forumz.info
  16-b.it
  32-b.it
  64-b.it
  soundcast.me
  tcp4.me
  dnsup.net
  hicam.net
  now-dns.net
  ownip.net
  vpndns.net
  dynserv.org
  now-dns.org
  x443.pw
  now-dns.top
  ntdll.top
  freeddns.us
  crafting.xyz
  zapto.xyz
  
  // nsupdate.info : https://www.nsupdate.info/
  // Submitted by Thomas Waldmann <info@nsupdate.info>
  nsupdate.info
  nerdpol.ovh
  
  // No-IP.com : https://noip.com/
  // Submitted by Deven Reza <publicsuffixlist@noip.com>
  blogsyte.com
  brasilia.me
  cable-modem.org
  ciscofreak.com
  collegefan.org
  couchpotatofries.org
  damnserver.com
  ddns.me
  ditchyourip.com
  dnsfor.me
  dnsiskinky.com
  dvrcam.info
  dynns.com
  eating-organic.net
  fantasyleague.cc
  geekgalaxy.com
  golffan.us
  health-carereform.com
  homesecuritymac.com
  homesecuritypc.com
  hopto.me
  ilovecollege.info
  loginto.me
  mlbfan.org
  mmafan.biz
  myactivedirectory.com
  mydissent.net
  myeffect.net
  mymediapc.net
  mypsx.net
  mysecuritycamera.com
  mysecuritycamera.net
  mysecuritycamera.org
  net-freaks.com
  nflfan.org
  nhlfan.net
  no-ip.ca
  no-ip.co.uk
  no-ip.net
  noip.us
  onthewifi.com
  pgafan.net
  point2this.com
  pointto.us
  privatizehealthinsurance.net
  quicksytes.com
  read-books.org
  securitytactics.com
  serveexchange.com
  servehumour.com
  servep2p.com
  servesarcasm.com
  stufftoread.com
  ufcfan.org
  unusualperson.com
  workisboring.com
  3utilities.com
  bounceme.net
  ddns.net
  ddnsking.com
  gotdns.ch
  hopto.org
  myftp.biz
  myftp.org
  myvnc.com
  no-ip.biz
  no-ip.info
  no-ip.org
  noip.me
  redirectme.net
  servebeer.com
  serveblog.net
  servecounterstrike.com
  serveftp.com
  servegame.com
  servehalflife.com
  servehttp.com
  serveirc.com
  serveminecraft.net
  servemp3.com
  servepics.com
  servequake.com
  sytes.net
  webhop.me
  zapto.org
  
  // NodeArt : https://nodeart.io
  // Submitted by Konstantin Nosov <Nosov@nodeart.io>
  stage.nodeart.io
  
  // Nodum B.V. : https://nodum.io/
  // Submitted by Wietse Wind <hello+publicsuffixlist@nodum.io>
  nodum.co
  nodum.io
  
  // Nucleos Inc. : https://nucleos.com
  // Submitted by Piotr Zduniak <piotr@nucleos.com>
  pcloud.host
  
  // NYC.mn : http://www.information.nyc.mn
  // Submitted by Matthew Brown <mattbrown@nyc.mn>
  nyc.mn
  
  // NymNom : https://nymnom.com/
  // Submitted by Dave McCormack <dave.mccormack@nymnom.com>
  nom.ae
  nom.af
  nom.ai
  nom.al
  nym.by
  nym.bz
  nom.cl
  nom.gd
  nom.ge
  nom.gl
  nym.gr
  nom.gt
  nym.gy
  nom.hn
  nym.ie
  nom.im
  nom.ke
  nym.kz
  nym.la
  nym.lc
  nom.li
  nym.li
  nym.lt
  nym.lu
  nym.me
  nom.mk
  nym.mn
  nym.mx
  nom.nu
  nym.nz
  nym.pe
  nym.pt
  nom.pw
  nom.qa
  nym.ro
  nom.rs
  nom.si
  nym.sk
  nom.st
  nym.su
  nym.sx
  nom.tj
  nym.tw
  nom.ug
  nom.uy
  nom.vc
  nom.vg
  
  // Octopodal Solutions, LLC. : https://ulterius.io/
  // Submitted by Andrew Sampson <andrew@ulterius.io>
  cya.gg
  
  // Omnibond Systems, LLC. : https://www.omnibond.com
  // Submitted by Cole Estep <cole@omnibond.com>
  cloudycluster.net
  
  // One Fold Media : http://www.onefoldmedia.com/
  // Submitted by Eddie Jones <eddie@onefoldmedia.com>
  nid.io
  
  // OpenCraft GmbH : http://opencraft.com/
  // Submitted by Sven Marnach <sven@opencraft.com>
  opencraft.hosting
  
  // Opera Software, A.S.A.
  // Submitted by Yngve Pettersen <yngve@opera.com>
  operaunite.com
  
  // OutSystems
  // Submitted by Duarte Santos <domain-admin@outsystemscloud.com>
  outsystemscloud.com
  
  // OwnProvider GmbH: http://www.ownprovider.com
  // Submitted by Jan Moennich <jan.moennich@ownprovider.com>
  ownprovider.com
  own.pm
  
  // OX : http://www.ox.rs
  // Submitted by Adam Grand <webmaster@mail.ox.rs>
  ox.rs
  
  // oy.lc
  // Submitted by Charly Coste <changaco@changaco.oy.lc>
  oy.lc
  
  // Pagefog : https://pagefog.com/
  // Submitted by Derek Myers <derek@pagefog.com>
  pgfog.com
  
  // Pagefront : https://www.pagefronthq.com/
  // Submitted by Jason Kriss <jason@pagefronthq.com>
  pagefrontapp.com
  
  // .pl domains (grandfathered)
  art.pl
  gliwice.pl
  krakow.pl
  poznan.pl
  wroc.pl
  zakopane.pl
  
  // Pantheon Systems, Inc. : https://pantheon.io/
  // Submitted by Gary Dylina <gary@pantheon.io>
  pantheonsite.io
  gotpantheon.com
  
  // Peplink | Pepwave : http://peplink.com/
  // Submitted by Steve Leung <steveleung@peplink.com>
  mypep.link
  
  // Planet-Work : https://www.planet-work.com/
  // Submitted by Frédéric VANNIÈRE <f.vanniere@planet-work.com>
  on-web.fr
  
  // Platform.sh : https://platform.sh
  // Submitted by Nikola Kotur <nikola@platform.sh>
  *.platform.sh
  *.platformsh.site
  
  // prgmr.com : https://prgmr.com/
  // Submitted by Sarah Newman <owner@prgmr.com>
  xen.prgmr.com
  
  // priv.at : http://www.nic.priv.at/
  // Submitted by registry <lendl@nic.at>
  priv.at
  
  // Protonet GmbH : http://protonet.io
  // Submitted by Martin Meier <admin@protonet.io>
  protonet.io
  
  // Publication Presse Communication SARL : https://ppcom.fr
  // Submitted by Yaacov Akiba Slama <admin@chirurgiens-dentistes-en-france.fr>
  chirurgiens-dentistes-en-france.fr
  byen.site
  
  // Redstar Consultants : https://www.redstarconsultants.com/
  // Submitted by Jons Slemmer <jons@redstarconsultants.com>
  instantcloud.cn
  
  // Russian Academy of Sciences
  // Submitted by Tech Support <support@rasnet.ru>
  ras.ru
  
  // QA2
  // Submitted by Daniel Dent (https://www.danieldent.com/)
  qa2.com
  
  // QNAP System Inc : https://www.qnap.com
  // Submitted by Nick Chang <nickchang@qnap.com>
  dev-myqnapcloud.com
  alpha-myqnapcloud.com
  myqnapcloud.com
  
  // Quip : https://quip.com
  // Submitted by Patrick Linehan <plinehan@quip.com>
  *.quipelements.com
  
  // Qutheory LLC : http://qutheory.io
  // Submitted by Jonas Schwartz <jonas@qutheory.io>
  vapor.cloud
  vaporcloud.io
  
  // Rackmaze LLC : https://www.rackmaze.com
  // Submitted by Kirill Pertsev <kika@rackmaze.com>
  rackmaze.com
  rackmaze.net
  
  // Read The Docs, Inc : https://www.readthedocs.org
  // Submitted by David Fischer <team@readthedocs.org>
  readthedocs.io
  
  // Red Hat, Inc. OpenShift : https://openshift.redhat.com/
  // Submitted by Tim Kramer <tkramer@rhcloud.com>
  rhcloud.com
  
  // Resin.io : https://resin.io
  // Submitted by Tim Perry <tim@resin.io>
  resindevice.io
  devices.resinstaging.io
  
  // RethinkDB : https://www.rethinkdb.com/
  // Submitted by Chris Kastorff <info@rethinkdb.com>
  hzc.io
  
  // Revitalised Limited : http://www.revitalised.co.uk
  // Submitted by Jack Price <jack@revitalised.co.uk>
  wellbeingzone.eu
  ptplus.fit
  wellbeingzone.co.uk
  
  // Sandstorm Development Group, Inc. : https://sandcats.io/
  // Submitted by Asheesh Laroia <asheesh@sandstorm.io>
  sandcats.io
  
  // SBE network solutions GmbH : https://www.sbe.de/
  // Submitted by Norman Meilick <nm@sbe.de>
  logoip.de
  logoip.com
  
  // schokokeks.org GbR : https://schokokeks.org/
  // Submitted by Hanno Böck <hanno@schokokeks.org>
  schokokeks.net
  
  // Scry Security : http://www.scrysec.com
  // Submitted by Shante Adam <shante@skyhat.io>
  scrysec.com
  
  // Securepoint GmbH : https://www.securepoint.de
  // Submitted by Erik Anders <erik.anders@securepoint.de>
  firewall-gateway.com
  firewall-gateway.de
  my-gateway.de
  my-router.de
  spdns.de
  spdns.eu
  firewall-gateway.net
  my-firewall.org
  myfirewall.org
  spdns.org
  
  // SensioLabs, SAS : https://sensiolabs.com/
  // Submitted by Fabien Potencier <fabien.potencier@sensiolabs.com>
  *.s5y.io
  *.sensiosite.cloud
  
  // Service Online LLC : http://drs.ua/
  // Submitted by Serhii Bulakh <support@drs.ua>
  biz.ua
  co.ua
  pp.ua
  
  // ShiftEdit : https://shiftedit.net/
  // Submitted by Adam Jimenez <adam@shiftcreate.com>
  shiftedit.io
  
  // Shopblocks : http://www.shopblocks.com/
  // Submitted by Alex Bowers <alex@shopblocks.com>
  myshopblocks.com
  
  // SinaAppEngine : http://sae.sina.com.cn/
  // Submitted by SinaAppEngine <saesupport@sinacloud.com>
  1kapp.com
  appchizi.com
  applinzi.com
  sinaapp.com
  vipsinaapp.com
  
  // Siteleaf : https://www.siteleaf.com/
  // Submitted by Skylar Challand <support@siteleaf.com>
  siteleaf.net
  
  // Skyhat : http://www.skyhat.io
  // Submitted by Shante Adam <shante@skyhat.io>
  bounty-full.com
  alpha.bounty-full.com
  beta.bounty-full.com
  
  // staticland : https://static.land
  // Submitted by Seth Vincent <sethvincent@gmail.com>
  static.land
  dev.static.land
  sites.static.land
  
  // SourceLair PC : https://www.sourcelair.com
  // Submitted by Antonis Kalipetis <akalipetis@sourcelair.com>
  apps.lair.io
  *.stolos.io
  
  // SpaceKit : https://www.spacekit.io/
  // Submitted by Reza Akhavan <spacekit.io@gmail.com>
  spacekit.io
  
  // SpeedPartner GmbH: https://www.speedpartner.de/
  // Submitted by Stefan Neufeind <info@speedpartner.de>
  customer.speedpartner.de
  
  // Standard Library : https://stdlib.com
  // Submitted by Jacob Lee <jacob@stdlib.com>
  api.stdlib.com
  
  // Storj Labs Inc. : https://storj.io/
  // Submitted by Philip Hutchins <hostmaster@storj.io>
  storj.farm
  
  // Studenten Net Twente : http://www.snt.utwente.nl/
  // Submitted by Silke Hofstra <syscom@snt.utwente.nl>
  utwente.io
  
  // Sub 6 Limited: http://www.sub6.com
  // Submitted by Dan Miller <dm@sub6.com>
  temp-dns.com
  
  // Swisscom Application Cloud: https://developer.swisscom.com
  // Submitted by Matthias.Winzeler <matthias.winzeler@swisscom.com>
  applicationcloud.io
  scapp.io
  
  // Synology, Inc. : https://www.synology.com/
  // Submitted by Rony Weng <ronyweng@synology.com>
  diskstation.me
  dscloud.biz
  dscloud.me
  dscloud.mobi
  dsmynas.com
  dsmynas.net
  dsmynas.org
  familyds.com
  familyds.net
  familyds.org
  i234.me
  myds.me
  synology.me
  vpnplus.to
  
  // TAIFUN Software AG : http://taifun-software.de
  // Submitted by Bjoern Henke <dev-server@taifun-software.de>
  taifun-dns.de
  
  // TASK geographical domains (www.task.gda.pl/uslugi/dns)
  gda.pl
  gdansk.pl
  gdynia.pl
  med.pl
  sopot.pl
  
  // Telebit : https://telebit.cloud
  // Submitted by AJ ONeal <aj@telebit.cloud>
  telebit.app
  telebit.io
  *.telebit.xyz
  
  // The Gwiddle Foundation : https://gwiddlefoundation.org.uk
  // Submitted by Joshua Bayfield <joshua.bayfield@gwiddlefoundation.org.uk>
  gwiddle.co.uk
  
  // Thingdust AG : https://thingdust.com/
  // Submitted by Adrian Imboden <adi@thingdust.com>
  cust.dev.thingdust.io
  cust.disrec.thingdust.io
  cust.prod.thingdust.io
  cust.testing.thingdust.io
  
  // TownNews.com : http://www.townnews.com
  // Submitted by Dustin Ward <dward@townnews.com>
  bloxcms.com
  townnews-staging.com
  
  // TrafficPlex GmbH : https://www.trafficplex.de/
  // Submitted by Phillipp Röll <phillipp.roell@trafficplex.de>
  12hp.at
  2ix.at
  4lima.at
  lima-city.at
  12hp.ch
  2ix.ch
  4lima.ch
  lima-city.ch
  trafficplex.cloud
  de.cool
  12hp.de
  2ix.de
  4lima.de
  lima-city.de
  1337.pictures
  clan.rip
  lima-city.rocks
  webspace.rocks
  lima.zone
  
  // TransIP : https://www.transip.nl
  // Submitted by Rory Breuk <rbreuk@transip.nl>
  *.transurl.be
  *.transurl.eu
  *.transurl.nl
  
  // TuxFamily : http://tuxfamily.org
  // Submitted by TuxFamily administrators <adm@staff.tuxfamily.org>
  tuxfamily.org
  
  // TwoDNS : https://www.twodns.de/
  // Submitted by TwoDNS-Support <support@two-dns.de>
  dd-dns.de
  diskstation.eu
  diskstation.org
  dray-dns.de
  draydns.de
  dyn-vpn.de
  dynvpn.de
  mein-vigor.de
  my-vigor.de
  my-wan.de
  syno-ds.de
  synology-diskstation.de
  synology-ds.de
  
  // Uberspace : https://uberspace.de
  // Submitted by Moritz Werner <mwerner@jonaspasche.com>
  uber.space
  *.uberspace.de
  
  // UDR Limited : http://www.udr.hk.com
  // Submitted by registry <hostmaster@udr.hk.com>
  hk.com
  hk.org
  ltd.hk
  inc.hk
  
  // United Gameserver GmbH : https://united-gameserver.de
  // Submitted by Stefan Schwarz <sysadm@united-gameserver.de>
  virtualuser.de
  virtual-user.de
  
  // .US
  // Submitted by Ed Moore <Ed.Moore@lib.de.us>
  lib.de.us
  
  // VeryPositive SIA : http://very.lv
  // Submitted by Danko Aleksejevs <danko@very.lv>
  2038.io
  
  // Viprinet Europe GmbH : http://www.viprinet.com
  // Submitted by Simon Kissel <hostmaster@viprinet.com>
  router.management
  
  // Virtual-Info : https://www.virtual-info.info/
  // Submitted by Adnan RIHAN <hostmaster@v-info.info>
  v-info.info
  
  // WeDeploy by Liferay, Inc. : https://www.wedeploy.com
  // Submitted by Henrique Vicente <security@wedeploy.com>
  wedeploy.io
  wedeploy.me
  wedeploy.sh
  
  // Western Digital Technologies, Inc : https://www.wdc.com
  // Submitted by Jung Jin <jungseok.jin@wdc.com>
  remotewd.com
  
  // Wikimedia Labs : https://wikitech.wikimedia.org
  // Submitted by Yuvi Panda <yuvipanda@wikimedia.org>
  wmflabs.org
  
  // XenonCloud GbR: https://xenoncloud.net
  // Submitted by Julian Uphoff <publicsuffixlist@xenoncloud.net>
  half.host
  
  // XnBay Technology : http://www.xnbay.com/
  // Submitted by XnBay Developer <developer.xncloud@gmail.com>
  xnbay.com
  u2.xnbay.com
  u2-local.xnbay.com
  
  // XS4ALL Internet bv : https://www.xs4all.nl/
  // Submitted by Daniel Mostertman <unixbeheer+publicsuffix@xs4all.net>
  cistron.nl
  demon.nl
  xs4all.space
  
  // YesCourse Pty Ltd : https://yescourse.com
  // Submitted by Atul Bhouraskar <atul@yescourse.com>
  official.academy
  
  // Yola : https://www.yola.com/
  // Submitted by Stefano Rivera <stefano@yola.com>
  yolasite.com
  
  // Yombo : https://yombo.net
  // Submitted by Mitch Schwenk <mitch@yombo.net>
  ybo.faith
  yombo.me
  homelink.one
  ybo.party
  ybo.review
  ybo.science
  ybo.trade
  
  // Yunohost : https://yunohost.org
  // Submitted by Valentin Grimaud <security@yunohost.org>
  nohost.me
  noho.st
  
  // ZaNiC : http://www.za.net/
  // Submitted by registry <hostmaster@nic.za.net>
  za.net
  za.org
  
  // Zeit, Inc. : https://zeit.domains/
  // Submitted by Olli Vanhoja <olli@zeit.co>
  now.sh
  
  // Zine EOOD : https://zine.bg/
  // Submitted by Martin Angelov <martin@zine.bg>
  bss.design
  
  // Zone.id : https://zone.id/
  // Submitted by Su Hendro <admin@zone.id>
  zone.id
  
  // ===END PRIVATE DOMAINS===
  END_BUILTIN_DATA
  1;
IO_SOCKET_SSL_PUBLICSUFFIX

$fatpacked{"IO/Socket/SSL/Utils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IO_SOCKET_SSL_UTILS';
  
  package IO::Socket::SSL::Utils;
  use strict;
  use warnings;
  use Carp 'croak';
  use Net::SSLeay;
  
  # old versions of Exporter do not export 'import' yet
  require Exporter;
  *import = \&Exporter::import;
  
  our $VERSION = '2.014';
  our @EXPORT = qw(
      PEM_file2cert PEM_string2cert PEM_cert2file PEM_cert2string
      PEM_file2key PEM_string2key PEM_key2file PEM_key2string
      KEY_free CERT_free
      KEY_create_rsa CERT_asHash CERT_create
  );
  
  sub PEM_file2cert {
      my $file = shift;
      my $bio = Net::SSLeay::BIO_new_file($file,'r') or
  	croak "cannot read $file: $!";
      my $cert = Net::SSLeay::PEM_read_bio_X509($bio);
      Net::SSLeay::BIO_free($bio);
      $cert or croak "cannot parse $file as PEM X509 cert: ".
  	Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
      return $cert;
  }
  
  sub PEM_cert2file {
      my ($cert,$file) = @_;
      my $string = Net::SSLeay::PEM_get_string_X509($cert)
  	or croak("cannot get string from cert");
      open( my $fh,'>',$file ) or croak("cannot write $file: $!");
      print $fh $string;
  }
  
  sub PEM_string2cert {
      my $string = shift;
      my $bio = Net::SSLeay::BIO_new( Net::SSLeay::BIO_s_mem());
      Net::SSLeay::BIO_write($bio,$string);
      my $cert = Net::SSLeay::PEM_read_bio_X509($bio);
      Net::SSLeay::BIO_free($bio);
      $cert or croak "cannot parse string as PEM X509 cert: ".
  	Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
      return $cert;
  }
  
  sub PEM_cert2string {
      my $cert = shift;
      return Net::SSLeay::PEM_get_string_X509($cert)
  	|| croak("cannot get string from cert");
  }
  
  sub PEM_file2key {
      my $file = shift;
      my $bio = Net::SSLeay::BIO_new_file($file,'r') or
  	croak "cannot read $file: $!";
      my $key = Net::SSLeay::PEM_read_bio_PrivateKey($bio);
      Net::SSLeay::BIO_free($bio);
      $key or croak "cannot parse $file as PEM private key: ".
  	Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
      return $key;
  }
  
  sub PEM_key2file {
      my ($key,$file) = @_;
      my $string = Net::SSLeay::PEM_get_string_PrivateKey($key)
  	or croak("cannot get string from key");
      open( my $fh,'>',$file ) or croak("cannot write $file: $!");
      print $fh $string;
  }
  
  sub PEM_string2key {
      my $string = shift;
      my $bio = Net::SSLeay::BIO_new( Net::SSLeay::BIO_s_mem());
      Net::SSLeay::BIO_write($bio,$string);
      my $key = Net::SSLeay::PEM_read_bio_PrivateKey($bio);
      Net::SSLeay::BIO_free($bio);
      $key or croak "cannot parse string as PEM private key: ".
  	Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
      return $key;
  }
  
  sub PEM_key2string {
      my $key = shift;
      return Net::SSLeay::PEM_get_string_PrivateKey($key)
  	|| croak("cannot get string from key");
  }
  
  sub CERT_free {
      my $cert = shift or return;
      Net::SSLeay::X509_free($cert);
  }
  
  sub KEY_free {
      my $key = shift or return;
      Net::SSLeay::EVP_PKEY_free($key);
  }
  
  sub KEY_create_rsa {
      my $bits = shift || 2048;
      my $key = Net::SSLeay::EVP_PKEY_new();
      my $rsa = Net::SSLeay::RSA_generate_key($bits, 0x10001); # 0x10001 = RSA_F4
      Net::SSLeay::EVP_PKEY_assign_RSA($key,$rsa);
      return $key;
  }
  
  if (defined &Net::SSLeay::EC_KEY_generate_key) {
      push @EXPORT,'KEY_create_ec';
      *KEY_create_ec = sub {
  	my $curve = shift || 'prime256v1';
  	my $key = Net::SSLeay::EVP_PKEY_new();
  	my $ec = Net::SSLeay::EC_KEY_generate_key($curve);
  	Net::SSLeay::EVP_PKEY_assign_EC_KEY($key,$ec);
  	return $key;
      }
  }
  
  # extract information from cert
  my %gen2i = qw( OTHERNAME 0 EMAIL 1 DNS 2 X400 3 DIRNAME 4 EDIPARTY 5 URI 6 IP 7 RID 8 );
  my %i2gen = reverse %gen2i;
  sub CERT_asHash {
      my $cert = shift;
      my $digest_name = shift || 'sha256';
  
      my %hash = (
  	version => Net::SSLeay::X509_get_version($cert),
  	not_before => _asn1t2t(Net::SSLeay::X509_get_notBefore($cert)),
  	not_after => _asn1t2t(Net::SSLeay::X509_get_notAfter($cert)),
  	serial => Net::SSLeay::P_ASN1_INTEGER_get_dec(
  	    Net::SSLeay::X509_get_serialNumber($cert)),
  	signature_alg => Net::SSLeay::OBJ_obj2txt (
  	    Net::SSLeay::P_X509_get_signature_alg($cert)),
  	crl_uri  => [ Net::SSLeay::P_X509_get_crl_distribution_points($cert) ],
  	keyusage => [ Net::SSLeay::P_X509_get_key_usage($cert) ],
  	extkeyusage => {
  	    oid => [ Net::SSLeay::P_X509_get_ext_key_usage($cert,0) ],
  	    nid => [ Net::SSLeay::P_X509_get_ext_key_usage($cert,1) ],
  	    sn  => [ Net::SSLeay::P_X509_get_ext_key_usage($cert,2) ],
  	    ln  => [ Net::SSLeay::P_X509_get_ext_key_usage($cert,3) ],
  	},
  	"pubkey_digest_$digest_name" => Net::SSLeay::X509_pubkey_digest(
  	    $cert,_digest($digest_name)),
  	"x509_digest_$digest_name" => Net::SSLeay::X509_digest(
  	    $cert,_digest($digest_name)),
  	"fingerprint_$digest_name" => Net::SSLeay::X509_get_fingerprint(
  	    $cert,$digest_name),
      );
  
      my $subj = Net::SSLeay::X509_get_subject_name($cert);
      my %subj;
      for ( 0..Net::SSLeay::X509_NAME_entry_count($subj)-1 ) {
  	my $e = Net::SSLeay::X509_NAME_get_entry($subj,$_);
  	my $o = Net::SSLeay::X509_NAME_ENTRY_get_object($e);
  	$subj{ Net::SSLeay::OBJ_obj2txt($o) } =
  	    Net::SSLeay::P_ASN1_STRING_get(
  		Net::SSLeay::X509_NAME_ENTRY_get_data($e));
      }
      $hash{subject} = \%subj;
  
      if ( my @names = Net::SSLeay::X509_get_subjectAltNames($cert) ) {
  	my $alt = $hash{subjectAltNames} = [];
  	while (my ($t,$v) = splice(@names,0,2)) {
  	    $t = $i2gen{$t} || die "unknown type $t in subjectAltName";
  	    if ( $t eq 'IP' ) {
  		if (length($v) == 4) {
  		    $v = join('.',unpack("CCCC",$v));
  		} elsif ( length($v) == 16 ) {
  		    my @v = unpack("nnnnnnnn",$v);
  		    my ($best0,$last0);
  		    for(my $i=0;$i<@v;$i++) {
  			if ($v[$i] == 0) {
  			    if ($last0) {
  				$last0->[1] = $i;
  				$last0->[2]++;
  				$best0 = $last0 if ++$last0->[2]>$best0->[2];
  			    } else {
  				$last0 = [ $i,$i,0 ];
  				$best0 ||= $last0;
  			    }
  			} else {
  			    $last0 = undef;
  			}
  		    }
  		    if ($best0) {
  			$v = '';
  			$v .= join(':', map { sprintf( "%x",$_) } @v[0..$best0->[0]-1]) if $best0->[0]>0;
  			$v .= '::';
  			$v .= join(':', map { sprintf( "%x",$_) } @v[$best0->[1]+1..$#v]) if $best0->[1]<$#v;
  		    } else {
  			$v = join(':', map { sprintf( "%x",$_) } @v);
  		    }
  		}
  	    }
  	    push @$alt,[$t,$v]
  	}
      }
  
      my $issuer = Net::SSLeay::X509_get_issuer_name($cert);
      my %issuer;
      for ( 0..Net::SSLeay::X509_NAME_entry_count($issuer)-1 ) {
  	my $e = Net::SSLeay::X509_NAME_get_entry($issuer,$_);
  	my $o = Net::SSLeay::X509_NAME_ENTRY_get_object($e);
  	$issuer{ Net::SSLeay::OBJ_obj2txt($o) } =
  	    Net::SSLeay::P_ASN1_STRING_get(
  		Net::SSLeay::X509_NAME_ENTRY_get_data($e));
      }
      $hash{issuer} = \%issuer;
  
      my @ext;
      for( 0..Net::SSLeay::X509_get_ext_count($cert)-1 ) {
  	my $e = Net::SSLeay::X509_get_ext($cert,$_);
  	my $o = Net::SSLeay::X509_EXTENSION_get_object($e);
  	my $nid = Net::SSLeay::OBJ_obj2nid($o);
  	push @ext, {
  	    oid => Net::SSLeay::OBJ_obj2txt($o),
  	    nid => ( $nid > 0 ) ? $nid : undef,
  	    sn  => ( $nid > 0 ) ? Net::SSLeay::OBJ_nid2sn($nid) : undef,
  	    critical => Net::SSLeay::X509_EXTENSION_get_critical($e),
  	    data => Net::SSLeay::X509V3_EXT_print($e),
  	}
      }
      $hash{ext} = \@ext;
  
      if ( defined(&Net::SSLeay::P_X509_get_ocsp_uri)) {
  	$hash{ocsp_uri} = [ Net::SSLeay::P_X509_get_ocsp_uri($cert) ];
      } else {
  	$hash{ocsp_uri} = [];
  	for( @ext ) {
  	    $_->{sn} or next;
  	    $_->{sn} eq 'authorityInfoAccess' or next;
  	    push @{ $hash{ocsp_uri}}, $_->{data} =~m{\bOCSP - URI:(\S+)}g;
  	}
      }
  
      return \%hash;
  }
  
  sub CERT_create {
      my %args = @_%2 ? %{ shift() } :  @_;
  
      my $cert = Net::SSLeay::X509_new();
      my $digest_name = delete $args{digest} || 'sha256';
  
      Net::SSLeay::ASN1_INTEGER_set(
  	Net::SSLeay::X509_get_serialNumber($cert),
  	delete $args{serial} || rand(2**32),
      );
  
      # version default to 2 (V3)
      Net::SSLeay::X509_set_version($cert,
  	delete $args{version} || 2 );
  
      # not_before default to now
      Net::SSLeay::ASN1_TIME_set(
  	Net::SSLeay::X509_get_notBefore($cert),
  	delete $args{not_before} || time()
      );
  
      # not_after default to now+365 days
      Net::SSLeay::ASN1_TIME_set(
  	Net::SSLeay::X509_get_notAfter($cert),
  	delete $args{not_after} || time() + 365*86400
      );
  
      # set subject
      my $subj_e = Net::SSLeay::X509_get_subject_name($cert);
      my $subj = delete $args{subject} || {
  	organizationName => 'IO::Socket::SSL',
  	commonName => 'IO::Socket::SSL Test'
      };
      while ( my ($k,$v) = each %$subj ) {
  	# Not everything we get is nice - try with MBSTRING_UTF8 first and if it
  	# fails try V_ASN1_T61STRING and finally V_ASN1_OCTET_STRING
  	Net::SSLeay::X509_NAME_add_entry_by_txt($subj_e,$k,0x1000,$v,-1,0)
  	    or Net::SSLeay::X509_NAME_add_entry_by_txt($subj_e,$k,20,$v,-1,0)
  	    or Net::SSLeay::X509_NAME_add_entry_by_txt($subj_e,$k,4,$v,-1,0)
  	    or croak("failed to add entry for $k - ".
  	    Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error()));
      }
  
      my @ext = (
  	&Net::SSLeay::NID_subject_key_identifier => 'hash',
  	&Net::SSLeay::NID_authority_key_identifier => 'keyid',
      );
      if ( my $altsubj = delete $args{subjectAltNames} ) {
  	push @ext,
  	    &Net::SSLeay::NID_subject_alt_name =>
  	    join(',', map { "$_->[0]:$_->[1]" } @$altsubj)
      }
  
      my $key = delete $args{key} || KEY_create_rsa();
      Net::SSLeay::X509_set_pubkey($cert,$key);
  
      my $is = delete $args{issuer};
      my $issuer_cert = delete $args{issuer_cert} || $is && $is->[0] || $cert;
      my $issuer_key  = delete $args{issuer_key}  || $is && $is->[1] || $key;
  
      my %purpose;
      if (my $p = delete $args{purpose}) {
  	if (!ref($p)) {
  	    $purpose{lc($2)} = (!$1 || $1 eq '+') ? 1:0
  		while $p =~m{([+-]?)(\w+)}g;
  	} elsif (ref($p) eq 'ARRAY') {
  	    for(@$p) {
  		m{^([+-]?)(\w+)$} or die "invalid entry in purpose: $_";
  		$purpose{lc($2)} = (!$1 || $1 eq '+') ? 1:0
  	    }
  	} else {
  	    while( my ($k,$v) = each %$p) {
  		$purpose{lc($k)} = ($v && $v ne '-')?1:0;
  	    }
  	}
      }
      if (delete $args{CA}) {
  	# add defaults for CA
  	%purpose = (
  	    ca => 1, sslca => 1, emailca => 1, objca => 1,
  	    %purpose
  	);
      }
      if (!%purpose) {
  	%purpose = (server => 1, client => 1);
      }
  
      my (%key_usage,%ext_key_usage,%cert_type,%basic_constraints);
  
      my %dS = ( digitalSignature => \%key_usage );
      my %kE = ( keyEncipherment => \%key_usage );
      my %CA = ( 'CA:TRUE' => \%basic_constraints, %dS, keyCertSign => \%key_usage );
      my @disable;
      for(
  	[ client  => { %dS, %kE, clientAuth => \%ext_key_usage, client  => \%cert_type } ],
  	[ server  => { %dS, %kE, serverAuth => \%ext_key_usage, server  => \%cert_type } ],
  	[ email   => { %dS, %kE, emailProtection => \%ext_key_usage, email => \%cert_type } ],
  	[ objsign => { %dS, %kE, codeSigning => \%ext_key_usage, objsign => \%cert_type } ],
  
  	[ CA      => { %CA }],
  	[ sslCA   => { %CA, sslCA => \%cert_type }],
  	[ emailCA => { %CA, emailCA => \%cert_type }],
  	[ objCA   => { %CA, objCA => \%cert_type }],
  
  	[ emailProtection  => { %dS, %kE, emailProtection => \%ext_key_usage, email => \%cert_type } ],
  	[ codeSigning      => { %dS, %kE, codeSigning => \%ext_key_usage, objsign => \%cert_type } ],
  
  	[ timeStamping     => { timeStamping => \%ext_key_usage } ],
  	[ digitalSignature => { digitalSignature => \%key_usage } ],
  	[ nonRepudiation   => { nonRepudiation => \%key_usage } ],
  	[ keyEncipherment  => { keyEncipherment => \%key_usage } ],
  	[ dataEncipherment => { dataEncipherment => \%key_usage } ],
  	[ keyAgreement     => { keyAgreement => \%key_usage } ],
  	[ keyCertSign      => { keyCertSign => \%key_usage } ],
  	[ cRLSign          => { cRLSign => \%key_usage } ],
  	[ encipherOnly     => { encipherOnly => \%key_usage } ],
  	[ decipherOnly     => { decipherOnly => \%key_usage } ],
  	[ clientAuth       => { clientAuth   => \%ext_key_usage } ],
  	[ serverAuth       => { serverAuth   => \%ext_key_usage } ],
      ) {
  	exists $purpose{lc($_->[0])} or next;
  	if (delete $purpose{lc($_->[0])}) {
  	    while (my($k,$h) = each %{$_->[1]}) {
  		$h->{$k} = 1;
  	    }
  	} else {
  	    push @disable, $_->[1];
  	}
      }
      die "unknown purpose ".join(",",keys %purpose) if %purpose;
      for(@disable) {
  	while (my($k,$h) = each %$_) {
  	    delete $h->{$k};
  	}
      }
  
      if (%basic_constraints) {
  	push @ext,&Net::SSLeay::NID_basic_constraints,
  	    => join(",",'critical', sort keys %basic_constraints);
      } else {
  	push @ext, &Net::SSLeay::NID_basic_constraints => 'critical,CA:FALSE';
      }
      push @ext,&Net::SSLeay::NID_key_usage
  	=> join(",",'critical', sort keys %key_usage) if %key_usage;
      push @ext,&Net::SSLeay::NID_netscape_cert_type
  	=> join(",",sort keys %cert_type) if %cert_type;
      push @ext,&Net::SSLeay::NID_ext_key_usage
  	=> join(",",sort keys %ext_key_usage) if %ext_key_usage;
      Net::SSLeay::P_X509_add_extensions($cert, $issuer_cert, @ext);
  
      my %have_ext;
      for(my $i=0;$i<@ext;$i+=2) {
  	$have_ext{ $ext[$i] }++
      }
      for my $ext (@{ $args{ext} || [] }) {
  	my $nid = $ext->{nid}
  	    || $ext->{sn} && Net::SSLeay::OBJ_sn2nid($ext->{sn})
  	    || croak "cannot determine NID of extension";
  	$have_ext{$nid} and next;
  	my $val = $ext->{data};
  	if ($nid == 177) {
  	    # authorityInfoAccess:
  	    # OpenSSL i2v does not output the same way as expected by i2v :(
  	    for (split(/\n/,$val)) {
  		s{ - }{;}; # "OCSP - URI:..." -> "OCSP;URI:..."
  		$_ = "critical,$_" if $ext->{critical};
  		Net::SSLeay::P_X509_add_extensions($cert,$issuer_cert,$nid,$_);
  	    }
  	} else {
  	    $val = "critical,$val" if $ext->{critical};
  	    Net::SSLeay::P_X509_add_extensions($cert, $issuer_cert, $nid, $val);
  	}
      }
  
      Net::SSLeay::X509_set_issuer_name($cert,
  	Net::SSLeay::X509_get_subject_name($issuer_cert));
      Net::SSLeay::X509_sign($cert,$issuer_key,_digest($digest_name));
  
      return ($cert,$key);
  }
  
  
  
  if ( defined &Net::SSLeay::ASN1_TIME_timet ) {
      *_asn1t2t = \&Net::SSLeay::ASN1_TIME_timet
  } else {
      require Time::Local;
      my %mon2i = qw(
  	Jan 0 Feb 1 Mar 2 Apr 3 May 4 Jun 5
  	Jul 6 Aug 7 Sep 8 Oct 9 Nov 10 Dec 11
      );
      *_asn1t2t = sub {
  	my $t = Net::SSLeay::P_ASN1_TIME_put2string( shift );
  	my ($mon,$d,$h,$m,$s,$y,$tz) = split(/[\s:]+/,$t);
  	defined( $mon = $mon2i{$mon} ) or die "invalid month in $t";
  	$tz ||= $y =~s{^(\d+)([A-Z]\S*)}{$1} && $2;
  	if ( ! $tz ) {
  	    return Time::Local::timelocal($s,$m,$h,$d,$mon,$y)
  	} elsif ( $tz eq 'GMT' ) {
  	    return Time::Local::timegm($s,$m,$h,$d,$mon,$y)
  	} else {
  	    die "unexpected TZ $tz from ASN1_TIME_print";
  	}
      }
  }
  
  {
      my %digest;
      sub _digest {
  	my $digest_name = shift;
  	return $digest{$digest_name} ||= do {
  	    Net::SSLeay::SSLeay_add_ssl_algorithms();
  	    Net::SSLeay::EVP_get_digestbyname($digest_name)
  		or die "Digest algorithm $digest_name is not available";
  	};
      }
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Socket::SSL::Utils -- loading, storing, creating certificates and keys
  
  =head1 SYNOPSIS
  
      use IO::Socket::SSL::Utils;
      my $cert = PEM_file2cert('cert.pem');  # load certificate from file
      my $string = PEM_cert2string($cert);   # convert certificate to PEM string
      CERT_free($cert);                      # free memory within OpenSSL
  
      my $key = KEY_create_rsa(2048);        # create new 2048-bit RSA key
      PEM_string2file($key,"key.pem");       # and write it to file
      KEY_free($key);                        # free memory within OpenSSL
  
  
  =head1 DESCRIPTION
  
  This module provides various utility functions to work with certificates and
  private keys, shielding some of the complexity of the underlying Net::SSLeay and
  OpenSSL.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item *
  
  Functions converting between string or file and certificates and keys.
  They croak if the operation cannot be completed.
  
  =over 8
  
  =item PEM_file2cert(file) -> cert
  
  =item PEM_cert2file(cert,file)
  
  =item PEM_string2cert(string) -> cert
  
  =item PEM_cert2string(cert) -> string
  
  =item PEM_file2key(file) -> key
  
  =item PEM_key2file(key,file)
  
  =item PEM_string2key(string) -> key
  
  =item PEM_key2string(key) -> string
  
  =back
  
  =item *
  
  Functions for cleaning up.
  Each loaded or created cert and key must be freed to not leak memory.
  
  =over 8
  
  =item CERT_free(cert)
  
  =item KEY_free(key)
  
  =back
  
  =item * KEY_create_rsa(bits) -> key
  
  Creates an RSA key pair, bits defaults to 2048.
  
  =item * KEY_create_ec(curve) -> key
  
  Creates an EC key, curve defaults to C<prime256v1>.
  
  =item * CERT_asHash(cert,[digest_algo]) -> hash
  
  Extracts the information from the certificate into a hash and uses the given
  digest_algo (default: SHA-256) to determine digest of pubkey and cert.
  The resulting hash contains:
  
  =over 8
  
  =item subject
  
  Hash with the parts of the subject, e.g. commonName, countryName,
  organizationName, stateOrProvinceName, localityName.
  
  =item subjectAltNames
  
  Array with list of alternative names. Each entry in the list is of
  C<[type,value]>, where C<type> can be OTHERNAME, EMAIL, DNS, X400, DIRNAME,
  EDIPARTY, URI, IP or RID.
  
  =item issuer
  
  Hash with the parts of the issuer, e.g. commonName, countryName,
  organizationName, stateOrProvinceName, localityName.
  
  =item not_before, not_after
  
  The time frame, where the certificate is valid, as time_t, e.g. can be converted
  with localtime or similar functions.
  
  =item serial
  
  The serial number
  
  =item crl_uri
  
  List of URIs for CRL distribution.
  
  =item ocsp_uri
  
  List of URIs for revocation checking using OCSP.
  
  =item keyusage
  
  List of keyUsage information in the certificate.
  
  =item extkeyusage
  
  List of extended key usage information from the certificate. Each entry in
  this list consists of a hash with oid, nid, ln and sn.
  
  =item pubkey_digest_xxx
  
  Binary digest of the pubkey using the given digest algorithm, e.g.
  pubkey_digest_sha256 if (the default) SHA-256 was used.
  
  =item x509_digest_xxx
  
  Binary digest of the X.509 certificate using the given digest algorithm, e.g.
  x509_digest_sha256 if (the default) SHA-256 was used.
  
  =item fingerprint_xxx
  
  Fingerprint of the certificate using the given digest algorithm, e.g.
  fingerprint_sha256 if (the default) SHA-256 was used. Contrary to digest_* this
  is an ASCII string with a list if hexadecimal numbers, e.g.
  "73:59:75:5C:6D...".
  
  =item signature_alg
  
  Algorithm used to sign certificate, e.g. C<sha256WithRSAEncryption>.
  
  =item ext
  
  List of extensions.
  Each entry in the list is a hash with oid, nid, sn, critical flag (boolean) and
  data (string representation given by X509V3_EXT_print).
  
  =item version
  
  Certificate version, usually 2 (x509v3)
  
  =back
  
  =item * CERT_create(hash) -> (cert,key)
  
  Creates a certificate based on the given hash.
  If the issuer is not specified the certificate will be self-signed.
  The following keys can be given:
  
  =over 8
  
  =item subject
  
  Hash with the parts of the subject, e.g. commonName, countryName, ... as
  described in C<CERT_asHash>.
  Default points to IO::Socket::SSL.
  
  =item not_before
  
  A time_t value when the certificate starts to be valid. Defaults to current
  time.
  
  =item not_after
  
  A time_t value when the certificate ends to be valid. Defaults to current
  time plus one 365 days.
  
  =item serial
  
  The serial number. If not given a random number will be used.
  
  =item version
  
  The version of the certificate, default 2 (x509v3).
  
  =item CA true|false
  
  If true declare certificate as CA, defaults to false.
  
  =item purpose string|array|hash
  
  Set the purpose of the certificate.
  The different purposes can be given as a string separated by non-word character,
  as array or hash. With string or array each purpose can be prefixed with '+'
  (enable) or '-' (disable) and same can be done with the value when given as a
  hash. By default enabling the purpose is assumed.
  
  If the CA option is given and true the defaults "ca,sslca,emailca,objca" are
  assumed, but can be overridden with explicit purpose.
  If the CA option is given and false the defaults "server,client" are assumed.
  If no CA option and no purpose is given it defaults to "server,client".
  
  Purpose affects basicConstraints, keyUsage, extKeyUsage and netscapeCertType.
  The following purposes are defined (case is not important):
  
      client
      server
      email
      objsign
  
      CA
      sslCA
      emailCA
      objCA
  
      emailProtection
      codeSigning
      timeStamping
  
      digitalSignature
      nonRepudiation
      keyEncipherment
      dataEncipherment
      keyAgreement
      keyCertSign
      cRLSign
      encipherOnly
      decipherOnly
  
  Examples:
  
       # root-CA for SSL certificates
       purpose => 'sslCA'   # or CA => 1
  
       # server certificate and CA (typically self-signed)
       purpose => 'sslCA,server'
  
       # client certificate
       purpose => 'client',
  
  
  =item ext [{ sn => .., data => ... }, ... ]
  
  List of extensions. The type of the extension can be specified as name with
  C<sn> or as NID with C<nid> and the data with C<data>. These data must be in the
  same syntax as expected within openssl.cnf, e.g. something like
  C<OCSP;URI=http://...>. Additionally the critical flag can be set with
  C<critical => 1>.
  
  =item key key
  
  use given key as key for certificate, otherwise a new one will be generated and
  returned
  
  =item issuer_cert cert
  
  set issuer for new certificate
  
  =item issuer_key key
  
  sign new certificate with given key
  
  =item issuer [ cert, key ]
  
  Instead of giving issuer_key and issuer_cert as separate arguments they can be
  given both together.
  
  =item digest algorithm
  
  specify the algorithm used to sign the certificate, default SHA-256.
  
  =back
  
  =back
  
  =head1 AUTHOR
  
  Steffen Ullrich
IO_SOCKET_SSL_UTILS

$fatpacked{"JSON/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_TINY';
  package JSON::Tiny;
  
  # Minimalistic JSON. Adapted from Mojo::JSON. (c)2012-2015 David Oswald
  # License: Artistic 2.0 license.
  # http://www.perlfoundation.org/artistic_license_2_0
  
  use strict;
  use warnings;
  use Carp 'croak';
  use Exporter 'import';
  use Scalar::Util 'blessed';
  use Encode ();
  
  our $VERSION = '0.56';
  our @EXPORT_OK = qw(decode_json encode_json false from_json j to_json true);
  
  # Literal names
  # Users may override Booleans with literal 0 or 1 if desired.
  our($FALSE, $TRUE) = map { bless \(my $dummy = $_), 'JSON::Tiny::_Bool' } 0, 1;
  
  # Escaped special character map with u2028 and u2029
  my %ESCAPE = (
    '"'     => '"',
    '\\'    => '\\',
    '/'     => '/',
    'b'     => "\x08",
    'f'     => "\x0c",
    'n'     => "\x0a",
    'r'     => "\x0d",
    't'     => "\x09",
    'u2028' => "\x{2028}",
    'u2029' => "\x{2029}"
  );
  my %REVERSE = map { $ESCAPE{$_} => "\\$_" } keys %ESCAPE;
  
  for(0x00 .. 0x1f) {
    my $packed = pack 'C', $_;
    $REVERSE{$packed} = sprintf '\u%.4X', $_ unless defined $REVERSE{$packed};
  }
  
  sub decode_json {
    my $err = _decode(\my $value, shift);
    return defined $err ? croak $err : $value;
  }
  
  sub encode_json { Encode::encode 'UTF-8', _encode_value(shift) }
  
  sub false () {$FALSE}  ## no critic (prototypes)
  
  sub from_json {
    my $err = _decode(\my $value, shift, 1);
    return defined $err ? croak $err : $value;
  }
  
  sub j {
    return encode_json $_[0] if ref $_[0] eq 'ARRAY' || ref $_[0] eq 'HASH';
    return decode_json $_[0];
  }
  
  sub to_json { _encode_value(shift) }
  
  sub true () {$TRUE} ## no critic (prototypes)
  
  sub _decode {
    my $valueref = shift;
  
    eval {
  
      # Missing input
      die "Missing or empty input\n" unless length( local $_ = shift );
  
      # UTF-8
      $_ = eval { Encode::decode('UTF-8', $_, 1) } unless shift;
      die "Input is not UTF-8 encoded\n" unless defined $_;
  
      # Value
      $$valueref = _decode_value();
  
      # Leftover data
      return m/\G[\x20\x09\x0a\x0d]*\z/gc || _throw('Unexpected data');
    } ? return undef : chomp $@;
  
    return $@;
  }
  
  sub _decode_array {
    my @array;
    until (m/\G[\x20\x09\x0a\x0d]*\]/gc) {
  
      # Value
      push @array, _decode_value();
  
      # Separator
      redo if m/\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if m/\G[\x20\x09\x0a\x0d]*\]/gc;
  
      # Invalid character
      _throw('Expected comma or right square bracket while parsing array');
    }
  
    return \@array;
  }
  
  sub _decode_object {
    my %hash;
    until (m/\G[\x20\x09\x0a\x0d]*\}/gc) {
  
      # Quote
      m/\G[\x20\x09\x0a\x0d]*"/gc
        or _throw('Expected string while parsing object');
  
      # Key
      my $key = _decode_string();
  
      # Colon
      m/\G[\x20\x09\x0a\x0d]*:/gc
        or _throw('Expected colon while parsing object');
  
      # Value
      $hash{$key} = _decode_value();
  
      # Separator
      redo if m/\G[\x20\x09\x0a\x0d]*,/gc;
  
      # End
      last if m/\G[\x20\x09\x0a\x0d]*\}/gc;
  
      # Invalid character
      _throw('Expected comma or right curly bracket while parsing object');
    }
  
    return \%hash;
  }
  
  sub _decode_string {
    my $pos = pos;
    
    # Extract string with escaped characters
    m!\G((?:(?:[^\x00-\x1f\\"]|\\(?:["\\/bfnrt]|u[0-9a-fA-F]{4})){0,32766})*)!gc; # segfault on 5.8.x in t/20-mojo-json.t
    my $str = $1;
  
    # Invalid character
    unless (m/\G"/gc) {
      _throw('Unexpected character or invalid escape while parsing string')
        if m/\G[\x00-\x1f\\]/;
      _throw('Unterminated string');
    }
  
    # Unescape popular characters
    if (index($str, '\\u') < 0) {
      $str =~ s!\\(["\\/bfnrt])!$ESCAPE{$1}!gs;
      return $str;
    }
  
    # Unescape everything else
    my $buffer = '';
    while ($str =~ m/\G([^\\]*)\\(?:([^u])|u(.{4}))/gc) {
      $buffer .= $1;
  
      # Popular character
      if ($2) { $buffer .= $ESCAPE{$2} }
  
      # Escaped
      else {
        my $ord = hex $3;
  
        # Surrogate pair
        if (($ord & 0xf800) == 0xd800) {
  
          # High surrogate
          ($ord & 0xfc00) == 0xd800
            or pos($_) = $pos + pos($str), _throw('Missing high-surrogate');
  
          # Low surrogate
          $str =~ m/\G\\u([Dd][C-Fc-f]..)/gc
            or pos($_) = $pos + pos($str), _throw('Missing low-surrogate');
  
          $ord = 0x10000 + ($ord - 0xd800) * 0x400 + (hex($1) - 0xdc00);
        }
  
        # Character
        $buffer .= pack 'U', $ord;
      }
    }
  
    # The rest
    return $buffer . substr $str, pos $str, length $str;
  }
  
  sub _decode_value {
  
    # Leading whitespace
    m/\G[\x20\x09\x0a\x0d]*/gc;
  
    # String
    return _decode_string() if m/\G"/gc;
  
    # Object
    return _decode_object() if m/\G\{/gc;
  
    # Array
    return _decode_array() if m/\G\[/gc;
  
    # Number
    my ($i) = /\G([-]?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)/gc;
    return 0 + $i if defined $i;
  
    # True
    return $TRUE if m/\Gtrue/gc;
  
    # False
    return $FALSE if m/\Gfalse/gc;
  
    # Null
    return undef if m/\Gnull/gc;  ## no critic (return)
  
    # Invalid character
    _throw('Expected string, array, object, number, boolean or null');
  }
  
  sub _encode_array {
    '[' . join(',', map { _encode_value($_) } @{$_[0]}) . ']';
  }
  
  sub _encode_object {
    my $object = shift;
    my @pairs = map { _encode_string($_) . ':' . _encode_value($object->{$_}) }
      sort keys %$object;
    return '{' . join(',', @pairs) . '}';
  }
  
  sub _encode_string {
    my $str = shift;
    $str =~ s!([\x00-\x1f\x{2028}\x{2029}\\"/])!$REVERSE{$1}!gs;
    return "\"$str\"";
  }
  
  sub _encode_value {
    my $value = shift;
  
    # Reference
    if (my $ref = ref $value) {
  
      # Object
      return _encode_object($value) if $ref eq 'HASH';
  
      # Array
      return _encode_array($value) if $ref eq 'ARRAY';
  
      # True or false
      return $$value ? 'true' : 'false' if $ref eq 'SCALAR';
      return $value  ? 'true' : 'false' if $ref eq 'JSON::Tiny::_Bool';
  
      # Blessed reference with TO_JSON method
      if (blessed $value && (my $sub = $value->can('TO_JSON'))) {
        return _encode_value($value->$sub);
      }
    }
  
    # Null
    return 'null' unless defined $value;
  
  
    # Number (bitwise operators change behavior based on the internal value type)
  
    # "0" & $x will modify the flags on the "0" on perl < 5.14, so use a copy
    my $zero = "0";
    # "0" & $num -> 0. "0" & "" -> "". "0" & $string -> a character.
    # this maintains the internal type but speeds up the xor below.
    my $check = $zero & $value;
    return $value
      if length $check
      # 0 ^ itself          -> 0    (false)
      # $character ^ itself -> "\0" (true)
      && !($check ^ $check)
      # filter out "upgraded" strings whose numeric form doesn't strictly match
      && 0 + $value eq $value
      # filter out inf and nan
      && $value * 0 == 0;
  
    # String
    return _encode_string($value);
  }
  
  sub _throw {
  
    # Leading whitespace
    m/\G[\x20\x09\x0a\x0d]*/gc;
  
    # Context
    my $context = 'Malformed JSON: ' . shift;
    if (m/\G\z/gc) { $context .= ' before end of data' }
    else {
      my @lines = split "\n", substr($_, 0, pos);
      $context .= ' at line ' . @lines . ', offset ' . length(pop @lines || '');
    }
  
    die "$context\n";
  }
  
  # Emulate boolean type
  package JSON::Tiny::_Bool;
  use overload '""' => sub { ${$_[0]} }, fallback => 1;
  1;
JSON_TINY

$fatpacked{"LockFile/Lock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCKFILE_LOCK';
  ;# $Id
  ;#
  ;#  @COPYRIGHT@
  ;#
  ;# $Log: Lock.pm,v $
  ;# Revision 0.3  2007/09/28 19:20:14  jv
  ;# Track where lock was issued in the code.
  ;#
  ;# Revision 0.2.1.1  2000/01/04 21:16:28  ram
  ;# patch1: track where lock was issued in the code
  ;#
  ;# Revision 0.2  1999/12/07 20:51:04  ram
  ;# Baseline for 0.2 release.
  ;#
  
  use strict;
  
  ########################################################################
  package LockFile::Lock;
  
  #
  # A lock instance -- deferred class.
  #
  
  #
  # ->_lock_init
  #
  # Common lock initialization
  #
  # Attributes:
  #
  #	scheme		the LockFile::* object that created the lock
  #	filename	where lock was taken
  #	line		line in filename where lock was taken
  #
  sub _lock_init {
  	my $self = shift;
  	my ($scheme, $filename, $line) = @_;
  	$self->{'scheme'} = $scheme;
  	$self->{'filename'} = $filename;
  	$self->{'line'} = $line;
  }
  
  #
  # Common attribute access
  #
  
  sub scheme		{ $_[0]->{'scheme'} }
  sub filename	{ $_[0]->{'filename'} }
  sub line		{ $_[0]->{'line'} }
  
  #
  # ->release
  #
  # Release the lock
  #
  sub release {
  	my $self = shift;
  	return $self->scheme->release($self);
  }
  
  #
  # ->where
  #
  # Returns '"filename", line #' where lock was taken.
  #
  sub where {
  	my $self = shift;
  	return sprintf '"%s", line %d', $self->filename, $self->line;
  }
  
  1;
  
LOCKFILE_LOCK

$fatpacked{"LockFile/Lock/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCKFILE_LOCK_SIMPLE';
  ;# $Id
  ;#
  ;#  @COPYRIGHT@
  ;#
  ;# $Log: Simple.pm,v $
  ;# Revision 0.3  2007/09/28 19:18:27  jv
  ;# Track where lock was issued in the code.
  ;#
  ;# Revision 0.2.1.1  2000/01/04 21:16:35  ram
  ;# patch1: track where lock was issued in the code
  ;#
  ;# Revision 0.2  1999/12/07 20:51:04  ram
  ;# Baseline for 0.2 release.
  ;#
  
  use strict;
  
  ########################################################################
  package LockFile::Lock::Simple;
  
  require LockFile::Lock;
  
  use vars qw(@ISA);
  
  @ISA = qw(LockFile::Lock);
  
  #
  # ->make
  #
  # Creation routine
  #
  # Attributes:
  #
  #	scheme		the LockFile::* object that created the lock
  #	file		the locked file
  #	format		the format used to create the lockfile
  #	filename	where lock was taken
  #	line		line in filename where lock was taken
  #
  sub make {
  	my $self = bless {}, shift;
  	my ($scheme, $file, $format, $filename, $line) = @_;
  	$self->{'file'} = $file;
  	$self->{'format'} = $format;
  	$self->_lock_init($scheme, $filename, $line);
  	return $self;
  }
  
  #
  # Attribute access
  #
  
  sub file	{ $_[0]->{'file'} }
  sub format	{ $_[0]->{'format'} }
  
  1;
  
LOCKFILE_LOCK_SIMPLE

$fatpacked{"LockFile/Manager.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCKFILE_MANAGER';
  ;# $Id
  ;#
  ;#  @COPYRIGHT@
  ;#
  ;# $Log: Manager.pm,v $
  ;# Revision 0.2  1999/12/07 20:51:05  ram
  ;# Baseline for 0.2 release.
  ;#
  
  use strict;
  
  ########################################################################
  package LockFile::Manager;
  
  #
  # A pool of all created locks.
  #
  
  my $MANAGER = undef;		# The main manager
  
  #
  # ->make
  #
  # Creates a new LockFile::Manager to hold the locks.
  #
  # Attributes:
  #
  #	pool		hash of LockFile::Lock objects
  #	wfunc		warning function to be called
  #	efunc		error function to be called
  #
  sub make {
  	my $self = bless {}, shift;
  	my ($wfunc, $efunc) = @_;
  	$self->{'pool'} = {};
  	$self->{'wfunc'} = $wfunc;
  	$self->{'efunc'} = $efunc;
  	return $self;
  }
  
  #
  # Attribute access
  #
  
  sub pool	{ $_[0]->{'pool'} }
  sub wfunc	{ $_[0]->{'wfunc'} }
  sub efunc	{ $_[0]->{'efunc'} }
  
  #
  # ->manager		-- "once" function
  #
  # Returns the main manager.
  #
  sub manager {
  	my ($class, $wfunc, $efunc) = @_;
  	return $MANAGER || ($MANAGER = $class->make($wfunc, $efunc));
  }
  
  #
  # ->remember
  #
  # Remember created locks.
  #
  sub remember {
  	my $self = shift;
  	my ($lock) = @_;				# A LockFile::Lock object
  	my $pool = $self->pool;
  	if (exists $pool->{$lock}) {
  		&{$self->efunc}("lock $lock already remembered");
  		return;
  	}
  	$pool->{$lock} = $lock;
  }
  
  #
  # ->forget
  #
  # Forget about a lock.
  #
  sub forget {
  	my $self = shift;
  	my ($lock) = @_;				# A LockFile::Lock object
  	my $pool = $self->pool;
  	unless (exists $pool->{$lock}) {
  		&{$self->efunc}("lock $lock not remembered yet");
  		return;
  	}
  	delete $pool->{$lock};
  }
  
  #
  # ->release_all
  #
  # Release all the locks.
  #
  sub release_all {
  	my $self = shift;
  	my $pool = $self->pool;
  	my $locks = scalar keys %$pool;
  	return unless $locks;
  
  	my $s = $locks == 1 ? '' : 's';
  	&{$self->wfunc}("releasing $locks pending lock$s...");
  
  	foreach my $lock (values %$pool) {
  		$lock->release;
  	}
  }
  
  sub END { $MANAGER->release_all if defined $MANAGER }
  
  1;
  
LOCKFILE_MANAGER

$fatpacked{"LockFile/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCKFILE_SIMPLE';
  ;# $Id$
  ;#
  ;#  @COPYRIGHT@
  ;#
  ;# $Log: Simple.pm,v $
  ;# Revision 0.4  2007/09/28 19:22:05  jv
  ;# Bump version.
  ;#
  ;# Revision 0.3  2007/09/28 19:19:41  jv
  ;# Revision 0.2.1.5  2000/09/18 19:55:07  ram
  ;# patch5: fixed computation of %F and %D when no '/' in file name
  ;# patch5: fixed OO example of lock to emphasize check on returned value
  ;# patch5: now warns when no lockfile is found during unlocking
  ;#
  ;# Revision 0.2.1.4  2000/08/15 18:41:43  ram
  ;# patch4: updated version number, grrr...
  ;#
  ;# Revision 0.2.1.3  2000/08/15 18:37:37  ram
  ;# patch3: fixed non-working "-wfunc => undef" due to misuse of defined()
  ;# patch3: check for stale lock while we wait for it
  ;# patch3: untaint pid before running kill() for -T scripts
  ;#
  ;# Revision 0.2.1.2  2000/03/02 22:35:02  ram
  ;# patch2: allow "undef" in -efunc and -wfunc to suppress logging
  ;# patch2: documented how to force warn() despite Log::Agent being there
  ;#
  ;# Revision 0.2.1.1  2000/01/04 21:18:10  ram
  ;# patch1: logerr and logwarn are autoloaded, need to check something real
  ;# patch1: forbid re-lock of a file we already locked
  ;# patch1: force $\ to be undef prior to writing the PID to lockfile
  ;# patch1: track where lock was issued in the code
  ;#
  ;# Revision 0.2.1.5  2000/09/18 19:55:07  ram
  ;# patch5: fixed computation of %F and %D when no '/' in file name
  ;# patch5: fixed OO example of lock to emphasize check on returned value
  ;# patch5: now warns when no lockfile is found during unlocking
  ;#
  ;# Revision 0.2.1.4  2000/08/15 18:41:43  ram
  ;# patch4: updated version number, grrr...
  ;#
  ;# Revision 0.2.1.3  2000/08/15 18:37:37  ram
  ;# patch3: fixed non-working "-wfunc => undef" due to misuse of defined()
  ;# patch3: check for stale lock while we wait for it
  ;# patch3: untaint pid before running kill() for -T scripts
  ;#
  ;# Revision 0.2.1.2  2000/03/02 22:35:02  ram
  ;# patch2: allow "undef" in -efunc and -wfunc to suppress logging
  ;# patch2: documented how to force warn() despite Log::Agent being there
  ;#
  ;# Revision 0.2.1.1  2000/01/04 21:18:10  ram
  ;# patch1: logerr and logwarn are autoloaded, need to check something real
  ;# patch1: forbid re-lock of a file we already locked
  ;# patch1: force $\ to be undef prior to writing the PID to lockfile
  ;# patch1: track where lock was issued in the code
  ;#
  ;# Revision 0.2  1999/12/07 20:51:05  ram
  ;# Baseline for 0.2 release.
  ;#
  
  use strict;
  
  ########################################################################
  package LockFile::Simple;
  
  #
  # This package extracts the simple locking logic used by mailagent-3.0
  # into a standalone Perl module to be reused in other applications.
  #
  
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);
  
  use Sys::Hostname;
  require Exporter;
  require LockFile::Lock::Simple;
  eval "use Log::Agent";
  
  @ISA = qw(Exporter);
  @EXPORT = ();
  @EXPORT_OK = qw(lock trylock unlock);
  $VERSION = '0.208';
  
  my $LOCKER = undef;			# Default locking object
  
  #
  # ->make
  #
  # Create a file locking object, responsible for holding the locking
  # parameters to be used by all the subsequent locks requested from
  # this locking object.
  #
  # Configuration attributes:
  #
  #	autoclean		keep track of locks and release pending one at END time
  #   max				max number of attempts
  #	delay			seconds to wait between attempts
  #	format			how to derive lockfile from file to be locked
  #	hold			max amount of seconds before breaking lock (0 for never)
  #	ext				lock extension
  #	nfs				true if lock must "work" on top of NFS
  #	stale			try to detect stale locks via SIGZERO and delete them
  #	warn			flag to turn warnings on
  #	wmin			warn once after that many waiting seconds
  #	wafter			warn every that many seconds after first warning
  #	wfunc			warning function to be called
  #	efunc			error function to be called
  #
  # Additional attributes:
  #
  #	manager			lock manager, used when autoclean
  #	lock_by_file	returns lock by filename
  #
  # The creation routine first and sole argument is a "hash table list" listing
  # all the configuration attributes. Missing attributes are given a default
  # value. A call to ->configure can alter the configuration parameters of
  # an existing object.
  #
  sub make {
  	my $self = bless {}, shift;
  	my (@hlist) = @_;
  
  	# Set configuration defaults, then override with user preferences
  	$self->{'max'} = 30;
  	$self->{'delay'} = 2;
  	$self->{'hold'} = 3600;
  	$self->{'ext'} = '.lock';
  	$self->{'nfs'} = 0;
  	$self->{'stale'} = 0;
  	$self->{'warn'} = 1;
  	$self->{'wmin'} = 15;
  	$self->{'wafter'} = 20;
  	$self->{'autoclean'} = 0;
  	$self->{'lock_by_file'} = {};
  
  	# The logxxx routines are autoloaded, so need to check for @EXPORT
  	$self->{'wfunc'} = @Log::Agent::EXPORT ? \&logwarn : \&core_warn;
  	$self->{'efunc'} = @Log::Agent::EXPORT ?  \&logerr  : \&core_warn;
  
  	$self->configure(@hlist);		# Will init "manager" if necessary
  	return $self;
  }
  
  #
  # ->locker		-- "once" function
  #
  # Compute the default locking object.
  #
  sub locker {
  	return $LOCKER || ($LOCKER = LockFile::Simple->make('-warn' => 1));
  }
  
  #
  # ->configure
  #
  # Extract known configuration parameters from the specified hash list
  # and use their values to change the object's corresponding parameters.
  #
  # Parameters are specified as (-warn => 1, -ext => '.lock') for instance.
  #
  sub configure {
  	my $self = shift;
  	my (%hlist) = @_;
  	my @known = qw(
  		autoclean
  		max delay hold format ext nfs warn wfunc wmin wafter efunc stale
  	);
  
  	foreach my $attr (@known) {
  		$self->{$attr} = $hlist{"-$attr"} if exists $hlist{"-$attr"};
  	}
  
  	$self->{'wfunc'} = \&no_warn unless defined $self->{'wfunc'};
  	$self->{'efunc'} = \&no_warn unless defined $self->{'efunc'};
  
  	if ($self->autoclean) {
  		require LockFile::Manager;
  		# Created via "once" function
  		$self->{'manager'} = LockFile::Manager->manager(
  			$self->wfunc, $self->efunc);
  	}
  }
  
  #
  # Attribute access
  #
  
  sub max				{ $_[0]->{'max'} }
  sub delay			{ $_[0]->{'delay'} }
  sub format			{ $_[0]->{'format'} }
  sub hold			{ $_[0]->{'hold'} }
  sub nfs				{ $_[0]->{'nfs'} }
  sub stale			{ $_[0]->{'stale'} }
  sub ext				{ $_[0]->{'ext'} }
  sub warn			{ $_[0]->{'warn'} }
  sub wmin			{ $_[0]->{'wmin'} }
  sub wafter			{ $_[0]->{'wafter'} }
  sub wfunc			{ $_[0]->{'wfunc'} }
  sub efunc			{ $_[0]->{'efunc'} }
  sub autoclean		{ $_[0]->{'autoclean'} }
  sub lock_by_file	{ $_[0]->{'lock_by_file'} }
  sub manager			{ $_[0]->{'manager'} }
  
  #
  # Warning and error reporting -- Log::Agent used only when available
  #
  
  sub core_warn	{ CORE::warn(@_) }
  sub no_warn		{ return }
  
  #
  # ->lock
  #
  # Lock specified file, possibly using alternate file "format".
  # Returns whether file was locked or not at the end of the configured
  # blocking period by providing the LockFile::Lock instance if successful.
  #
  # For quick and dirty scripts wishing to use locks, create the locking
  # object if not invoked as a method, turning on warnings.
  #
  sub lock {
  	my $self = shift;
  	unless (ref $self) {			# Not invoked as a method
  		unshift(@_, $self);
  		$self = locker();
  	}
  	my ($file, $format) = @_;		# File to be locked, lock format
  	return $self->take_lock($file, $format, 0);
  }
  
  #
  # ->trylock
  #
  # Attempt to lock specified file, possibly using alternate file "format".
  # If the file is already locked, don't block and return undef. The
  # LockFile::Lock instance is returned upon success.
  #
  # For quick and dirty scripts wishing to use locks, create the locking
  # object if not invoked as a method, turning on warnings.
  #
  sub trylock {
  	my $self = shift;
  	unless (ref $self) {			# Not invoked as a method
  		unshift(@_, $self);
  		$self = locker();
  	}
  	my ($file, $format) = @_;		# File to be locked, lock format
  	return $self->take_lock($file, $format, 1);
  }
  
  #
  # ->take_lock
  #
  # Common code for ->lock and ->trylock.
  # Returns a LockFile::Lock object on success, undef on failure.
  #
  sub take_lock {
  	my $self = shift;
  	my ($file, $format, $tryonly) = @_;
  
  	#
  	# If lock was already taken by us, it's an error when $tryonly is 0.
  	# Otherwise, simply fail to get the lock.
  	#
  
  	my $lock = $self->lock_by_file->{$file};
  	if (defined $lock) {
  		my $where = $lock->where;
  		&{$self->efunc}("file $file already locked at $where") unless $tryonly;
  		return undef;
  	}
  
  	my $locked = $self->_acs_lock($file, $format, $tryonly);
  	return undef unless $locked;
  
  	#
  	# Create LockFile::Lock object
  	#
  
  	my ($package, $filename, $line) = caller(1);
  	$lock = LockFile::Lock::Simple->make($self, $file, $format,
  		$filename, $line);
  	$self->manager->remember($lock) if $self->autoclean;
  	$self->lock_by_file->{$file} = $lock;
  
  	return $lock;
  }
  
  #
  # ->unlock
  #
  # Unlock file.
  # Returns true if file was unlocked.
  #
  sub unlock {
  	my $self = shift;
  	unless (ref $self) {			# Not invoked as a method
  		unshift(@_, $self);
  		$self = locker();
  	}
  	my ($file, $format) = @_;		# File to be unlocked, lock format
  
  	if (defined $format) {
  		require Carp;
  		Carp::carp("2nd argument (format) is no longer needed nor used");
  	}
  
  	#
  	# Retrieve LockFile::Lock object
  	#
  
  	my $lock = $self->lock_by_file->{$file};
  
  	unless (defined $lock) {
  		&{$self->efunc}("file $file not currently locked");
  		return undef;
  	}
  
  	return $self->release($lock);
  }
  
  #
  # ->release			-- not exported (i.e. not documented)
  #
  # Same a unlock, but we're passed a LockFile::Lock object.
  # And we MUST be called as a method (usually via LockFile::Lock, not user code).
  #
  # Returns true if file was unlocked.
  #
  sub release {
  	my $self = shift;
  	my ($lock) = @_;
  	my $file = $lock->file;
  	my $format = $lock->format;
  	$self->manager->forget($lock) if $self->autoclean;
  	delete $self->lock_by_file->{$file};
  	return $self->_acs_unlock($file, $format);
  }
  
  #
  # ->lockfile
  #
  # Return the name of the lockfile, given the file name to lock and the custom
  # string provided by the user. The following macros are substituted:
  #	%D: the file dir name
  #   %f: the file name (full path)
  #   %F: the file base name (last path component)
  #   %p: the process's pid
  #   %%: a plain % character
  #
  sub lockfile {
  	my $self = shift;
  	my ($file, $format) = @_;
  	local $_ = defined($format) ? $format : $self->format;
  	s/%%/\01/g;				# Protect double percent signs
  	s/%/\02/g;				# Protect against substitutions adding their own %
  	s/\02f/$file/g;			# %f is the full path name
  	s/\02D/&dir($file)/ge;	# %D is the dir name
  	s/\02F/&base($file)/ge;	# %F is the base name
  	s/\02p/$$/g;			# %p is the process's pid
  	s/\02/%/g;				# All other % kept as-is
  	s/\01/%/g;				# Restore escaped % signs
  	$_;
  }
  
  # Return file basename (last path component)
  sub base {
  	my ($file) = @_;
  	my ($base) = $file =~ m|^.*/(.*)|;
  	return ($base eq '') ? $file : $base;
  }
  
  # Return dirname
  sub dir {
  	my ($file) = @_;
  	my ($dir) = $file =~ m|^(.*)/.*|;
  	return ($dir eq '') ? '.' : $dir;
  }
  
  #
  # _acs_lock			-- private
  #
  # Internal locking routine.
  #
  # If $try is true, don't wait if the file is already locked.
  # Returns true if the file was locked.
  #
  sub _acs_lock {		## private
  	my $self = shift;
  	my ($file, $format, $try) = @_;
  	my $max = $self->max;
  	my $delay = $self->delay;
  	my $stamp = $$;
  
  	# For NFS, we need something more unique than the process's PID
  	$stamp .= ':' . hostname if $self->nfs;
  
  	# Compute locking file name -- hardwired default format is "%f.lock"
  	my $lockfile = $file . $self->ext;
  	$format = $self->format unless defined $format;
  	$lockfile = $self->lockfile($file, $format) if defined $format;
  
  	# Detect stale locks or break lock if held for too long
  	$self->_acs_stale($file, $lockfile) if $self->stale;
  	$self->_acs_check($file, $lockfile) if $self->hold;
  
  	my $waited = 0;					# Amount of time spent sleeping
  	my $lastwarn = 0;				# Last time we warned them...
  	my $warn = $self->warn;
  	my ($wmin, $wafter, $wfunc);
  	($wmin, $wafter, $wfunc) = 
  		($self->wmin, $self->wafter, $self->wfunc) if $warn;
  	my $locked = 0;
  	my $mask = umask(0333);			# No write permission
  	local *FILE;
  
  	while ($max-- > 0) {
  		if (-f $lockfile) {
  			next unless $try;
  			umask($mask);
  			return 0;				# Already locked
  		}
  
  		# Attempt to create lock
  		if (open(FILE, ">$lockfile")) {
  			local $\ = undef;
  			print FILE "$stamp\n";
  			close FILE;
  			open(FILE, $lockfile);	# Check lock
  			my $l;
  			chop($l = <FILE>);
  			$locked = $l eq $stamp;
  			$l = <FILE>;			# Must be EOF
  			$locked = 0 if defined $l; 
  			close FILE;
  			last if $locked;		# Lock seems to be ours
  		} elsif ($try) {
  			umask($mask);
  			return 0;				# Already locked, or cannot create lock
  		}
  	} continue {
  		sleep($delay);				# Busy: wait
  		$waited += $delay;
  
  		# Warn them once after $wmin seconds and then every $wafter seconds
  		if (
  			$warn &&
  				((!$lastwarn && $waited > $wmin) ||
  				($waited - $lastwarn) > $wafter)
  		) {
  			my $waiting  = $lastwarn ? 'still waiting' : 'waiting';
  			my $after  = $lastwarn ? 'after' : 'since';
  			my $s = $waited == 1 ? '' : 's';
  			&$wfunc("$waiting for $file lock $after $waited second$s");
  			$lastwarn = $waited;
  		}
  
  		# While we wait, existing lockfile may become stale or too old
  		$self->_acs_stale($file, $lockfile) if $self->stale;
  		$self->_acs_check($file, $lockfile) if $self->hold;
  	}
  
  	umask($mask);
  	return $locked;
  }
  
  #
  # ->_acs_unlock		-- private
  #
  # Unlock file. If lock format is specified, it must match the one used
  # at lock time.
  #
  # Return true if file was indeed locked by us and is now properly unlocked.
  #
  sub _acs_unlock {	## private
  	my $self = shift;
  	my ($file, $format) = @_;		# Locked file, locking format
  	my $stamp = $$;
  	$stamp .= ':' . hostname if $self->nfs;
  
  	# Compute locking file name -- hardwired default format is "%f.lock"
  	my $lockfile = $file . $self->ext;
  	$format = $self->format unless defined $format;
  	$lockfile = $self->lockfile($file, $format) if defined $format;
  
  	local *FILE;
  	my $unlocked = 0;
  
  	if (-f $lockfile) {
  		open(FILE, $lockfile);
  		my $l;
  		chop($l = <FILE>);
  		close FILE;
  		if ($l eq $stamp) {			# Pid (plus hostname possibly) is OK
  			$unlocked = 1;
  			unless (unlink $lockfile) {
  				$unlocked = 0;
  				&{$self->efunc}("cannot unlock $file: $!");
  			}
  		} else {
  			&{$self->efunc}("cannot unlock $file: lock not owned");
  		}
  	} else {
  		&{$self->wfunc}("no lockfile found for $file");
  	}
  
  	return $unlocked;				# Did we successfully unlock?
  }
  
  #
  # ->_acs_check
  #
  # Make sure lock lasts only for a reasonable time. If it has expired,
  # then remove the lockfile.
  #
  # This is not enabled by default because there is a race condition between
  # the time we stat the file and the time we unlink the lockfile.
  #
  sub _acs_check {
  	my $self = shift;
  	my ($file, $lockfile) = @_;
  
  	my $mtime = (stat($lockfile))[9];
  	return unless defined $mtime;	# Assume file does not exist
  	my $hold = $self->hold;
  
  	# If file too old to be considered stale?
  	if ((time - $mtime) > $hold) {
  
  		# RACE CONDITION -- shall we lock the lockfile?
  
  		unless (unlink $lockfile) {
  			&{$self->efunc}("cannot unlink $lockfile: $!");
  			return;
  		}
  
  		if ($self->warn) {
  			my $s = $hold == 1 ? '' : 's';
  			&{$self->wfunc}("UNLOCKED $file (lock older than $hold second$s)");
  		}
  	}
  }
  
  #
  # ->_acs_stale
  #
  # Detect stale locks and remove them. This works by sending a SIGZERO to
  # the pid held in the lockfile. If configured for NFS, only processes
  # on the same host than the one holding the lock will be able to perform
  # the check.
  #
  # Stale lock detection is not enabled by default because there is a race
  # condition between the time we check for the pid, and the time we unlink
  # the lockfile: we could well be unlinking a new lockfile created inbetween.
  #
  sub _acs_stale {
  	my $self = shift;
  	my ($file, $lockfile) = @_;
  
  	local *FILE;
  	open(FILE, $lockfile) || return;
  	my $stamp;
  	chop($stamp = <FILE>);
  	close FILE;
  
  	my ($pid, $hostname);
  
  	if ($self->nfs) {
  		($pid, $hostname) = $stamp =~ /^(\d+):(\S+)/;
  		my $local = hostname;
  		return if $local ne $hostname;
  		return if kill 0, $pid;
  		$hostname = " on $hostname";
  	} else {
  		($pid) = $stamp =~ /^(\d+)$/;		# Untaint $pid for kill()
  		$hostname = '';
  		return if kill 0, $pid;
  	}
  
  	# RACE CONDITION -- shall we lock the lockfile?
  
  	unless (unlink $lockfile) {
  		&{$self->efunc}("cannot unlink stale $lockfile: $!");
  		return;
  	}
  
  	&{$self->wfunc}("UNLOCKED $file (stale lock by PID $pid$hostname)");
  }
  
  1;
  
  ########################################################################
  
  =head1 NAME
  
  LockFile::Simple - simple file locking scheme
  
  =head1 SYNOPSIS
  
   use LockFile::Simple qw(lock trylock unlock);
  
   # Simple locking using default settings
   lock("/some/file") || die "can't lock /some/file\n";
   warn "already locked\n" unless trylock("/some/file");
   unlock("/some/file");
  
   # Build customized locking manager object
   $lockmgr = LockFile::Simple->make(-format => '%f.lck',
  	-max => 20, -delay => 1, -nfs => 1);
  
   $lockmgr->lock("/some/file") || die "can't lock /some/file\n";
   $lockmgr->trylock("/some/file");
   $lockmgr->unlock("/some/file");
  
   $lockmgr->configure(-nfs => 0);
  
   # Using lock handles
   my $lock = $lockmgr->lock("/some/file");
   $lock->release;
  
  =head1 DESCRIPTION
  
  This simple locking scheme is not based on any file locking system calls
  such as C<flock()> or C<lockf()> but rather relies on basic file system
  primitives and properties, such as the atomicity of the C<write()> system
  call. It is not meant to be exempt from all race conditions, especially over
  NFS. The algorithm used is described below in the B<ALGORITHM> section.
  
  It is possible to customize the locking operations to attempt locking
  once every 5 seconds for 30 times, or delete stale locks (files that are
  deemed too ancient) before attempting the locking.
  
  =head1 ALGORITHM
  
  The locking alogrithm attempts to create a I<lockfile> using a temporarily
  redefined I<umask> (leaving only read rights to prevent further create
  operations). It then writes the process ID (PID) of the process and closes
  the file. That file is then re-opened and read. If we are able to read the
  same PID we wrote, and only that, we assume the locking is successful.
  
  When locking over NFS, i.e. when the one of the potentially locking processes
  could access the I<lockfile> via NFS, then writing the PID is not enough.
  We also write the hostname where locking is attempted to ensure the data
  are unique.
  
  =head1 CUSTOMIZING
  
  Customization is only possible by using the object-oriented interface,
  since the configuration parameters are stored within the object. The
  object creation routine C<make> can be given configuration parmeters in
  the form a "hash table list", i.e. a list of key/value pairs. Those
  parameters can later be changed via C<configure> by specifying a similar
  list of key/value pairs.
  
  To benefit from the bareword quoting Perl offers, all the parameters must
  be prefixed with the C<-> (minus) sign, as in C<-format> for the I<format>
  parameter..  However, when querying the object, the minus must be omitted,
  as in C<$obj-E<gt>format>.
  
  Here are the available configuration parmeters along with their meaning,
  listed in alphabetical order:
  
  =over 4
  
  =item I<autoclean>
  
  When true, all locks are remembered and pending ones are automatically
  released when the process exits normally (i.e. whenever Perl calls the
  END routines).
  
  =item I<delay>
  
  The amount of seconds to wait between locking attempts when the file appears
  to be already locked. Default is 2 seconds.
  
  =item I<efunc>
  
  A function pointer to dereference when an error is to be reported. By default,
  it redirects to the logerr() routine if you have Log::Agent installed,
  to Perl's warn() function otherwise.
  
  You may set it explicitely to C<\&LockFile::Simple::core_warn> to force the
  use of Perl's warn() function, or to C<undef> to suppress logging.
  
  =item I<ext>
  
  The locking extension that must be added to the file path to be locked to
  compute the I<lockfile> path. Default is C<.lock> (note that C<.> is part
  of the extension and can therefore be changed). Ignored when I<format> is
  also used.
  
  =item I<format>
  
  Using this parmeter supersedes the I<ext> parmeter. The formatting string
  specified is run through a rudimentary macro expansion to derive the
  I<lockfile> path from the file to be locked. The following macros are
  available:
  
      %%	A real % sign
      %f	The full file path name
      %D	The directory where the file resides
      %F	The base name of the file
      %p	The process ID (PID)
  
  The default is to use the locking extension, which itself is C<.lock>, so
  it is as if the format used was C<%f.lock>, but one could imagine things
  like C</var/run/%F.%p>, i.e. the I<lockfile> does not necessarily lie besides
  the locked file (which could even be missing).
  
  When locking, the locking format can be specified to supersede the object
  configuration itself.
  
  =item I<hold>
  
  Maximum amount of seconds we may hold a lock. Past that amount of time,
  an existing I<lockfile> is removed, being taken for a stale lock. Default
  is 3600 seconds. Specifying 0 prevents any forced unlocking.
  
  =item I<max>
  
  Amount of times we retry locking when the file is busy, sleeping I<delay>
  seconds between attempts. Defaults to 30.
  
  =item I<nfs>
  
  A boolean flag, false by default. Setting it to true means we could lock
  over NFS and therefore the hostname must be included along with the process
  ID in the stamp written to the lockfile.
  
  =item I<stale>
  
  A boolean flag, false by default. When set to true, we attempt to detect
  stale locks and break them if necessary.
  
  =item I<wafter>
  
  Stands for I<warn after>. It is the number of seconds past the first
  warning during locking time after which a new warning should be emitted.
  See I<warn> and I<wmin> below. Default is 20.
  
  =item I<warn>
  
  A boolean flag, true by default. To suppress any warning, set it to false.
  
  =item I<wfunc>
  
  A function pointer to dereference when a warning is to be issued. By default,
  it redirects to the logwarn() routine if you have Log::Agent installed,
  to Perl's warn() function otherwise.
  
  You may set it explicitely to C<\&LockFile::Simple::core_warn> to force the
  use of Perl's warn() function, or to C<undef> to suppress logging.
  
  =item I<wmin>
  
  The minimal amount of time when waiting for a lock after which a first
  warning must be emitted, if I<warn> is true. After that, a warning will
  be emitted every I<wafter> seconds. Defaults to 15.
  
  =back
  
  Each of those configuration attributes can be queried on the object directly:
  
      $obj = LockFile::Simple->make(-nfs => 1);
      $on_nfs = $obj->nfs;
  
  Those are pure query routines, i.e. you cannot say:
  
      $obj->nfs(0);                  # WRONG
      $obj->configure(-nfs => 0);    # Right
  
  to turn of the NFS attribute. That is because my OO background chokes
  at having querying functions with side effects.
  
  =head1 INTERFACE
  
  The OO interface documented below specifies the signature and the
  semantics of the operations. Only the C<lock>, C<trylock> and
  C<unlock> operation can be imported and used via a non-OO interface,
  with the exact same signature nonetheless.
  
  The interface contains all the attribute querying routines, one for
  each configuration parmeter documented in the B<CUSTOMIZING> section
  above, plus, in alphabetical order:
  
  =over 4
  
  =item configure(I<-key =E<gt> value, -key2 =E<gt> value2, ...>)
  
  Change the specified configuration parameters and silently ignore
  the invalid ones.
  
  =item lock(I<file>, I<format>)
  
  Attempt to lock the file, using the optional locking I<format> if
  specified, otherwise using the default I<format> scheme configured
  in the object, or by simply appending the I<ext> extension to the file.
  
  If the file is already locked, sleep I<delay> seconds before retrying,
  repeating try/sleep at most I<max> times. If warning is configured,
  a first warning is emitted after waiting for I<wmin> seconds, and
  then once every I<wafter> seconds, via  the I<wfunc> routine.
  
  Before the first attempt, and if I<hold> is non-zero, any existing
  I<lockfile> is checked for being too old, and it is removed if found
  to be stale. A warning is emitted via the I<wfunc> routine in that
  case, if allowed.
  
  Likewise, if I<stale> is non-zero, a check is made to see whether
  any locking process is still around (only if the lock holder is on the
  same machine when NFS locking is configured). Should the locking
  process be dead, the I<lockfile> is declared stale and removed.
  
  Returns a lock handle if the file has been successfully locked, which
  does not necessarily needs to be kept around. For instance:
  
      $obj->lock('ppp', '/var/run/ppp.%p');
      <do some work>
      $obj->unlock('ppp');
  
  or, using OO programming:
  
      my $lock = $obj->lock('ppp', '/var/run/ppp.%p') ||;
          die "Can't lock for ppp\n";
      <do some work>
      $lock->relase;   # The only method defined for a lock handle
  
  i.e. you don't even have to know which file was locked to release it, since
  there is a lock handle right there that knows enough about the lock parameters.
  
  =item lockfile(I<file>, I<format>)
  
  Simply compute the path of the I<lockfile> that would be used by the
  I<lock> procedure if it were passed the same parameters.
  
  =item make(I<-key =E<gt> value, -key2 =E<gt> value2, ...>)
  
  The creation routine for the simple lock object. Returns a blessed hash
  reference.
  
  =item trylock(I<file>, I<format>)
  
  Same as I<lock> except that it immediately returns false and does not
  sleep if the to-be-locked file is busy, i.e. already locked. Any
  stale locking file is removed, as I<lock> would do anyway.
  
  Returns a lock hande if the file has been successfully locked.
  
  =item unlock(I<file>)
  
  Unlock the I<file>.
  
  =back
  
  =head1 BUGS
  
  The algorithm is not bullet proof.  It's only reasonably safe.  Don't bet
  the integrity of a mission-critical database on it though.
  
  The sysopen() call should probably be used with the C<O_EXCL|O_CREAT> flags
  to be on the safer side. Still, over NFS, this is not an atomic operation
  anyway.
  
  B<BEWARE>: there is a race condition between the time we decide a lock is
  stale or too old and the time we unlink it. Don't use C<-stale> and set
  C<-hold> to 0 if you can't bear with that idea, but recall that this race
  only happens when something is already wrong. That does not make it right,
  nonetheless. ;-)
  
  =head1 AUTHOR
  
  Raphael Manfredi F<E<lt>Raphael_Manfredi@pobox.comE<gt>>
  
  =head1 SEE ALSO
  
  File::Flock(3).
  
  =cut
  
LOCKFILE_SIMPLE

$fatpacked{"VC3/Bag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_BAG';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Bag; 
  
  use Carp qw/carp croak/;
  #use English qw/-mo_match_vars/;
  use File::Basename;
  use File::Copy;
  use File::Spec::Functions qw/catfile rel2abs file_name_is_absolute/;
  use File::Temp qw/tempfile/;
  use FindBin  qw/$RealBin $RealScript/;
  use JSON::Tiny;
  use List::Util qw/first max/;
  use POSIX ();
  use Tie::RefHash;
  use version ();
  
  use VC3::Plan;
  use VC3::Package;
  
  sub new {
      my ($class, %args) = @_;
      
      #args:
      #    root       
      #    home       
      #    distfiles  
      #    repository 
      #    shell      
      #    dry_run    
      #    on_terminal
      #    silent     
      #    databases  
      #    pkg_opts  
      #    sys_manual 
      #    no_sys     
      #    env_vars   
  
      my $self = bless {}, $class;
  
      $self->{dry_run}     = $args{dry_run};
      $self->{on_terminal} = $args{on_terminal};
      $self->{silent_run}  = $args{silent};
  
      # clean generated shell profile by default
      $self->preserve_profile(0);
  
      # root, home, shell, etc.
      $self->set_builder_variables($args{root}, $args{home}, $args{shell}, $args{distfiles}, $args{repository});
  
      # read the catalog of available packages
      my $recipes_raw = $self->read_bags($args{databases});
  
      $self->{recipes}{op_sys_distro} = $self->decode_recipes($recipes_raw->{op_sys_distro}, $args{pkg_opts});
      # arch, distro, etc.
      $self->set_machine_vars();
  
      $self->{recipes}{op_sys}  = $self->decode_recipes($recipes_raw->{op_sys}, $args{pkg_opts});
      $self->{recipes}{package} = $self->decode_recipes($recipes_raw->{package}, $args{pkg_opts});
  
      if(%{$args{pkg_opts}}) {
          warn 'The options for these packages were unused: ', join(',', keys %{$args{pkg_opts}}) . "\n";
      }
  
      $self->{no_system} = { map { ( $_ => 1 ), } @{$args{no_sys}} };
      $self->{system}    = {};
  
      # always use singularity from the system (we can't compile it as a user.)
      $self->{system}{singularity} = 1;
  
      $self->{indent_level} = 0;
  
      $self->add_manual_variables($args{env_vars});
      $self->add_manual_packages($args{sys_manual});
  
      $self->write_db();
  
      return $self;
  }
  
  sub to_hash {
      my ($self) = @_;
  
      my $bh = {};
  
      for my $subbag (values %{$self->{recipes}}) {
          for my $p (values %{$subbag}) {
              $bh->{$p->name} = $p->original_description();
          }
      }
  
      return $bh;
  }
  
  sub write_db {
      my ($self) = @_;
  
      my $rec_file = $self->sh_profile . '.recipes';
  
      # write recipes
      open(my $sh_f_recp, '>', $rec_file)
      || die "Could not open file $rec_file $!";
  
  
      my $json = JSON::Tiny::encode_json($self->to_hash);
      print { $sh_f_recp } "$json";
      close($sh_f_recp);
  }
  
  sub list_packages() {
      my ($self, $option) = @_;
  
      my @ps;
      if($option eq 'os') {
          @ps = values %{$self->{recipes}{op_sys}};
      } else {
          @ps = values %{$self->{recipes}{package}};
      }
  
      if($option ne 'all') {
          @ps = grep { $_->show_in_list } @ps;
      }
  
      my $by_tags = ($option eq 'section');
  
      my %tags;
      for my $p (@ps) {
          my @ts = ($by_tags && $p->tags) ? @{$p->tags} : ('other');
  
          for my $t (@ts) {
              $tags{$t} ||= [];
              push @{$tags{$t}}, $p;
          }
      }
  
      my @tagnames = sort { $a cmp $b } keys %tags;
  
      @tagnames = grep { ! m/other/ } @tagnames;
      push @tagnames, 'other';
  
      for my $t (@tagnames) {
          if(defined $tags{$t}) {
  
              my @ps = sort { $a->name cmp $b->name } @{$tags{$t}};
  
              if($by_tags) {
                  print "\n--- $t\n";
              }
  
              for my $p (@ps) {
                  my $printed = {};
                  my $ws = $p->widgets;
  
                  for my $w (@{$ws}) {
                      my $version = $w->from_system ? 'auto' : $w->version;
  
                      my $str = $p->name . ':' . $version;
  
                      unless(defined $printed->{$str}) {
                          $printed->{$str} = 1;
                          print "$str\n";
                      }
                  }
              }
          }
      }
  }
  
  sub check_manual_requirements() {
      my ($self) = @_;
  
      my @restricted_unmet;
      for my $w (@{$self->plan->order}) {
          my $msg = $w->msgs_manual_requirements();
          if($msg) {
              $self->activate_widget($w);
              push @restricted_unmet, $w->msgs_manual_requirements();
          }
      }
  
      if(@restricted_unmet > 0) {
          my ($pid, $build_in) = $self->shell();
  
          print { $build_in } "cat <<EOF\n";
  
          for my $msg (@restricted_unmet) {
              for my $line (@{$msg}) {
                  print { $build_in } "$line\n";
              }
              print { $build_in } "\n";
          }
  
          print { $build_in } "EOF\n";
          print { $build_in } "exit 0\n";
  
          die "\n";
      }
  
      return 1;
  }
  
  sub active_widgets {
      my ($self) = @_;
  
      unless($self->{active_widgets}) {
          my %new;
          tie %new, 'Tie::RefHash';
  
          $self->{active_widgets} = \%new;
      }
  
      return $self->{active_widgets};
  }
  
  sub active_widgets_vars {
      my ($self) = @_;
  
      unless($self->{active_widgets_vars}) {
          my %new;
          tie %new, 'Tie::RefHash';
  
          $self->{active_widgets_vars} = \%new;
      }
  
      return $self->{active_widgets_vars};
  }
  
  sub activate_widget {
      my ($self, $widget) = @_;
      $self->activate_widget_vars($widget);
      $self->active_widgets->{$widget} = 1;
  }
  
  sub activate_widget_vars {
      my ($self, $widget) = @_;
      $self->active_widgets_vars->{$widget} = 1;
  }
  
  sub set_builder_variables {
      my ($self, $root, $home, $shell, $distfiles, $repository) = @_;
  
      $self->{environment_variables} = [];
  
      $self->root_dir($root);
      $self->home_dir($home);
      $self->files_dir($distfiles);
      $self->tmp_dir($self->with_root('tmp'));
  
      $self->repository($repository);
  
      $self->shell_executable($shell);
  
      # the var $> has the effective uid of the current user
      $self->user_uid($>);
  
      # the var $) has the effective groups of the current user
      $self->user_gid($));
  
      $self->user_name($ENV{'USER'} || getpwuid($self->user_uid) || 'vc3-user');
  
      my $executable = $RealScript;
      if($executable eq '-e') {
          # this will break! BUG. How to know the name of static executable?
          $executable = 'vc3-builder-static';
      }
  
      $self->builder_path(catfile($RealBin, $executable));
  
      eval {
          File::Path::make_path($self->root_dir);
          File::Path::make_path($self->files_dir);
          File::Path::make_path(catfile($self->files_dir, 'manual-distribution'));
          File::Path::make_path(catfile($self->files_dir, 'images', 'singularity'));
          File::Path::make_path(catfile($self->files_dir, 'images', 'docker'));
          File::Path::make_path($self->home_dir);
          File::Path::make_path($self->tmp_dir);
      };
  
      if($@) {
          my $error = $@;
          $error =~ s/ at .*$//;
          warn("Could not create some directory: $error");
          warn("giving up...\n");
          exit 1;
      }
  
      my ($profile_f, $profile_name) = tempfile(catfile($self->home_dir, '.vc3_sh-XXXXXX'));
      close $profile_f;
      $self->sh_profile($profile_name);
  
      $self->add_builder_variable('VC3_ROOT',         $self->root_dir);
      $self->add_builder_variable('VC3_DISTFILES',    $self->files_dir);
      $self->add_builder_variable('VC3_BUILDER_PATH', $self->builder_path);
      $self->add_builder_variable('VC3_INSTALL_USER_HOME', $self->home_dir);
      $self->add_builder_variable('TMP',              $self->tmp_dir);
      $self->add_builder_variable('TERM',             $ENV{'TERM'} || 'xterm');
      $self->add_builder_variable('CC',               $ENV{'CC'}   || 'gcc');
      $self->add_builder_variable('CXX',              $ENV{'CXX'}  || 'g++');
      $self->add_builder_variable('SHELL',            $self->shell_executable);
  
      # we don't want to overwrite these variables in the general profile:
      # $self->add_builder_variable('USER',
      # $self->add_builder_variable('HOME',             $self->home_dir);
  }
  
  sub DESTROY {
      my ($self) = @_;
      $self->cleanup();
  }
  
  sub root_dir {
      my ($self, $root) = @_;
  
      if($root) {
          $root = glob $root; # expand ~
          $root = rel2abs($root);
          $self->{root_dir} = $root;
      }
  
      return $self->{root_dir};
  }
  
  sub repository {
      my ($self, $shell) = @_;
  
      if($shell) {
          $self->{repository} = $shell;
      }
  
      return $self->{repository};
  }
  
  sub shell_executable {
      my ($self, $shell) = @_;
  
      if($shell) {
          $self->{shell_executable} = $shell;
      }
  
      return $self->{shell_executable};
  }
  
  sub home_dir {
      my ($self, $home) = @_;
  
      if($home) {
          $home = glob $home; # expand ~
  
          unless(file_name_is_absolute($home)) {
              $home = $self->with_root($home);
          }
  
          $home = rel2abs($home);
          $self->{home_dir} = $home;
      }
  
      return $self->{home_dir};
  }
  
  sub files_dir {
      my ($self, $files) = @_;
  
      if($files) {
          $files = glob $files; # expand ~
          $files = rel2abs($files);
          $self->{files_dir} = $files;
      }
  
      return $self->{files_dir};
  }
  
  sub tmp_dir {
      my ($self, $tmp) = @_;
  
      if($tmp) {
          $tmp = glob $tmp; # expand ~
          $tmp = rel2abs($tmp);
          $self->{tmp_dir} = $tmp;
      }
  
      return $self->{tmp_dir};
  }
  
  sub with_root {
      my ($self, $dir) = @_;
  
      return catfile($self->root_dir, $dir);
  }
  
  sub user_name {
      my ($self, $name) = @_;
  
      $self->{user_name} = $name if($name);
  
      return $self->{user_name};
  }
  
  sub user_uid {
      my ($self, $uid) = @_;
  
      if(defined $uid) {
          $self->{user_uid} = $uid;
      }
  
      return $self->{user_uid};
  }
  
  sub user_gid {
      my ($self, $gids) = @_;
  
      if(defined $gids) {
          my @all = split(' ', $gids);
          $self->{user_gid} = $all[0];
      }
  
      return $self->{user_gid};
  }
  
  sub on_terminal {
      my ($self, $ont) = @_;
  
      $self->{on_terminal} = $ont if($ont);
  
      return $self->{on_terminal};
  }
  
  
  sub plan {
      my ($self, $new) = @_;
  
      $self->{plan} = $new if($new);
  
      return $self->{plan};
  }
  
  sub builder_path {
      my ($self, $new) = @_;
  
      $self->{builder} = $new if($new);
  
      return $self->{builder};
  }
  
  
  sub sh_profile {
      my ($self, $init) = @_;
  
      $self->{sh_profile} = $init if($init);
  
      return $self->{sh_profile};
  }
  
  sub dry_run {
      my ($self) = @_;
      return $self->{dry_run};
  }
  
  sub preserve_profile {
      my ($self, $val) = @_;
  
      if(defined $val) {
          $self->{preserve_profile} = $val;
      }
  
      unless(defined $self->{preserve_profile}) {
          # do not preserve profile by default.
          $self->{preserve_profile} = 0;
      }
  
      return $self->{preserve_profile};
  }
  
  
  sub environment_variables {
      my ($self, $new_vars) = @_;
  
      $self->{environment_variables} = $new_vars if($new_vars);
  
      return $self->{environment_variables};
  }
  
  sub add_builder_variable {
      my ($self, $name, $value) = @_;
  
      my $var = {
          name     => $name,
          value    => $value,
          clobber  => 1,
          absolute => 1
      };
  
      my $vars = $self->environment_variables;
      push @{$vars}, $var;
  
      return $var;
  }
  
  sub add_manual_variables {
      my ($self, $extra_vars) = @_;
  
      for my $var (@{$extra_vars}) {
          $var =~ m/
          ^
          (?<name>[A-Za-z_][A-Z-a-z_0-9]*)
          =
          (?<value>.*)
          $
          /x or die "Malformed variable specification: '$var'";
  
          $self->add_builder_variable($+{name}, $+{value});
      }
  }
  
  
  sub add_manual_packages {
      my ($self, $specs) = @_;
  
      for my $spec (@{$specs}) {
          my ($name, $version, $dir);
  
          if(
              $spec =~ m/
              ^
              (?<name>[A-Za-z_][A-Z-a-z_0-9]*)
              :
              (?<version>(([0-9]+(\.?[0-9]){0,3})|auto))
              (=(?<dir>.*))?
              $
              /x
          ) {
              ($name, $version, $dir) = @+{qw(name version dir)};
              $dir ||= '/usr';
          } else {
              die "Malformed manual specification: '$spec'\n";
          }
  
          my $pkg = $self->{recipes}{package}{$name};
          unless($pkg) {
              die "Could not find specification to overwrite for '$name'\n";
          }
  
          if($version eq 'auto') {
              $version = $pkg->compute_auto_version($dir);
          }
  
          my $s = {};
          $s->{version} = $version;
          $s->{source} = {
              type   => 'system',
              recipe => [
                  "echo VC3_ROOT_SYSTEM: $dir"
              ]
          };
  
          $self->{system}{$name} = 1;
  
          my $widgets = $pkg->widgets;
          unshift @{$widgets}, VC3::Widget->new($pkg, $s);
      }
  }
  
  sub del_builder_variable {
      my ($self, $name) = @_;
  
      my @vars = @{$self->environment_variables};
      @vars = grep { $name ne $_->{name} } @vars;
  
      $self->environment_variables(\@vars);
  }
  
  sub set_plan_for {
      my ($self, @requires) = @_;
  
      $self->{indent_level} = 0;
  
      my $plan = VC3::Plan->new($self);
      $self->plan($plan);
  
      if(!$plan->add_main_targets(@requires)) {
          die("Could not find an installation plan.\n");
      }
  
      $plan->order(1);
  }
  
  sub execute_plan {
      my ($self, $sh_on_error, $force_rebuild, $ignore_locks) = @_;
  
      for my $w (@{$self->plan->order}) {
          $self->activate_widget_vars($w);
          $self->build_widget($w, $sh_on_error, $force_rebuild, $ignore_locks);
          $self->activate_widget($w);
      }
  }
  
  sub cleanup {
      my ($self) = @_;
  
      if($self->{child_pid}) {
          $self->say('Cleaning payload with pid: ' . $self->{child_pid});
          # send HUP to all processes
          kill -1, $self->{child_pid};
      }
  
      unless($self->preserve_profile) {
  
          if(defined $self->sh_profile) {
              if(-f $self->sh_profile) {
                  unlink $self->sh_profile;
              }
  
              if(-f $self->sh_profile . '.env') {
                  unlink $self->sh_profile . '.env';
              }
  
              if(-f $self->sh_profile . '.prologue') {
                  unlink $self->sh_profile . '.prologue';
              }
  
              if(-f $self->sh_profile . '.wrapper') {
                  unlink $self->sh_profile . '.wrapper';
              }
  
              if(-f $self->sh_profile . '.payload') {
                  unlink $self->sh_profile . '.payload';
              }
  
              if(-f $self->sh_profile . '.recipes') {
                  unlink $self->sh_profile . '.recipes';
              }
          }
  
          $self->del_builder_variable('VC3_SH_PROFILE_ENV');
          $self->del_builder_variable('VC3_SH_PROFILE_WRAPPER');
      }
  
      if($self->{child_pid}) {
          # give 10 seconds for child to cleanup HUP, then REDRUM
          for my $i (1..10) {
              my $n = waitpid(-1, POSIX::WNOHANG);
              if($n < 0) {
                  $self->{child_pid} = undef;
                  return;
              } else {
                  $self->say('Waiting for payload with pid: ' . $self->{child_pid} . "  $n");
                  VC3::Builder::select_sleep(1);
              }
          }
          $self->say('Hard terminating for payload with pid: ' . $self->{child_pid});
  
          # KILL to anybody
          kill -9, $self->{child_pid};
          $self->{child_pid} = undef;
      }
  }
  
  sub set_machine_vars {
      my ($self) = @_;
  
      ($self->{osname}, undef, undef, undef, $self->{architecture}) = POSIX::uname();
  
      $self->{distribution} = $self->find_distribution();
  
      $self->{target} = catfile($self->architecture, $self->distribution);
  
  
      my $ldd_version_raw = qx(ldd --version);
      $ldd_version_raw =~ /
      # we are looking for a line starting with 'ldd'
      ^ldd
      # followed by anything
      .*
      # followed by at least one space
      \s+
      # followed by the version number (that we capture)
      ([0-9.]+)
      # followed by any number of spaces at the end of the line
      \s*$
      # options: x allows regexp comments. m treats each line indepedently
      /xm ;
  
      $self->{glibc_version} = $1
      || 'unknown';
  
      $self->add_builder_variable('VC3_MACHINE_OS',            catfile($self->{osname}, $self->distribution));
      $self->add_builder_variable('VC3_MACHINE_ARCH',          $self->architecture);
      $self->add_builder_variable('VC3_MACHINE_GLIBC_VERSION', $self->glibc_version);
      $self->add_builder_variable('VC3_MACHINE_TARGET',        $self->{target});
  }
  
  sub target {
      my ($self) = @_;
      return $self->{target};
  }
  
  sub osname {
      my ($self) = @_;
      return $self->{osname};
  }
  
  sub architecture {
      my ($self) = @_;
      return $self->{architecture};
  }
  
  sub glibc_version {
      my ($self) = @_;
      return $self->{glibc_version};
  }
  
  sub distribution {
      my ($self) = @_;
      return $self->{distribution};
  }
  
  # reads /etc/readhat-release and transforms something like:
  # 'Red Hat Enterprise Linux Server release 6.5 (Santiago)'
  # into 'redhat6'.
  # or /etc/debian_version into 'debian9
  # etc.
  sub find_distribution {
      my ($self) = @_;
      my $distribution;
  
      my @wheres = values %{$self->{recipes}{op_sys_distro}};
  
      @wheres = sort { $a->name cmp $b->name } @wheres;
  
      for my $p (@wheres) {
          for my $w (@{$p->widgets}) {
              my $exit_status = -1;
              eval { $exit_status = $w->source->check_prerequisites() };
              if($exit_status) {
                  next;
              }
  
              eval { $distribution = $w->compute_os_distribution(); };
              if($@) {
                  next;
              }
  
              if($distribution) {
                  return $distribution;
              }
          }
      }
  
      warn "Could not find any OS version. Using 'generic'\n";
      return 'generic';
  }
  
  sub widgets_of {
      my ($self, $name) = @_;
  
      my $pkg = $self->{recipes}{package}{$name}
      || die "I do not know anything about '$name' . \n";
  
      return $pkg->widgets;
  }
  
  sub read_bags {
      my ($self, $databases) = @_;
  
      my $recipes  = {};
      $recipes->{package} = {};
      $recipes->{op_sys}  = {};
      $recipes->{op_sys_distro} = {};
  
      for my $filespec (@{$databases}) {
          if(-d $filespec) {
              $self->read_bag_dir($filespec, 1, $recipes);
          } elsif(-f $filespec) {
              $self->read_bag_file($filespec, $recipes);
          } elsif($filespec eq '<internal>') {
              $self->read_bag_internal($recipes);
          }
      }
  
      return $recipes;
  }
  
  sub read_bag_dir {
      my ($self, $dir, $depth, $recipes) = @_;
  
      if($depth > 32) {
          die "Maximum directory depth allowed reached.\n";
      }
  
      my @listing = sort { $a cmp $b } glob catfile($dir, '*');
  
      for my $filespec (@listing) {
          if(-d $filespec) {
              $self->read_bag_dir($filespec, $depth+1, $recipes);
          } elsif($filespec =~ m/\.json$/) {
              $self->read_bag_file($filespec, $recipes);
          }
      }
  }
  
  sub read_bag_file {
      my ($self, $filename, $recipes) = @_;
  
      open(my $catbag_f, '<:encoding(UTF-8)', $filename) ||
      die "Could not open '$filename': $!\n";
  
      return $self->read_bag_fh($catbag_f, $recipes);
  }
  
  sub read_bag_internal {
      my ($self, $recipes) = @_;
  
      {
          no warnings;
          if(tell(VC3::Builder::DATA) == -1) {
              return $recipes;
          }
      }
  
      my $catbag_f = *VC3::Builder::DATA;
  
      return $self->read_bag_fh($catbag_f, $recipes);
  }
  
  
  sub read_bag_fh {
      my ($self, $fh, $recipes) = @_;
  
      my $contents = do { local($/); <$fh> };
      close($fh);
  
      my $bag_raw; 
      eval { $bag_raw = JSON::Tiny::decode_json($contents); };
      if($@) {
          die "There was an error while decoding JSON file:\n$@\n";
      }
  
      if(ref($bag_raw) ne 'ARRAY') {
          $bag_raw = [ $bag_raw ];
      }
  
      for my $obj (@{$bag_raw}) {
          for my $package_name (keys %{$obj}) {
  
              my $pkg_raw = $obj->{$package_name};
  
              if(!$pkg_raw->{type} || $pkg_raw->{type} eq 'package') {
                  $recipes->{package}{$package_name} = $pkg_raw;
              } elsif($pkg_raw->{type} eq 'operating-system') {
                  $recipes->{op_sys}{$package_name} = $pkg_raw;
              } elsif($pkg_raw->{type} eq 'operating-system-distribution') {
                  $recipes->{op_sys_distro}{$package_name} = $pkg_raw;
              } else {
                  die "I don't know about a package type '" . $pkg_raw->{type} . "'\n";
              }
          }
      }
  
      return $recipes;
  } 
  
  sub decode_recipes {
      my ($self, $raw, $pkg_opts) = @_;
  
      my $recipes = {};
  
      for my $package_name (keys %{$raw}) {
          if(exists $pkg_opts->{$package_name}) {
              $raw->{$package_name}{options} = $pkg_opts->{$package_name};
              delete $pkg_opts->{$package_name};
          }
  
          my $pkg = VC3::Package->new($self, $package_name, $raw->{$package_name});
          $recipes->{$package_name} = $pkg;
      }
  
      return $recipes;
  }
  
  sub build_widget {
      my ($self, $widget, $sh_on_error, $force_rebuild, $ignore_locks) = @_;
  
      my $sys_label = $widget->source->type eq 'system' ? ' (from host)' : '';
      $self->say("processing for @{[$widget->package->name]}-" . $widget->version->normal . $sys_label);
  
  
      my $exit_status = 0;
      eval { $exit_status = -1; $exit_status = $widget->source->execute_recipe($force_rebuild, $ignore_locks) };
  
      if($exit_status) {
          $widget->process_error($sh_on_error, $English::EVAL_ERROR, $exit_status);
          exit 1;
      }
  
      return $exit_status;
  }
  
  sub dot_graph {
      my ($self, $dotname) = @_;
      return $self->plan->dot_graph($dotname);
  }
  
  sub to_parallel {
      my ($self, $dir, $make_jobs) = @_;
  
      my $abs_dir;
      if(file_name_is_absolute($dir)) {
          $abs_dir = $dir;
      } else {
          $abs_dir = catfile($self->home_dir, $dir);
      }
  
      my $dag_name       = 'dag';
      my $builder_name   = 'builder';
      my $local_database = 'recipes';
  
      File::Path::make_path($abs_dir);
  
      my $build_wrapper = catfile($abs_dir, 'build');
      open my $script_f, '>', "$build_wrapper" || die "Could not open '$build_wrapper' for writing: $!";
      print { $script_f } <<EOFF;
  #! @{[$self->shell_executable]}
  set -e
  
  makeflow --shared-fs @{[$self->root_dir]} -r 5 $dag_name "\$@"
  
  cat <<EOF
  
  Parallel build mode complete. To run type:
  
  VC3_ROOT=@{[$self->root_dir]}
  VC3_DB=@{[catfile($abs_dir, $local_database)]}
  
  $0 --database \\\${VC3_DB} --install \\\${VC3_ROOT} @{[map { "--require $_" } @{$self->plan->requirements}]}
  
  EOF
  EOFF
  
      close $script_f;
      chmod 0755, $build_wrapper;
  
      my $builder_path = catfile($abs_dir, $builder_name);
      copy($self->builder_path, $builder_path);
      chmod 0755, $builder_path;
  
      $self->plan->to_makeflow($abs_dir, $dag_name, $builder_name, $local_database, $make_jobs);
  
      $self->check_manual_requirements();
      $self->plan->prestage();
  }
  
  sub set_environment_variables {
      my ($self, $sh_f) = @_;
  
      my $env = $self->active_widgets_vars();
  
      my $expansion = {};
  
      for my $var (@{$self->environment_variables}) {
          $expansion->{$var->{name}} = [$var->{value}];
      }
  
      if($self->plan and $self->plan->order) {
          for my $wid (@{$self->plan->order}) {
              next unless $env->{$wid};
              $wid->consolidate_environment_variables($expansion);
          }
      }
  
      $expansion->{'PATH'} ||= [];
      $expansion->{'LD_LIBRARY_PATH'} ||= [];
      $expansion->{'MODULEPATH'} ||= [];
  
      # use default PATH:
      push @{$expansion->{'PATH'}},            $ENV{'PATH'}            || qw(/bin /usr/bin /usr/local/bin);
      push @{$expansion->{'LD_LIBRARY_PATH'}}, $ENV{'LD_LIBRARY_PATH'} || qw(/lib /usr/lib /usr/local/lib);
      push @{$expansion->{'MODULEPATH'}},      $ENV{'MODULEPATH'}      || ();
  
      for my $var_name (keys %{$expansion}) {
          my @values = $self->clean_variable_repetitions($expansion->{$var_name});
  
          eval { $expansion->{$var_name} = join(':', @values) };
          if($@) {
              warn("Environment variable '$var_name' was not explicitely set.\n");
          }
      }
  
      my @ordered = $self->order_variables($expansion);
  
      for my $var_name (@ordered) {
          my $value = $expansion->{$var_name};
  
          # if value already starts with quotes, don't add quotes.
          if($value =~ qr/^\s*("|')/) {
              print { $sh_f } "export $var_name=$value\n";
          } else {
              print { $sh_f } "export $var_name=\"$value\"\n";
          }
      }
  
      print { $sh_f } "\n";
  }
  
  sub clean_variable_repetitions {
      my ($self, $ref) = @_;
  
      my @values = @$ref;
  
      my %metric;
      my $count = 1;
      my $root = $self->root_dir;
  
      for my $v (@values) {
          if($v !~ m%^/(usr/(local/)?)?(bin|lib)$%) {
              $metric{$v} = $count;
          } elsif ($v =~ m%^$root%) {
              $metric{$v} = $count;
          } else {
              $metric{$v} = $count + @values;
          }
          $count++;
      }
  
      return sort { $metric{$a} <=> $metric{$b} } keys %metric;
  }
  
  sub order_variables {
      my ($self, $expansion) = @_;
  
      my @alpha = sort { $a cmp $b } keys %{$expansion};
  
      my $order = {};
  
      my $index = 1;
      for my $var (@alpha) {
          $order->{$var} = $index;
          $index++;
      }
  
      my $total_passes = 0;
      my $swap       = 1;
  
      while($swap) {
          $swap = 0;
  
          my @ordered = sort { ($order->{$a} <=> $order->{$b}) || ($a cmp $b) } keys %{$expansion};
  
          for my $var (@ordered) {
              my $value = $expansion->{$var};
              my @deps  = ($value =~ m/\$\{(\w+)\}/g);
  
              next unless @deps;
  
              my $org   = $order->{$var};
              my $nxt   = 1 + max(map { $order->{$_} || warn "Variable '$_' is not explicitely set.\n" } @deps);
  
              if($nxt > $org) {
                  $swap++;
                  $order->{$var} = $nxt;
              }
          }
  
          $total_passes++;
          carp "Cyclic dependency in environment variables." if $total_passes > @alpha;
      }
  
      my @ordered = sort { ($order->{$a} <=> $order->{$b}) || ($a cmp $b) } keys %{$expansion};
      return @ordered;
  }
  
  
  sub set_profile {
      my ($self, $profile_file, @command_and_args) = @_;
  
      my ($env_file, $prog_file, $wrap_file, $pay_file) = map { $profile_file . $_ } ('.env', '.prologue', '.wrapper', '.payload');
      
      # write to env file
      open(my $sh_f_env, '>', $env_file)
      || die "Could not open file $env_file $!";
      print { $sh_f_env } <<EOFP;
  #! @{[$self->shell_executable]}
  
  # don't load environment variables repeatedly (e.g., to not grow PATH at every shell)
  if [ ! "\${VC3_ENV_TAG_GLOBAL}" = $$ ]
  then
  
  EOFP
      $self->set_environment_variables($sh_f_env);
  
      print { $sh_f_env } <<EOFP;
  export VC3_ENV_TAG_GLOBAL=$$
  fi
  
  EOFP
  
      close($sh_f_env);
  
      # write to prologue file
      open(my $sh_f_prog, '>', $prog_file)
      || die "Could not open file $prog_file $!";
      print { $sh_f_prog } <<EOFP;
  #! @{[$self->shell_executable]}
  
  # don't source prologues at a shell that already sourced them.
  if [ ! "\${VC3_ENV_TAG_LOCAL}" = $$ ]
  then
  
  EOFP
  
      for my $prog_line (@{$self->consolidate_prologue}) {
          print { $sh_f_prog } "$prog_line";
          print { $sh_f_prog } "\n";
      }
  
      print { $sh_f_prog } <<EOFP;
  
      VC3_ENV_TAG_LOCAL=$$
  fi
  
  EOFP
  
      # write to general profile
      open(my $sh_f, '>', "$profile_file")
      || die "Could not open file $profile_file $!";
  
      print { $sh_f } <<EOFP;
  #! @{[$self->shell_executable]}
  
  . $env_file
  . $prog_file
  
  EOFP
      close($sh_f);
  
      # write to payload file
      open(my $sh_f_pay, '>', $pay_file)
      || die "Could not open file $pay_file $!";
  
      print { $sh_f_pay } <<EOFP;
  #! @{[$self->shell_executable]}
  
  if [ "\${VC3_INSIDE_WRAPPER_SCRIPT}" != yes ]
  then
  
      echo This script cannot be executed by itself.
      echo Run instead: ${wrap_file}
      exit 1
  fi
  
  # load profile for further interactive shells.
  export ENV=$profile_file
  
  # load profile if the exec below is not interactive
  . $profile_file
  
  EOFP
  
      print { $sh_f_pay } join(' ', 'exec', @command_and_args);
      print { $sh_f_pay } "\n";
  
      close($sh_f_pay);
      chmod 0755, $pay_file;
  
      # write to wrapper file
      open(my $sh_f_wrap, '>', "$wrap_file")
      || die "Could not open file $wrap_file $!";
  
      print { $sh_f_wrap } <<EOFP;
  #! @{[$self->shell_executable]}
  
  . $env_file
  
  export VC3_INSIDE_WRAPPER_SCRIPT=yes
  cd  "\${HOME}"
  
  EOFP
  
      my @payload = ($pay_file);
  
      my $env = $self->active_widgets();
      if($self->plan and $self->plan->order) {
          for my $w (@{$self->plan->order}) {
              next unless $env->{$w};
              next unless $w->wrapper;
  
              my @wrap = @{$w->wrapper};
              my $braces_pos = first { $wrap[$_] eq '{}' } 0..$#wrap;
  
              if(defined($braces_pos)) {
                  my @tmp = @payload;
                  @payload = @wrap;
                  splice @payload, $braces_pos, 1, @tmp;
              } else {
                  @payload = (@wrap, @payload);
              }
          }
      }
  
      print { $sh_f_wrap } "exec @payload\n\n";
  
      close($sh_f_wrap);
      chmod 0755, $wrap_file;
  
      $self->add_builder_variable('VC3_SH_PROFILE_ENV',     $profile_file);
      $self->add_builder_variable('VC3_SH_PROFILE_WRAPPER', $wrap_file);
  }
  
  sub consolidate_prologue {
      my ($self) = @_;
  
      my $env = $self->active_widgets();
  
      my @progs = ();
  
      if($self->plan and $self->plan->order) {
          for my $w (@{$self->plan->order}) {
              next unless $env->{$w};
  
              if($w->prologue) {
                  push @progs, @{$w->prologue};
              }
          }
      }
  
      return \@progs;
  }
  
  sub preserved_vars {
      my ($self) = @_;
  
      my %to_preserve;
  
      $to_preserve{HOME} = $self->home_dir;
      $to_preserve{USER} = $self->user_name;
  
      my @output;
  
      for my $var (keys %to_preserve) {
          push @output, "$var=$to_preserve{$var}";
      }
  
      return @output;
  }
  
  
  sub execute {
      my ($self, @command_and_args) = @_;
  
      $self->set_profile($self->sh_profile, @command_and_args);
  
      my $pid = fork();
  
      if($pid == 0) {
          my @args = (
              '/usr/bin/env',
              '-i',
              $self->preserved_vars(),
              $self->sh_profile . '.wrapper');
  
          POSIX::setpgid(0, 0);
  
          exec { $args[0] } @args;
          die 'Could not exec payload';
      } elsif($pid > 0) {
  
          close(STDIN);
          POSIX::setpgid($pid, $pid);
  
          if($self->{on_terminal}) {
              $self->bring_to_foreground($pid);
          }
  
          $self->{child_pid} = $pid;
          waitpid $pid, 0;
          my $status = $?;
          $self->{child_pid} = undef;
  
          return POSIX::WEXITSTATUS($status);
      } else {
          die 'Could not fork to exec payload: ' . $!;
      }
  }
  
  sub bring_to_foreground {
      my ($self, $groupid) = @_;
  
      $SIG{TTOU} = 'IGNORE';
  
      open my $term, '+<', '/dev/tty';
      return unless $term;
  
      POSIX::tcsetpgrp(fileno($term), $groupid) or die "Could not bring child to foreground: $!";
  
      close $term;
  }
  
  sub shell {
      my ($self, $payload) = @_;
  
      $payload |= $self->shell_executable;
      $self->set_profile($self->sh_profile, $payload);
  
      my $pid = open(my $input, '|-');
      if($pid == 0) {
          my @args = (
              '/usr/bin/env',
              '-i',
              $self->preserved_vars(),
              $self->sh_profile . '.wrapper');
          exec { $args[0] } @args;
          die 'Could not exec shell';
      } elsif($pid > 0) {
          $self->{child_pid} = $pid;
          # wait for this shell later.
      } else {
          die 'Could not fork to exec payload: ' . $!;
      }
  
      return ($pid, $input);
  }
  
  sub shell_user {
      my ($self) = @_;
      return $self->execute($self->shell_executable);
  }
  
  sub say {
      my ($self, @rest) = @_;
  
      return if($self->{silent_run} and $self->{silent_run} eq 'ALL');
  
      print( ('.' x ($self->{indent_level} || 0)), join(' ', @rest), "\n");
  }
  
  sub say_plan {
      my ($self, @rest) = @_;
  
      return if($self->{silent_run} and $self->{silent_run} eq 'plan');
  
      $self->say(@rest);
  }
  
  1;
  
VC3_BAG

$fatpacked{"VC3/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_PACKAGE';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use warnings;
  use strict;
  
  package VC3::Package;
  use Carp;
  use File::Temp;
  use File::Spec::Functions qw/catfile rel2abs/;
  
  use VC3::Widget;
  
  sub new {
      my ($class, $bag, $name, $json_description) = @_;
  
      my $self = bless {}, $class;
  
      $self->original_description(\%{$json_description});
  
      $self->bag($bag);
      $self->name($name);
      $self->dependencies($json_description->{dependencies});
      $self->wrapper($json_description->{wrapper});
      $self->prologue($json_description->{prologue});
      $self->options($json_description->{options});
      $self->environment_variables($json_description->{'environment-variables'});
      $self->environment_autovars($json_description->{'environment-autovars'});
      $self->phony($json_description->{phony});
  
      $json_description->{'type'} ||= 'package';
      $self->type($json_description->{'type'});
  
      $self->show_in_list($json_description->{'show-in-list'});
      $self->tags($json_description->{'tags'});
  
      if($json_description->{versions}) {
          $self->widgets($json_description->{versions});
      } else {
          $self->{widgets} = [];
      }
  
      return $self;
  }
  
  sub to_hash {
      my ($self) = @_;
  
      my $ph = {};
  
      $ph->{phony}     = $self->phony;
      $ph->{prologue}  = $self->prologue;
      $ph->{wrapper}   = $self->wrapper;
      $ph->{options}   = $self->options;
      $ph->{type}      = $self->type;
  
      # environment-autovars already included in environment-variables
      # environment-variables already included in widgets
      # dependencies included in widgets
      
      $ph->{'versions'}       = [];
  
      for my $w (@{$self->widgets}) {
          push @{$ph->{versions}}, $w->to_hash;
      }
  
      for my $k (keys %{$ph}) {
          unless(defined $ph->{$k}) {
              delete $ph->{$k};
          }
      }
  
      return $ph;
  }
  
  
  sub widgets {
      my ($self, $new_widgets_spec) = @_;
  
      if($new_widgets_spec) {
          my @widgets;
          for my $s (@{$new_widgets_spec}) {
              my $w = VC3::Widget->new($self, $s);
              push @widgets, $w if $w;
          }
  
          $self->{widgets} = \@widgets;
      }
  
      return $self->{widgets};
  }
          
  
  sub name {
      my ($self, $new_name) = @_;
  
      if($new_name) {
          # names can only contain letters, numbers, - and _.
          my @badchars = ($new_name =~ /([^A-Za-z0-9-_])/g);
          if(@badchars) {
              die "The name '$new_name' containes the following disallowed charactares: " 
              . join ', ', map { "'$_'" } @badchars;
          } else {
              $self->{name} = $new_name if($new_name);
          }
      }
  
      die 'No name given'
      unless($self->{name}); 
  
      return $self->{name};
  }
  
  sub original_description {
      my ($self, $new_original) = @_;
  
      $self->{original_description} = $new_original if($new_original);
  
      return $self->{original_description};
  }
  
  sub dependencies {
      my ($self, $new_dependencies) = @_;
  
      $self->{dependencies} = $new_dependencies if($new_dependencies);
  
      return $self->{dependencies};
  }
  
  sub prologue {
      my ($self, $new_prologue) = @_;
  
      $self->{prologue} = $new_prologue if($new_prologue);
  
      return $self->{prologue};
  }
  
  sub wrapper {
      my ($self, $new_wrapper) = @_;
  
      $self->{wrapper} = $new_wrapper if($new_wrapper);
  
      return $self->{wrapper};
  }
  
  sub options {
      my ($self, $new_options) = @_;
  
      $self->{options} = $new_options if($new_options);
  
      return $self->{options};
  }
  
  sub environment_variables {
      my ($self, $new_vars) = @_;
  
      $self->{environment_variables} ||= [];
  
      if($new_vars) {
          unshift @{$self->{environment_variables}}, @{$new_vars};
      }
  
      return $self->{environment_variables};
  }
  
  sub environment_autovars {
      my ($self, $new_autovars) = @_;
  
      $self->{environment_autovars} = $new_autovars if($new_autovars);
  
      return $self->{environment_autovars};
  }
  
  sub bag {
      my ($self, $new_bag) = @_;
  
      $self->{bag} = $new_bag if($new_bag);
  
      croak 'No bag given'
      unless($self->{bag}); 
  
      return $self->{bag};
  }
  
  sub phony {
      my ($self, $new_phony) = @_;
  
      $self->{phony} = $new_phony if(defined $new_phony);
  
      return $self->{phony};
  }
  
  sub show_in_list {
      my ($self, $new_show) = @_;
  
      $self->{show_in_list} = $new_show if(defined $new_show);
  
      return $self->{show_in_list};
  }
  
  sub tags {
      my ($self, $new_tags) = @_;
  
      $self->{tags} = $new_tags if($new_tags);
  
      return $self->{tags};
  }
  
  sub type {
      my ($self, $new_type) = @_;
  
      $self->{type} = $new_type if($new_type);
  
      return $self->{type}
  }
  
  1;
  
VC3_PACKAGE

$fatpacked{"VC3/Plan.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_PLAN';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Plan;
  use File::Spec::Functions qw/catfile rel2abs/;
  use JSON::Tiny;
  
  use VC3::Plan::Element;
  
  sub new {
      my ($class, $bag, $parent) = @_;
  
      my $self = bless {}, $class;
  
      $self->bag($bag);
  
      $self->elements($parent && $parent->elements || {});
  
      return $self;
  }
  
  sub bag {
      my ($self, $new) = @_;
  
      if($new) {
          $self->{bag} = $new;
      }
  
      return $self->{bag};
  }
  
  sub say {
      my ($self, @rest) = @_;
  
      return $self->bag->say_plan(@rest);
  }
  
  sub elements {
      my ($self, $new) = @_;
  
      if($new) {
          $self->{elements} = \%{ $new };
      }
  
      return $self->{elements};
  }
  
  sub element_of {
      my ($self, $name) = @_;
  
      return $self->elements->{$name};
  }
  
  sub requirements {
      my ($self) = @_;
  
      unless($self->{requirements}) {
          $self->{requirements} = [];
      }
  
      return $self->{requirements};
  }
  
  sub add_target {
      my ($self, $name, $min, $max) = @_;
  
      $self->bag->{indent_level}++;
  
      $self->say("Plan:    $name => [@{[$min || '']}, @{[$max || '']}]");
  
      # if this target has been already added, we check that versions are congruent
      my $p = $self->elements->{$name};
      if($p) {
          my $e = $self->refine($p->widget, $p, $min, $max);
  
          if($e) {
              $self->elements->{$name} = $e;
              $self->say("Using:   $name => [@{[$e->min || '']}, @{[$e->max || '']}]");
              $self->bag->{indent_level}--;
              return 1;
          }
      }
  
      my $available = $self->bag->widgets_of($name);
      for my $widget (@{$available}) {
  
          unless($widget->available) {
              next;
          }
  
          # This is a naive search!
          # We also want to check for different order of targets.
          if($self->add_widget($widget, $min, $max)) {
              $self->bag->{indent_level}--;
              return 1;
          }
      }
  
      $self->say("Failure: $name => [@{[$min || '']}, @{[$max || '']}]");
      $self->bag->{indent_level}--;
  
      return 0;
  }
  
  sub operating_system {
      my ($self, $new_os) = @_;
  
      $self->{operating_system} = $new_os if($new_os);
  
      return $self->{operating_system};
  }
  
  sub add_main_targets {
      my ($self, @requires) = @_;
  
      my $root_entry = { version => version->declare('v0.0.1'), phony => 1, dependencies => {} };
  
      for my $req (@requires) {
          my ($name, $min, $max) = $self->parse_requirement($req);
  
          my $versions = [$min, $max];
  
          $root_entry->{dependencies}{$name} = $versions;
          
          unless($self->add_target($name, $min, $max)) {
              die "Could not find plan for $req.\n";
          }
  
          push @{$self->requirements}, $name;
      }
  
      return 1;
  }
  
  sub parse_requirement {
      my ($self, $req) = @_;
  
      $req =~ m/
      ^
      (?<name> [A-z0-9_-]+)
      (:v?                      # start of min version
      (?<min> [^:]*)
      (:v?                    # start of max version
      (?<max> [^:]*)
      )?)?
      $
      /x;
  
      my ($name, $min, $max) = ($+{name}, $+{min}, $+{max});
  
      if($min) {
          if($min eq 'auto') {
              undef $min;
          } else {
              my ($M, $m, $b) = ($min =~ m/^v?([0-9]+)\.?([0-9]+)?\.?([0-9]+)?/);
              
              $m = '0' unless defined($m);
              $b = '0' unless defined($b);
  
              $min = "v$M.$m.$b";
          }
      }
  
      if($max) {
          if($max eq 'auto') {
              undef $max;
          } else {
              my ($M, $m, $b) = ($max =~ m/^v?([0-9]+)\.?([0-9]+)?\.?([0-9]+)?/);
              
              $m = '999999' unless defined($m);
              $b = '999999' unless defined($b);
  
              $max = "v$M.$m.$b";
          }
      }
  
      if(!$min && $max) {
          $min = 'v0.0.1';
      }
  
      # turn into version strings
      eval {
          $min = version->declare($min) if($min);
          $max = version->declare($max) if($max);
      };
      if($@) {
          die "Versions should be of the form: MAJOR.MINOR.REVISION\n";
      }
  
  
      return ($name, $min, $max);
  }
  
  sub version_str {
      my ($self, $v) = @_;
  
      return ''         unless $v;
      return $v->normal if $v->isa('version');
      return version->parse($v)->normal;
  }
  
  sub add_widget {
      my ($self, $widget, $min, $max) = @_;
  
      my $version = $widget->version;
  
      $self->say("Try:     " . $widget->package->name . " => @{[$version->normal]}");
  
      if($min && $min gt $version || $max && $max lt $version) {
          $self->say("Incorrect version: @{[$version->normal]} => [@{[$self->version_str($min)]},@{[$self->version_str($max)]}]");
          return 0;
      }
  
      my $saved_state = $self->elements();
  
      my $p = $self->elements->{$widget->package->name};
      my $e = $self->refine($widget, $p, $min, $max);
  
      my $success;
      if($p && !$e) {
          $self->say("conflicting versions: @{[$widget->package->name]} [@{[ $self->version_str($p->{min}) ]}, @{[ $self->version_str($p->{max})]} <=> [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
          $success = 0;
      } elsif(!$e) {
          $success = 0;
          die('bug, this should not happen.');
      } else {
          $self->say("Refining version: @{[$widget->package->name, $version]} => [@{[$self->version_str($e->{min})]}, @{[$self->version_str($e->{max})]}]");
          if($self->add_dependencies($widget->dependencies)) {
              if($widget->source) {
                  my $s = $self->add_source($widget->source);
                  if($s) {
                      $success = 1;
                  } else {
                      $self->say("could not add source for: @{[$widget->package->name, $version]} => [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
                      $success = 0;
                  }
              } else {
                  $success = 1;
              }
          } else {
              $self->say("could not set dependencies for: @{[$widget->package->name]} @{[$version->normal]} => [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
              $success = 0;
          }
      }
  
      if($success) {
          # add new step to plan
          $self->elements->{$widget->package->name} = $e;
          $self->say("Success: @{[$widget->package->name]} @{[$e->widget->version->normal]} => [@{[$self->version_str($min)]}, @{[$self->version_str($max)]}]");
      } else {
          # restore old plan on error
          $self->elements($saved_state);
      }
  
      return $success;
  }
  
  sub add_dependencies {
      my ($self, $dependencies) = @_;
  
      my $saved_state = $self->elements();
  
      my $success = 1;
      for my $name (keys %{$dependencies}) {
  
          my ($min, $max) = @{$dependencies->{$name}};
          unless($self->add_target($name, $min, $max)) {
              $success = 0;
              last;
          }
      }
  
      unless($success) {
          $self->elements($saved_state);
      }
  
      return $success;
  }
  
  sub add_source {
      my ($self, $source) = @_;
  
      my $saved_state = $self->elements();
  
      if($source->isa('VC3::Source::System')) {
          return if $self->bag->{no_system}{ALL};
          return if $self->bag->{no_system}{$source->widget->package->name};
      }
  
      my $exit_status = -1;
      eval { $exit_status = $source->check_prerequisites() };
  
      if($exit_status) {
          $self->say("Fail-prereq: " . $source->widget->package->name . '-' . $source->widget->version->normal);
          return undef;
      }
  
      if($self->add_dependencies($source->dependencies)) {
          return $source;
      }
  
      $self->elements($saved_state);
      return undef;
  }
  
  
  sub refine {
      my ($self, $widget, $p, $min, $max) = @_;
  
      my $e = VC3::Plan::Element->new($widget, $min, $max);
  
      if($p) {
          return $e->refine($min, $max);
      } else {
          return $e;
      }
  }
  
  sub order {
      my ($self, $set) = @_;
  
      if($set) {
          my $ordinals = $self->order_aux();
          my @ordered = sort { ($ordinals->{$a} <=> $ordinals->{$b}) || ($a cmp $b) } keys %{$ordinals};
          $self->{order} = [ map { $self->elements->{$_}{widget} } @ordered ];
      }
  
      return $self->{order};
  }
  
  sub order_aux {
      my ($self) = @_;
  
      my $ordinal_of = {};
  
      my @names = keys %{$self->elements};
  
      for my $name (@names) {
          $ordinal_of->{$name} = 1;
      }
  
      my $to_go = @names;
  
      while($to_go >= 0) {
          my $change = 0;
  
          $to_go--;
  
          for my $name (@names) {
              my $e = $self->elements->{$name};
              my $o = $ordinal_of->{$name};
  
              my @deps;
  
              my $w = $e->{widget};
  
              if($w->dependencies) {
                  push @deps, keys %{$w->dependencies};
              }
  
              if($w->source->dependencies) {
                  push @deps, keys %{$w->source->dependencies};
              }
  
              my $max = $o;
              if(@deps) {
                  $max = 1 + List::Util::max( @{$ordinal_of}{@deps} );
              }
  
              if($max != $o) {
                  $change = 1;
                  $ordinal_of->{$w->package->name} = $max;
              }
          }
  
          if(!$change) {
              return $ordinal_of;
          }
      }
  
      die 'Circular dependency found';
  }
  
  sub dot_graph {
      my ($self, $dotname) = @_;
      my @names = keys %{$self->elements};
  
      open(my $dot_f, '>', $dotname) 
      || die "Could not open '$dotname': $!";
  
      print { $dot_f } "digraph {\n";
  
      print { $dot_f } "node [shape=record];\n";
  
      for my $name (@names) {
          my $e = $self->elements->{$name};
          my $w = $e->{widget};
          my $v = $w->version->normal;
  
          my $n = $name;
          $n =~ s/[^A-z0-9]//g;
  
          print { $dot_f } qq($n [label="$name&#92;n$v"];\n);
      }
  
      for my $name (@names) {
          my @deps;
  
          my $e = $self->elements->{$name};
          my $w = $e->{widget};
  
          if($w->dependencies) {
              push @deps, keys %{$w->dependencies};
          }
  
          if($w->source->dependencies) {
              push @deps, keys %{$w->source->dependencies};
          }
  
          my $n = $name;
          $n =~ s/[^A-z0-9]//g;
  
          if(@deps) {
              for my $dep (@deps) {
                  my $d = $dep;
                  $d =~ s/[^A-z0-9]//g;
  
                  print { $dot_f } qq(\t"$d"->"$n";\n);
              }
          }
      }
  
      print { $dot_f } "}\n";
      close $dot_f;
  }
  
  sub to_makeflow {
      my ($self, $dir, $dag_name, $builder_exec, $local_database, $cores) = @_;
  
      $self->trimmed_database(catfile($dir,$local_database));
  
      my $makeflow_name = $dag_name;
  
      open(my $mflow_f, '>', catfile($dir,$makeflow_name)) 
      || die "Could not open '$dir/$makeflow_name': $!";
  
      print { $mflow_f } ".MAKEFLOW CATEGORY builds\n";
      print { $mflow_f } ".MAKEFLOW CORES    $cores\n";
      print { $mflow_f } ".MAKEFLOW MEMORY   @{[$cores * 512]}\n";
      print { $mflow_f } ".MAKEFLOW DISK     20000\n";    # 20 GB of disk
      print { $mflow_f } "\n\n";
  
      my $bag    = $self->bag;
      my $root   = $bag->root_dir;
      my $target = catfile($bag->root_dir, $bag->target);
  
      my $home   = $bag->home_dir;
      $home      =~ s/^\Q$root/\$(ROOT_DIR)/;
  
      print { $mflow_f } "RECIPES  = $local_database\n";
      print { $mflow_f } "ROOT_DIR = $root\n";
      print { $mflow_f } "TRGT_DIR = \$(ROOT_DIR)/@{[$bag->target]}\n";
      print { $mflow_f } "HOME_DIR = $home\n";
      print { $mflow_f } "DIST_DIR = " . $bag->files_dir  . "\n";
      print { $mflow_f } "REPO     = " . $bag->repository . "\n";
      print { $mflow_f } "OPTIONS  = --silent=plan --make-jobs \$(CORES) --no-run\n\n";
  
      print { $mflow_f } "RIBBON   = .VC3_DEPENDENCY_BUILD\n\n";
  
      print { $mflow_f } "\n";
      print { $mflow_f } "BUILD_COMMAND  = ./$builder_exec --database \$(RECIPES) --install \$(ROOT_DIR) --home \$(HOME_DIR) --distfiles \$(DIST_DIR) --repository \$(REPO) \$(OPTIONS) --ignore-locks\n";
  
      print { $mflow_f } "\n\n";
      
      my @names = keys %{$self->elements};
      for my $name (@names) {
          my @deps;
  
          my $e = $self->elements->{$name};
          my $w = $e->{widget};
  
          if($w->dependencies) {
              push @deps, keys %{$w->dependencies};
          }
  
          if($w->source && $w->source->dependencies) {
              push @deps, keys %{$w->source->dependencies};
          }
  
          my @inputs;
          for my $d (@deps) {
              my $rname = $self->elements->{$d}->{widget}->ribbon->{filename};
  
              $rname =~ s/.VC3_DEPENDENCY_BUILD$/\$(RIBBON)/;
              $rname =~ s/^\Q$target/\$(TRGT_DIR)/;
  
              push @inputs, $rname;
          }
  
          my $output = $w->ribbon->{filename};
          $output =~ s/.VC3_DEPENDENCY_BUILD$/\$(RIBBON)/;
          $output =~ s/^\Q$target/\$(TRGT_DIR)/;
  
          print { $mflow_f } "$output: $builder_exec $local_database @inputs\n";
  
          print { $mflow_f } "\t";
  
          if(!$w->source || $w->local) {
              print { $mflow_f } "LOCAL "
          }
  
          print { $mflow_f } "\t\$(BUILD_COMMAND) --require $name\n\n";
      }
  
      close $mflow_f;
  }
  
  sub prestage {
      my ($self) = @_;
  
      for my $e (values %{$self->elements}) {
          $e->widget->source->get_files();
      }
  }
  
  sub trimmed_database {
      my ($self, $filename) = @_;
  
      my $output = {};
  
      for my $e (values %{$self->elements}) {
          my $ph = $e->widget->package->to_hash;
          $ph->{versions} = [ $e->widget->to_hash ];
  
          $output->{$e->widget->package->name} = $ph;
      }
  
      open my $f_h, '>', $filename || die "Could not open $filename for writing: $!\n";
  
      my $json = JSON::Tiny::encode_json($output);
  
      print { $f_h } $json, "\n";
  
      close $f_h;
  }
  
  sub to_script {
      my ($self, $filename) = @_;
  
      open my $f_h, '>', $filename || die "Could not open $filename for writing: $!\n";
  
      for my $w (@{$self->order}) {
          $self->bag->activate_widget_vars($w);
          $self->bag->set_environment_variables($f_h);
          $self->bag->activate_widget($w);
      }
  
      close $f_h;
  }
  
  
  package version;
  sub TO_JSON {
      my ($self) = @_;
      return $self->normal;
  }
  
  1;
  
VC3_PLAN

$fatpacked{"VC3/Plan/Element.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_PLAN_ELEMENT';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Plan::Element;
  
  sub new {
      my ($class, $widget, $min, $max) = @_;
  
      my $self = bless {}, $class;
  
      if($min && $max && $min gt $max) {
          die 'Incompatible versions';
      }
  
      $self->{widget} = $widget;
      $self->{min}    = $min;
      $self->{max}    = $max;
  
      return $self;
  }
  
  sub widget {
      my ($self, $new) = @_;
  
      if($new) {
          $self->{widget} = $new;;
      }
  
      return $self->{widget};
  }
  
  sub min {
      my ($self, $new) = @_;
  
      if($new) {
          $self->{min} = $new;
      }
  
      return $self->{min};
  }
  
  sub max {
      my ($self, $new) = @_;
  
      if($new) {
          $self->{max} = $new;
      }
  
      return $self->{max};
  }
  
  sub refine {
      my ($self, $new_min, $new_max) = @_;
  
      if($new_min && $self->{max} && $new_min gt $self->{max}) {
          return undef;
      }
  
      if($new_max && $self->{min} && $new_max lt $self->{min}) {
          return undef;
      }
  
      # take the more restrictive min
      my $min = $new_min || $self->{min};
      if($new_min && $self->{min}) {
          $min = $new_min lt $self->{min} ? $self->{min} : $new_min;
      }
  
      # take the more restrictive max
      my $max = $new_max || $self->{max};
      if($new_max && $self->{max}) {
          $max = $new_max lt $self->{max} ? $new_max : $self->{max};
      }
  
      if($min && $min gt $self->{widget}->version) { 
          return undef;
      }
  
  
      if($max && $max lt $self->{widget}->version) {
          return undef;
      }
          
      return VC3::Plan::Element->new($self->{widget}, $min, $max);
  }
  
  1;
  
VC3_PLAN_ELEMENT

$fatpacked{"VC3/Ribbon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_RIBBON';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Ribbon;
  
  use File::Basename; 
  use LockFile::Simple qw(lock unlock);
  use File::Spec::Functions qw/catfile rel2abs/;
  
  sub new {
      my ($class, $name, $install_dir, $tmpdir, $checksum) = @_;
  
      my $self = bless {}, $class;
  
      $self->{filename} = catfile($install_dir, '.VC3_DEPENDENCY_BUILD');
      $self->{lockname} = catfile($tmpdir, $name . '.lock');
      $self->{checksum} = $checksum;
  
      $self->{lockmgr} = LockFile::Simple->make(-hold => 3600, -autoclean => 1, -max => 99999, -delay => 5, -stale => 1, -wmin => 2,
          -wfunc => sub { LockFile::Simple::core_warn("Waiting for a lock for '$name'. If you think this lock is stale, please remove the file:\n'" . $self->{lockname} . "'\n") }
      );
  
      return $self;
  }
  
  sub commit {
      my ($self, $state) = @_;
  
      my $ribbon_fh = IO::Handle->new();
      open ($ribbon_fh, '>', $self->{filename});
  
      my $report = {};
      $report->{state}    = $state;
      $report->{checksum} = $self->{checksum};
      $report->{time}     = time();
  
      printf { $ribbon_fh } JSON::Tiny::encode_json($report);
  
      $ribbon_fh->flush();
      $ribbon_fh->sync();
  
      $ribbon_fh->close();
  }
  
  sub set_lock {
      my ($self) = @_;
  
      # make sure parent directory exists
      File::Path::make_path( dirname($self->{filename}) );
  
      $self->{lockobj} = $self->{lockmgr}->lock($self->{filename}, $self->{lockname});
  }
  
  sub release_lock {
      my ($self) = @_;
      $self->{lockobj}->release();
  }
  
  sub state {
      my ($self) = @_;
  
      my $name = $self->{filename};
      my $state = 'MISSING';
  
      if(-f $name) {
          open my $ribbon_fh, '<', $name || warn $!;
  
          if($ribbon_fh) {
              my $contents = do { local($/); <$ribbon_fh> };
              close($ribbon_fh);
  
              my $report;
              eval { $report = JSON::Tiny::decode_json($contents) };
              if($@) {
                  $state = 'MISSING';
              }
  
              if(!$report->{state}) {
                  $state = 'MISSING';
              } elsif(!$report->{checksum}) {
                  $state = 'MISSING';
              } elsif($report->{checksum} ne $self->{checksum}) {
                  $state = 'OUT_OF_DATE';
              } elsif($report->{state} eq 'PROCESSING') {
                  $state = 'PROCESSING';
              } else {
                  $state = $report->{state};
              }
          }
      }
  
  
      return $state;
  }
  
  1;
  
VC3_RIBBON

$fatpacked{"VC3/Source.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source;
  use Carp;
  
  use VC3::Source::Generic;
  use VC3::Source::Configure;
  use VC3::Source::CMake;
  use VC3::Source::Tarball;
  use VC3::Source::ManualDist;
  use VC3::Source::Binary;
  use VC3::Source::System;
  use VC3::Source::Perl;
  use VC3::Source::Container::Singularity;
  use VC3::Source::Container::Docker;
  use VC3::Source::OSNative;
  
  our $class_of = {};
  
  $class_of->{'generic'}             = 'VC3::Source::Generic';
  $class_of->{'configure'}           = 'VC3::Source::Configure';
  $class_of->{'cmake'}               = 'VC3::Source::CMake';
  $class_of->{'tarball'}             = 'VC3::Source::Tarball';
  $class_of->{'manual-distribution'} = 'VC3::Source::ManualDist';
  $class_of->{'binary'}              = 'VC3::Source::Binary';
  $class_of->{'system'}              = 'VC3::Source::System';
  $class_of->{'cpan'}                = 'VC3::Source::Perl';
  $class_of->{'singularity'}         = 'VC3::Source::Container::Singularity';
  $class_of->{'docker'}              = 'VC3::Source::Container::Docker';
  $class_of->{'os-native'}           = 'VC3::Source::OSNative';
  
  sub new {
      my ($widget, $source_raw) = @_;
  
      my $type  = $source_raw->{type} || 'generic';
      my $class = $class_of->{$type};
  
      unless($class) {
          die "Do not know about source type '" . $source_raw->{type} . "' for '" . $widget->package->name . "'\n";
      }
  
      return $class->new($widget, $source_raw);
  }
  
  1;
  
VC3_SOURCE

$fatpacked{"VC3/Source/AutoRecipe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_AUTORECIPE';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::AutoRecipe;
  use base 'VC3::Source::Tarball';
  use Carp;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      # dummy recipe, so Tarball does not complain.
      $json_description->{recipe} = ['dummy'];
  
      my $self = $class->SUPER::new($widget, $json_description);
  
      $self->preface($json_description->{preface});
      $self->options($json_description->{options});
      $self->postface($json_description->{postface});
  
      my @steps;
      if($self->preface) {
          push @steps, @{$self->preface};
      }
  
      push @steps, @{$self->autorecipe};
  
      if($self->postface) {
          push @steps, @{$self->postface};
      }
  
      $self->recipe(\@steps);
  
      return $self;
  }
  
  sub to_hash {
      my ($self) = @_;
  
      my $sh = $self->SUPER::to_hash();
      $sh->{preface}  = $self->preface;
      $sh->{options}  = $self->options;
      $sh->{postface} = $self->postface;
  
      # automatically computed, so we delete it.
      delete $sh->{recipe};
  
      for my $k (keys %{$sh}) {
          unless(defined $sh->{$k}) {
              delete $sh->{$k};
          }
      }
  
      return $sh;
  }
  
  sub preface {
      my ($self, $new_preface) = @_;
  
      $self->{preface} = $new_preface if($new_preface);
  
      return $self->{preface};
  }
  
  sub postface {
      my ($self, $new_postface) = @_;
  
      $self->{postface} = $new_postface if($new_postface);
  
      return $self->{postface};
  }
  
  sub options {
      my ($self, $new_options) = @_;
  
      $self->{options} = $new_options if($new_options);
  
      return $self->{options};
  }
  
  sub autorecipe {
      die 'No autorecipe defined.';
  }
  
  1;
  
VC3_SOURCE_AUTORECIPE

$fatpacked{"VC3/Source/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_BINARY';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Binary;
  use base 'VC3::Source::Generic';
  use Carp;
  # Right now, do the same as generic, but ensure we do it locally in parallel builds.
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      $widget->local(1);
  
      unless($json_description->{prerequisites}) {
          if($json_description->{native}) {
              $json_description->{prerequisites} = [
                  ": check if native is prefix of target",
                  'pref=${VC3_MACHINE_TARGET#' . $json_description->{native} . '}',
                  '[ "$pref" != ${VC3_MACHINE_TARGET} ] || exit 1'
              ];
          }
      }
  
      unless($json_description->{recipe}) {
          $json_description->{recipe} = [
              'mkdir -p ${VC3_PREFIX}',
              'for file in $VC3_FILES; do',
              '   tar -C ${VC3_PREFIX} --strip-components=1 -xf $file',
              'done'
          ]
      }
  
      return $class->SUPER::new($widget, $json_description);
  }
  
  1;
  
VC3_SOURCE_BINARY

$fatpacked{"VC3/Source/CMake.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_CMAKE';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::CMake;
  use base 'VC3::Source::AutoRecipe';
  use Carp;
  
  sub autorecipe {
      my ($self) = @_;
  
      $self->{dependencies}{'cmake'} ||= ['v3.5.0'];
  
      my $conf = 'cmake -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX}';
      if($self->options) {
          $conf = join(' ', $conf, $self->options);
      }
  
      $conf .= ' ..';
  
      return [ 'mkdir -p build', 'cd build', $conf, 'make', 'make install' ];
  }
  
  1;
  
VC3_SOURCE_CMAKE

$fatpacked{"VC3/Source/Configure.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_CONFIGURE';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Configure;
  use base 'VC3::Source::AutoRecipe';
  use Carp;
  
  sub autorecipe {
      my ($self) = @_;
  
      my $conf = './configure --prefix ${VC3_PREFIX}';
  
      if($self->options) {
          $conf = join(' ', $conf, $self->options);
      }
  
      return [ $conf, 'make', 'make install' ];
  }
  
  1;
  
VC3_SOURCE_CONFIGURE

$fatpacked{"VC3/Source/Container.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_CONTAINER';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Container;
  use base 'VC3::Source::System';
  use JSON::Tiny;
  use Carp;
  use File::Copy;
  use File::Spec::Functions qw/catfile file_name_is_absolute/;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      if($widget->wrapper) {
          die "Wrapper specified in conflict with '" . $widget->package->name . "'\n";
      }
  
  
      my $self = $class->SUPER::new($widget, $json_description);
  
      # anything with a Container source becomes an operating system
      $self->widget->package->type('operating-system');
  
      my $image = $json_description->{image};
      unless($image) {
          die "No image specified for '" . $widget->package->name . "'\n";
      }
  
      $json_description->{'images-directory'} ||= 'images';
  
      if($image =~ m^://^ or file_name_is_absolute($image)) {
          $self->image($image);
      } else {
          $image = catfile($json_description->{'images-directory'}, $image);
          $self->image(catfile($self->widget->package->bag->files_dir, $image));
          push @{$self->files}, $image;
      }
  
      return $self;
  }
  
  sub setup_wrapper {
      my ($self, $exe, $builder_args, $mount_map) = @_;
  
      die "Container Source did not define a wrapper.\n";
  }
  
  sub to_hash {
      my ($self) = @_;
  
      my $sh = $self->SUPER::to_hash();
      $sh->{image} = $self->image;
  
      # wrapper is generated automatically:
      delete $sh->{wrapper};
  
      return $sh;
  }
  
  sub image {
      my ($self, $new_image) = @_;
  
      $self->{image} = $new_image if($new_image);
  
      unless($self->{image}) {
          die "Container recipe for '" . $self->widget->package->name . "' did not define an 'image' field.\n";
      }
      
      return $self->{image};
  }
  
  sub prepare_recipe_sandbox {
      my ($self, $exe, $builder_args, $payload_args, $mount_map) = @_;
  
      $self->get_files();
  
      my $bag = $self->widget->package->bag;
      my ($root, $home, $files, $tmp) = ($bag->root_dir, $bag->home_dir, $bag->files_dir, $bag->tmp_dir);
  
      my $root_target  = $self->add_mount($mount_map, $bag->root_dir,  '/vc3/vc3-root');
      my $home_target  = $self->add_mount($mount_map, $bag->home_dir,  '/vc3/vc3-home');
      my $files_target = $self->add_mount($mount_map, $bag->files_dir, '/vc3/vc3-distfiles');
  
      my $builder_path = catfile($bag->tmp_dir, 'vc3-builder');
      copy($0, $builder_path);
      chmod 0755, $builder_path;
  
      my $recipe_path = catfile($bag->tmp_dir, 'vc3-recipes');
      copy($bag->sh_profile . '.recipes', $recipe_path);
  
      my @new_builder_args;
      push @new_builder_args, catfile($root_target, 'tmp', 'vc3-builder');
      push @new_builder_args, '--no-os-switch';
      push @new_builder_args, $self->remove_args(@{$builder_args});
      push @new_builder_args, ('--install',   $root_target);
      push @new_builder_args, ('--distfiles', $files_target);
      push @new_builder_args, ('--home',      $home_target);
      push @new_builder_args, ('--database',  catfile($root_target, 'tmp', 'vc3-recipes'));
  
  
      if(scalar @{$payload_args} > 0) {
          push @new_builder_args, '--';
          push @new_builder_args, @{$payload_args};
      }
  
      my $wrapper = $self->setup_wrapper($exe, \@new_builder_args, $mount_map);
  
      $self->widget->wrapper($wrapper);
  }
  
  sub add_mount {
      my ($self, $mount_map, $from, $default_target) = @_;
  
      unless($mount_map->{$from}) {
          $mount_map->{$from} = $default_target;
      }
  
      return $mount_map->{$from};
  }
  
  sub remove_args {
      my ($self, @args) = @_;
  
      my @builder_args;
  
      my $prev_no_equal = 0;
      for my $a (@args) {
          if($prev_no_equal) {
              $prev_no_equal = 0;
              next;
          }
  
          if($a =~ m/^--mount=/) {
              next;
          }
  
          if($a =~ m/^--mount$/) {
              $prev_no_equal = 1;
              next;
          }
  
          if($a =~ m/^--database=/) {
              next;
          }
  
          if($a =~ m/^--database$/) {
              $prev_no_equal = 1;
              next;
          }
  
          push @builder_args, $a;
      }
  
      return @builder_args;
  }
  
  1;
  
VC3_SOURCE_CONTAINER

$fatpacked{"VC3/Source/Container/Docker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_CONTAINER_DOCKER';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Container::Docker;
  use base 'VC3::Source::Container';
  use Carp;
  use File::Copy;
  use File::Spec::Functions qw/catfile file_name_is_absolute/;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      $json_description->{'images-directory'} = 'images/docker';
      my $self = $class->SUPER::new($widget, $json_description);
  
      $self->drop_priviliges($json_description->{'drop-priviliges'});
  
      return $self;
  }
  
  sub drop_priviliges {
      my ($self, $new_drop_priviliges) = @_;
  
      if(defined $new_drop_priviliges) {
          $self->{drop_priviliges} = $new_drop_priviliges;
      }
  
      return $self->{drop_priviliges};
  }
  
  sub setup_wrapper {
      my ($self, $exe, $builder_args, $mount_map) = @_;
  
      my $bag = $self->widget->package->bag;
  
      my @wrapper;
      push @wrapper, $exe;
      push @wrapper, '--require=docker';
      push @wrapper, '--revar=".*"';
      push @wrapper, '--install='    . $self->widget->package->bag->root_dir;
      push @wrapper, '--home='       . $self->widget->package->bag->home_dir;
      push @wrapper, '--distfiles='  . $self->widget->package->bag->files_dir;
      push @wrapper, '--repository=' . $self->widget->package->bag->repository;
  
      push @wrapper, '--';
  
      push @wrapper, 'docker';
      push @wrapper, 'run';
  
      push @wrapper, '--rm=true';
  
      # it would be nice to have this one, but we can't because we need to create
      # the user...
      #push @wrapper, '--read-only';
  
      # for things that need ptrace:
      push @wrapper, ('--security-opt', 'seccomp=unconfined');
  
      if($bag->{on_terminal}) {
          push @wrapper, ('-i', '-t');
      }
  
      for my $from (keys %{$mount_map}) {
          push @wrapper, ('--volume', $from . ':' . $mount_map->{$from});
      }
  
      push @wrapper, ('--tmpfs', '/tmp');
  
      push @wrapper, ('--workdir', $mount_map->{$bag->home_dir()});
  
      if($self->drop_priviliges) {
          push @wrapper, ('--entrypoint', '/sbin/run-with-user');
      }
  
      my $image = $self->image;
      if($image =~ m#^docker://#) {
          $image =~ s#^docker://##;
      } elsif(-f $image) {
          system("docker load -i $image");
      } else {
          die "I don't know how to process '$image'\n";
      }
  
      push @wrapper, $image;
  
      # pass first arguments to run-with-user, if needed
      if($self->drop_priviliges) {
          push @wrapper, ($bag->user_uid, $bag->user_gid);
      }
  
      push @wrapper, @{$builder_args};
  
      return \@wrapper;
  }
  
  1;
  
VC3_SOURCE_CONTAINER_DOCKER

$fatpacked{"VC3/Source/Container/Singularity.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_CONTAINER_SINGULARITY';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Container::Singularity;
  use base 'VC3::Source::Container';
  use Carp;
  use File::Copy;
  use File::Spec::Functions qw/catfile file_name_is_absolute/;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      $json_description->{'images-directory'} = 'images/singularity';
      my $self = $class->SUPER::new($widget, $json_description);
  
      return $self;
  }
  
  sub setup_wrapper {
      my ($self, $exe, $builder_args, $mount_map) = @_;
  
      my @wrapper;
      push @wrapper, $exe;
      push @wrapper, '--require=singularity';
      push @wrapper, '--revar=".*"';
      push @wrapper, '--install='    . $self->widget->package->bag->root_dir;
      push @wrapper, '--home='       . $self->widget->package->bag->home_dir;
      push @wrapper, '--distfiles='  . $self->widget->package->bag->files_dir;
      push @wrapper, '--repository=' . $self->widget->package->bag->repository;
  
      push @wrapper, '--';
  
      push @wrapper, 'singularity';
      push @wrapper, 'exec';
  
      for my $from (keys %{$mount_map}) {
          push @wrapper, ('-B', $from . ':' . $mount_map->{$from});
      }
  
      push @wrapper, $self->image;
  
      push @wrapper, @{$builder_args};
  
      return \@wrapper;
  }
  
  1;
  
VC3_SOURCE_CONTAINER_SINGULARITY

$fatpacked{"VC3/Source/Generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_GENERIC';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Generic;
  use Carp;
  use File::Basename;
  use File::Copy;
  use File::Path;
  use File::Spec::Functions qw/catfile rel2abs/;
  use File::stat;
  use Time::gmtime;
  use HTTP::Tiny;
  use POSIX ":sys_wait_h";
  use parent;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      my $self = bless {}, $class;
  
      $self->widget($widget);
      $self->recipe($json_description->{recipe});
      $self->files($json_description->{files});
      $self->mirrors($json_description->{mirrors});
      $self->msg_manual_requirement($json_description->{'msg-manual-requirement'});
      $self->dependencies($json_description->{dependencies});
      $self->prerequisites($json_description->{prerequisites});
  
  
      $self->type($json_description->{type} || 'generic');
  
      return $self;
  }
  
  sub to_hash {
      my ($self) = @_;
  
      my $sh = {};
  
      $sh->{type}          = $self->type;
      $sh->{recipe}        = $self->recipe;
      $sh->{files}         = $self->files;
      $sh->{mirrors}       = $self->mirrors;
      $sh->{dependencies}  = $self->dependencies;
      $sh->{prerequisites} = $self->prerequisites;
      $sh->{'msg-manual-requirement'} = $self->msg_manual_requirement;
  
      for my $k (keys %{$sh}) {
          unless(defined $sh->{$k}) {
              delete $sh->{$k};
          }
      }
  
      return $sh;
  }
  
  sub type {
      my ($self, $new_type) = @_;
  
      $self->{type} = $new_type if($new_type);
  
      return $self->{type};
  }
  
  sub widget {
      my ($self, $new_widget) = @_;
  
      $self->{widget} = $new_widget if($new_widget);
  
      croak 'No argument given'
      unless($self->{widget}); 
  
      return $self->{widget};
  }
  
  sub bag {
      my ($self) = @_;
  
      return $self->widget->package->bag;
  }
  
  sub recipe {
      my ($self, $new_recipe) = @_;
  
      $self->{recipe} = $new_recipe if($new_recipe);
  
      unless($self->{recipe}) {
          $self->{recipe} = ['echo "no explicit recipe given"'];
      }
  
      return $self->{recipe};
  }
  
  sub files {
      my ($self, $new_files) = @_;
  
      $self->{files} = $new_files if($new_files);
  
      unless($self->{files}) {
          $self->{files} = [];
      }
  
      return $self->{files};
  }
  
  sub mirrors {
      my ($self, $new_mirrors) = @_;
  
      $self->{mirrors} = $new_mirrors if($new_mirrors);
  
      unless($self->{mirrors}) {
          $self->{mirrors} = [];
      }
  
      return $self->{mirrors};
  }
  
  sub msg_manual_requirement {
      my ($self, $new_message) = @_;
  
      if($new_message) {
          $self->{msg_manual_requirement} = $new_message;
      }
  
      return $self->{msg_manual_requirement};
  }
  
  sub check_manual_requirements {
      my ($self, $new_message) = @_;
  
      # by default return true. Usually packages do not have manual requirements.
      return 1;
  }
  
  sub file_absolute {
      my ($self, $file) = @_;
      return rel2abs(catfile($self->bag->files_dir, $file));
  }
  
  sub dependencies {
      my ($self, $new_dependencies) = @_;
  
      if($new_dependencies) {
          $self->{dependencies} = {};
  
          for my $name (keys %{$new_dependencies}) {
              my $versions = $new_dependencies->{$name};
              my ($min_version, $max_version) = @{$versions};
  
              if($min_version) {
                  $min_version = version->declare($min_version);
              }
  
              if($max_version) {
                  $max_version = version->declare($max_version);
  
                  my $num = $max_version->numify();
                  my $fix = ($num * 1000000) % 1000;
                  $num   += 0.000999 unless($fix);
                  $max_version = version->declare($num);
  
                  unless($min_version) {
                      $min_version = version->declare('v0.0.0');
                  }
              }
  
              $self->{dependencies}{$name} = [];
  
              if($min_version) {
                  push @{$self->{dependencies}{$name}}, $min_version;
              }
  
              if($max_version) {
                  push @{$self->{dependencies}{$name}}, $max_version;
              }
          }
      }
  
      return $self->{dependencies};
  }
  
  sub prerequisites {
      my ($self, $new_prerequisites) = @_;
  
      $self->{prerequisites} = $new_prerequisites if($new_prerequisites);
  
      return $self->{prerequisites};
  }
  
  sub check_prerequisites {
      my ($self) = @_;
  
      # by default return true. Usually packages do not have prerequisites.
      unless($self->prerequisites()) {
          return 0;
      }
  
      my @steps = @{$self->prerequisites};
  
      my ($pid, $pre_in) = $self->widget->package->bag->shell();
  
      print { $pre_in } "exec 1>> /dev/null\n";
      print { $pre_in } "exec 2>&1\n";
      print { $pre_in } "set -ex\n";
  
  
      # add shifting to tmp directory as the first step.
      unshift @steps, 'cd ' . $self->bag->tmp_dir;
  
      # add exiting cleanly from shell as a last step.
      push @steps, 'exit 0';
  
      for my $step (@steps) {
          print { $pre_in } "$step\n";
      }
  
      my $exit_status = -1;
      eval { close $pre_in; $exit_status = $? };
  
      if(!$@ && WIFEXITED($exit_status) && (WEXITSTATUS($exit_status) == 0)) {
          return 0;
      } else {
          return -1;
      }
  }
  
  sub say {
      my $self = shift @_;
  
      return $self->widget->say(@_);
  }
  
  sub get_file {
      my ($self, $file) = @_;
  
      my @mirrors = @{$self->mirrors};
  
      unless( grep { $_ eq $self->bag->repository } @mirrors ) {
          push @mirrors, $self->bag->repository;
      }
  
      for my $m (@mirrors) {
          eval { $self->get_file_from_mirror($m, $file); };
  
          return unless $@;
  
          $self->bag->say($@);
      }
  
      die "Could not download '$file' from any of the mirrors.\n";
  }
  
  sub get_file_from_mirror {
      my ($self, $mirror, $file) = @_;
  
      $self->say("downloading '" . $file . "' from " . $mirror);
  
      my $ff = HTTP::Tiny->new();
  
      my $url    = $mirror . '/' . $file;
      my $output = catfile($self->bag->files_dir,  $file);
  
      my $retries = 5;
      my $sleep_before_retry = 5; # seconds
  
      my $last_modification;
      if(-f $self->file_absolute($file)) {
          # + 1 because when dates are the same, HTTP::Tiny is downloading the file...
          $last_modification = gmctime(stat($self->file_absolute($file))->mtime + 1);
      } else {
          $last_modification = gmctime(0)
      }
  
      for my $i (1..$retries) {
  
          my $response = $ff->mirror($url, $output,
              {'headers' => {
                      'If-Modified-Since' => $last_modification }});
  
          # 304 means file did not change from the last time we downloaded it
          if($response->{status} == 304) {
              $self->say("local copy of '" . $file . "' was up to date.");
          }
  
          return if $response->{success};
  
          # retries:
          # 408 is request timeout
          # 503 is service unavailable
          # 504 is a gatewat timeout
          # 524 is a cloudflare timeout
          # 599 is an internal exception of HTTP::Tiny, which may be a timeout too.
  
          if( grep { $response->{status} == $_ } (408,503,504,524,599) ) {
              print "Could not download '" . $file . "':\n" . "$response->{status}: $response->{reason}\n";
              print "$response->{content}\n" if $response->{content};
              print "Retrying @{[$retries - $i]} more time(s)\n"; 
  
              VC3::Builder::select_sleep($sleep_before_retry);
  
              next;
          }
  
          die "Could not download '" . $file . "':\n" . "$response->{status} $response->{reason}";
      }
  
      die "Could not download '" . $file . "':\n";
  }
  
  sub get_files {
      my ($self) = @_;
  
      my $files = $self->files;
  
      for my $file (@{$files}) {
          $self->get_file($file);
      }
  }
  
  sub prepare_files {
      my ($self, $build_dir) = @_;
  
      for my $file (@{$self->files}) {
          symlink($self->file_absolute($file), catfile($build_dir, basename($file)))
          || die "Could not link '" . $file . "' to build directory.\n";
      }
  }
  
  
  sub prepare_recipe_sandbox {
      my ($self) = @_;
  
  
      my $no_erase = $self->isa('VC3::Source::System');
  
      my $result = $self->widget->prepare_recipe_sandbox($self, $no_erase);
  
      if($result == 0) {
          return 0;
      }
  
      # download to $vc3_distfiles the ingredient (i.e., input files) if missing.
      $self->get_files();
  
      # if generic, copy all files to build directory.
      # if tarball, expand first file to build directory, and copy the rest of
      # the files to build directory.
      $self->prepare_files($self->widget->build_dir);
  
      return 1;
  }
  
  sub cleanup_recipe_sandbox {
      my ($self, $result) = @_;
      return $self->widget->cleanup_recipe_sandbox($result);
  }
  
  
  sub execute_recipe {
      my ($self, $force_rebuild, $ignore_locks) = @_;
  
      my $result = 1;
  
      unless($ignore_locks) {
          $self->widget->ribbon->set_lock();
      }
  
      eval {
          my $state = $self->widget->ribbon->state;
  
          if($state eq 'DONE' && !$force_rebuild && !$self->widget->phony) {
              $result = 0;
          } else {
              $self->say("preparing '" . $self->widget->package->name . "' for " . $self->widget->package->bag->target);
              if($self->widget->package->bag->dry_run) {
                  $result = 0;
              } else {
                  $self->prepare_recipe_sandbox();
                  $result = $self->execute_recipe_unlocked();
                  $self->cleanup_recipe_sandbox($result);
              }
          }
      };
  
      my $error_msg = $@;
  
      unless($ignore_locks) {
          $self->widget->ribbon->release_lock();
      }
  
      if($error_msg) {
          die $error_msg;
      }
  
      return $result;
  }
  
  sub execute_recipe_unlocked {
      my ($self) = @_;
  
      unless($self->isa('VC3::Source::System')) {
          $self->widget->ribbon->commit('PROCESSING');
      }
  
      my $result = -1;
      my ($pid, $build_in) = $self->setup_build_shell();
  
      my @steps = @{$self->recipe};
  
      # add shifting to build directory as the first step.
      unshift @steps, 'cd ' . $self->widget->build_dir;
  
      # add exiting cleanly from shell as a last step.
      push @steps, 'exit 0';
  
      $self->say("details: " .  $self->widget->build_log);
  
      for my $step (@steps) {
          print { $build_in } "$step\n";
      }
  
      my $status = -1;
      eval { close $build_in; $status = $? };
      if($@) {
          carp $@;
      }
  
      $self->widget->{child_pid} = undef;
  
      if(!$@ && WIFEXITED($status) && (WEXITSTATUS($status) == 0)) {
          $result = 0;
      }
  
      return $result;
  }
  
  sub setup_build_shell {
      my ($self) = @_;
      return $self->widget->setup_build_shell(@{$self->recipe});
  }
  
  1;
VC3_SOURCE_GENERIC

$fatpacked{"VC3/Source/ManualDist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_MANUALDIST';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::ManualDist;
  use base 'VC3::Source::Generic';
  use Carp;
  
  use File::Spec::Functions qw/rel2abs catfile/;
  
  sub get_file {
      my ($self, $file) = @_;
  
      unless(-f $self->file_absolute($file)) {
          die "Missing manual or restricted distribution file '$file'.\n";
      }
  }
  
  sub file_absolute {
      my ($self, $file) = @_;
      return rel2abs(catfile($self->bag->files_dir, 'manual-distribution', $file));
  }
  
  sub check_manual_requirements {
      my ($self) = @_;
  
      for my $file (@{$self->files}) {
          unless(-f $self->file_absolute($file)) {
              # check failed, return false
              return 0;
          }
      }
  
      return 1;
  }
  
  1;
  
VC3_SOURCE_MANUALDIST

$fatpacked{"VC3/Source/OSNative.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_OSNATIVE';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::OSNative;
  use base 'VC3::Source::System';
  use Carp;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      $widget->local(1);
  
      unless($json_description->{prerequisites}) {
  
          unless($json_description->{native}) {
              die "No method to verify native OS provided. Add prerequisites or native field.\n";
          }
  
          $json_description->{prerequisites} = [
              ": check if native is prefix of target",
              'pref=${VC3_MACHINE_TARGET#' . $json_description->{native} . '}',
              '[ "$pref" != ${VC3_MACHINE_TARGET} ] || exit 1'
          ];
      }
  
      unless($json_description->{'auto-version'}) {
  
          my $dver = $widget->package->bag->distribution;
          
          unless($dver =~ s/^.*[^0-9.]([0-9.]+)$/$1/) {
              $widget->available(0);
              die "Could not find version of distribution in '$dver'\n";
          }
  
          $json_description->{'auto-version'} = [
              "echo VC3_VERSION_SYSTEM: $dver"
          ]
      }
  
      my $self = $class->SUPER::new($widget, $json_description);
  
      return $self;
  }
  
  
  1;
  
VC3_SOURCE_OSNATIVE

$fatpacked{"VC3/Source/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_PERL';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Perl;
  use base 'VC3::Source::Generic';
  use Carp;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      unless($json_description->{recipe}) {
          my @steps;
          push @steps, "cpanm --notest --mirror \${VC3_MODULES_PERL_LOCAL_CPAN}/perl --mirror-only " . $json_description->{files}->[0];
          $json_description->{recipe} = \@steps;
      }
  
      my $self = $class->SUPER::new($widget, $json_description);
  
      unless($self->files) {
          croak "For type 'perl', at least one file should be defined in the files list.";
      }
  
      unless($self->dependencies) {
          $self->dependencies({});
      }
  
      $self->{dependencies}{'perl-cpanminus'} ||= [];
  
      return $self;
  }
  
  sub prepare_files  {
      my ($self, $build_dir) = @_;
  
      # do nothing
      return;
  }
  
  sub get_file {
      my ($self) = @_;
  
      # do nothing
      return;
  }
  
  1;
  
VC3_SOURCE_PERL

$fatpacked{"VC3/Source/System.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_SYSTEM';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::System;
  use base 'VC3::Source::Generic';
  use Carp;
  use File::Basename;
  use File::Which qw(which);
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      $widget->local(1);
      $widget->phony(1);
  
      my $exe    = $json_description->{executable};
      my $switch = $json_description->{"version-switch"} || '--version';
  
      if($exe) {
          $json_description->{prerequisites} ||= [];
          my $path = which($exe);
  
          if(defined $path) {
              my $dirname = dirname(${path});
  
              unless($json_description->{recipe}) {
                  $json_description->{recipe} = [
                      "bin=${dirname}",
                      "echo VC3_ROOT_SYSTEM: \${bin%%bin}"
                  ];
              }
              unless($json_description->{'auto-version'}) {
                  $json_description->{'auto-version'} = [
                      "echo VC3_VERSION_SYSTEM: \$(${path} $switch | head -n1 | sed -n -r -e \"s/(^|.*[ \\\"'])([0-9]+(\\.[0-9]+){0,2}).*/\\2/p\")"
                  ];
              }
          } else {
              unshift @{$json_description->{prerequisites}}, "exit 1";
          }
      }
  
      my $self = $class->SUPER::new($widget, $json_description);
  
      $self->auto_version($json_description->{'auto-version'});
  
      return $self;
  }
  
  sub auto_version {
      my ($self, $new_auto_version) = @_;
  
      $self->{auto_version} = $new_auto_version if($new_auto_version);
  
      return $self->{auto_version};
  }
  
  sub execute_recipe_unlocked {
      my ($self) = @_;
  
      my $output_filename = $self->widget->build_log;
  
      my $result;
      eval { $result = $self->SUPER::execute_recipe_unlocked(); };
  
      if($@) {
          die $@;
      } else {
          open(my $f, '<', $output_filename) || die 'Did not produce root directory file';
          my $root;
          while( my $line = <$f>) {
              if($line =~ m/^VC3_ROOT_SYSTEM:\s*(?<root>.*)$/) {
                  $root = $+{root};
                  chomp($root);
  
                  # update root from widget with the new information:
                  $self->widget->root_dir($root);
                  last;
              }
          }
          close $f;
          unless(defined($root)) {
              die 'Did not produce root directory information.';
          }
      }
  
      return $result;
  }
  
  1;
  
VC3_SOURCE_SYSTEM

$fatpacked{"VC3/Source/Tarball.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_SOURCE_TARBALL';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Source::Tarball;
  use base 'VC3::Source::Generic';
  use Carp;
  
  sub new {
      my ($class, $widget, $json_description) = @_;
  
      my $self = VC3::Source::Generic->new($widget, $json_description);
  
      unless($self->files) {
          croak "For type 'tarball', at least one file should be defined in the files list, and the first file in the list should be a tarball.";
      }
  
      $self = bless $self, $class;
  
      return $self;
  }
  
  sub prepare_files  {
      my ($self, $build_dir) = @_;
  
      # first file in $self->files is the tarball, by convention.
      my $tarball = @{$self->files}[0];
      $tarball = $self->file_absolute($tarball);
  
      system(qq/tar -C ${build_dir} --strip-components=1 -xpf ${tarball}/);
      die "Could not expand tarball $tarball.\n" if $?;
  
      # link in the rest of the input files.
      $self->SUPER::prepare_files($build_dir);
  }
  
  1;
  
VC3_SOURCE_TARBALL

$fatpacked{"VC3/Widget.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VC3_WIDGET';
  #
  # Copyright (C) 2016- The University of Notre Dame
  # This software is distributed under the GNU General Public License.
  # See the file COPYING for details.
  #
  
  use v5.09;
  use strict;
  use warnings;
  
  package VC3::Widget;
  use Carp;
  use POSIX ":sys_wait_h";
  use IO::Handle;
  use Digest::Perl::MD5 qw(md5_hex);
  use Cwd;
  use File::Temp qw/tempdir/;
  use File::Spec::Functions qw/catfile rel2abs/;
  use JSON::Tiny;
  
  use VC3::Ribbon;
  
  # Attributes:
  # version, source, dependencies, wrapper, prologue, environment_variables, environment_autovars, phony
  sub new {
      my ($class, $pkg, $json_description) = @_;
  
      my $self = bless {}, $class;
  
      $self->package($pkg);
      $self->available(1);
  
      $self->source($json_description->{source});
  
      if($json_description->{version} eq 'auto') {
          $self->from_system(1);
          eval { $self->version($self->compute_auto_version()) };
          if($@) {
              $self->available(0);
          }
      } else {
          $self->version($json_description->{version});
          $self->from_system(0);
      }
  
      $self->dependencies($json_description->{dependencies});
      $self->wrapper($json_description->{wrapper});
      $self->prologue($json_description->{prologue});
      $self->environment_variables($json_description->{'environment-variables'});
      $self->environment_autovars($json_description->{'environment-autovars'});
  
      # should always be executed
      $self->phony($json_description->{phony});
  
      # should recipe be executed locally when using parallel builds?
      $self->local($json_description->{local});
  
  
      if($self->available) {
          my $majminbug = $self->version->normal;
          $majminbug =~ s/^v([0-9]+\.[0-9]+\.[0-9]+)/$1/;
  
          my $majmin = $self->version->normal;
          $majmin    =~ s/^v([0-9]+\.[0-9]+)\..*/$1/;
  
          $self->add_widget_variable('VERSION', $majmin);
          $self->add_widget_variable('VERSION_FULL', $majminbug);
  
          if($self->package->options) {
              $self->add_widget_variable('OPTIONS', @{$self->package->options});
          }
  
          # initialize root dir variable. we use unless here becase root_dir
          # depends on machine target, which is still not set until we process
          # all the operating-system-distribution's
          unless($self->package->type eq 'operating-system-distribution') {
              $self->root_dir();
          }
      }
  
      unless($self->source) {
          my $null_source = {};
          $null_source->{type}   = 'generic';
          $null_source->{recipe} = ['echo "no explicit recipe given"'];
  
          $self->source($null_source);
      }
  
      return $self;
  }
  
  sub to_hash {
      my ($self) = @_;
  
      my $wh = {};
  
      $wh->{version}       = $self->version;
      $wh->{phony}         = $self->phony;
      $wh->{local}         = $self->local;
      $wh->{source}        = $self->source->to_hash;
      $wh->{dependencies}  = $self->dependencies;
      $wh->{wrapper}       = $self->wrapper;
      $wh->{prologue}      = $self->prologue;
      $wh->{'environment-variables'} = $self->environment_variables;
  
      # environment-autovars already included in environment-variables
  
      for my $k (keys %{$wh}) {
          unless(defined $wh->{$k}) {
              delete $wh->{$k};
          }
      }
  
      return $wh;
  }
  
  sub add_widget_variable {
      my ($self, $varname, $value) = @_;
  
      $varname = $self->widget_var($varname);
  
      my $var = {
          name     => $varname,
          value    => $value,
          clobber  => 1,
          absolute => 1
      };
  
      $self->environment_variables([$var]);
  }
  
  sub widget_var {
      my ($self, $varname) = @_;
  
      my $expanded = "VC3_${varname}_" . uc($self->package->name);
  
      # replace - with _, as env vars cannot have - in their names.
      $expanded =~ s/-/_/g;
  
      return $expanded;
  }
  
  sub package {
      my ($self, $new_pkg) = @_;
  
      $self->{package} = $new_pkg if($new_pkg);
  
      croak 'No package given'
      unless($self->{package}); 
  
      return $self->{package};
  }
  
  sub ribbon {
      my ($self) = @_;
  
      unless($self->{ribbon}) {
          $self->{ribbon} = VC3::Ribbon->new($self->package->name, $self->bookeeping_dir, $self->package->bag->tmp_dir, $self->checksum($self->source->recipe));
      }
  
      return $self->{ribbon};
  }
  
  sub version {
      my ($self, $new_version) = @_;
  
      if($new_version) {
          $self->{version} = version->declare($new_version);
      }
  
      unless($self->{version}) {
          croak 'No version given';
      }
  
      return $self->{version};
  }
  
  sub dependencies {
      my ($self, $new_dependencies) = @_;
  
      if($new_dependencies) {
          $self->{dependencies} = $new_dependencies;
      }
  
      my %deps;
      if($self->package->dependencies) {
          %deps = %{$self->package->dependencies};
      }
  
      for my $d (keys %{$self->{dependencies}}) {
          $deps{$d} = $self->{dependencies}->{$d};
      }
  
      return \%deps;
  }
  
  sub source {
      my ($self, $new_source) = @_;
  
      if($new_source) {
          $self->{source} = VC3::Source::new($self, $new_source);
      }
  
      return $self->{source};
  }
  
  sub prologue {
      my ($self, $new_prologue) = @_;
  
      $self->{prologue} = $new_prologue if($new_prologue);
  
      my $prologue = $self->{prologue} || $self->package->prologue;
  
      return $prologue;
  }
  
  sub wrapper {
      my ($self, $new_wrapper) = @_;
  
      $self->{wrapper} = $new_wrapper if($new_wrapper);
  
      my $wrapper = $self->{wrapper} || $self->package->wrapper;
  
      return $wrapper;
  }
  
  
  sub environment_variables {
      my ($self, $new_vars) = @_;
  
      $self->{environment_variables} ||= [];
  
      if($new_vars) {
          unshift @{$self->{environment_variables}}, @{$new_vars};
      }
  
      return [ @{$self->{environment_variables}}, @{$self->package->environment_variables} ];
  }
  
  sub environment_autovars {
      my ($self, $new_autovars) = @_;
  
      my %mappings;
      $mappings{PATH}               = 'bin';
      $mappings{LD_LIBRARY_PATH}    = 'lib';
      $mappings{LIBRARY_PATH}       = 'lib';
      $mappings{C_INCLUDE_PATH}     = 'include';
      $mappings{CPLUS_INCLUDE_PATH} = 'include';
      $mappings{PKG_CONFIG_PATH}    = 'lib/pkgconfig';
      $mappings{PERL5LIB}           = 'lib/perl5/site_perl';
  
      if($new_autovars) {
          $self->{environment_autovars} = $new_autovars;
      }
  
      my @autovars;
      if($self->package->environment_autovars) {
          push @autovars, @{$self->package->environment_autovars};
      }
  
      if($self->{environment_autovars}) {
          push @autovars, @{$self->{environment_autovars}};
      }
  
      $self->{environment_variables} ||= [];
      for my $var (@autovars) {
          my $target = $mappings{$var};
  
          unless($target) {
              die "Unrecognized auto-variable '$var'";
          }
  
          push @{$self->{environment_variables}}, { 'name' => $var, 'value' => $target };
      }
  
      return \@autovars;
  }
  
  sub phony {
      my ($self, $new_phony) = @_;
  
      $self->{phony} = $new_phony if(defined $new_phony);
  
      my $phony = $self->{phony} || $self->package->phony;
  
      return $phony;
  }
  
  sub local {
      my ($self, $new_local) = @_;
  
      $self->{local} = $new_local if($new_local);
  
      return $self->{local};
  }
  
  sub from_system {
      my ($self, $new_from_system) = @_;
  
      $self->{from_system} = $new_from_system if(defined $new_from_system);
  
      return $self->{from_system};
  }
  
  sub available {
      my ($self, $new_available) = @_;
  
      $self->{available} = $new_available if(defined $new_available);
  
      return $self->{available};
  }
  
  sub root_dir {
      my ($self, $new) = @_;
  
      my $old = $self->{root_dir};
  
      my $var_value;
  
      if($new) {
          $self->{root_dir} = $new;
          $var_value = $new;
      }
  
      unless($self->{root_dir}) {
          my $rel = catfile($self->package->bag->target, $self->package->name, $self->version->normal);
          $self->{root_dir} = catfile($self->package->bag->root_dir, $rel);
          $var_value = catfile('${VC3_ROOT}', '${VC3_MACHINE_TARGET}', $self->package->name, 'v${' . $self->widget_var('VERSION_FULL') . '}');
      }
  
      if(!$old || $old ne $self->{root_dir}) {
          $self->add_widget_variable('ROOT', $var_value);
      }
  
      return $self->{root_dir};
  }
  
  sub bookeeping_dir {
      my ($self, $relative) = @_;
  
      my $rel = catfile($self->package->bag->target, $self->package->name, $self->version->normal);
  
      if($relative) {
          return $rel;
      }
  
      return catfile($self->package->bag->root_dir, $rel);
  }
  
  sub build_dir {
      my ($self) = @_;
  
      unless($self->{build_dir}) {
          my $root     = catfile($self->package->bag->root_dir, 'builds');
  
          unless(-d $root) {
              File::Path::make_path($root);
          }
  
          my $template = catfile($root, $self->package->name . '.XXXXXX');
  
          my $tmpdir   = File::Temp::tempdir($template, CLEANUP => 1);
          $self->{build_dir} = $tmpdir;
      }
  
      return $self->{build_dir};
  }
  
  sub build_log {
      my ($self) = @_;
      my $log_name = catfile($self->bookeeping_dir, $self->package->name . '-build-log');
  
      return $log_name;
  }
  
  sub say {
      my $self = shift @_;
  
      return $self->package->bag->say(@_);
  }
  
  sub consolidate_environment_variables {
      my ($self, $expansion) = @_; 
  
      my $vars = $self->environment_variables
      || return;
  
      for my $var (reverse @{$vars}) {
  
          my $name = $var->{name}
          || carp "Environment variable does not have a name.";
  
          my $value = $var->{value}
          || carp "Environment variable '$name' did not define a value.";
  
          my $clobber  = $var->{clobber};
          my $absolute = $var->{absolute};
  
          if($expansion->{$name} && $clobber) {
              my @old_value = @{$expansion->{$name}};
              my $n = @old_value;
              if($n > 1) {
                  carp("Asked to clobber variable '$name', but it already had a value.\n"
                      . "'$value' <> '" . join(',', @old_value) . "'\n");
              }
          }
  
          $expansion->{$name} ||= [];
  
          my @paths;
          if($clobber) {
              # when clobber, we use the value as is, and remove previous expansions.
              @paths = ($value);
              $expansion->{$name} = [];
          } else {
              # otherwise, split paths on :
              @paths = split /:/, $value;
          }
  
          my @current_expansions;
          for my $path (@paths) {
              if(!$absolute) {
                  if($self->root_dir eq $self->bookeeping_dir) {
                      $path = catfile('${' . $self->widget_var('ROOT') . '}', $path);
                  } else {
                      $path = catfile($self->root_dir, $path);
                  }
              }
  
              push @current_expansions, $path;
          }
  
          unshift @{$expansion->{$name}}, @current_expansions;
      }
  }
  
  sub error_debug_info {
      my ($self, $eval_error) = @_;
  
      print "'", $self->package->name, "' failed to build for ", $self->package->bag->target, "\n";
  
      if($eval_error) {
          print $eval_error, "\n";
      }
  
      if(-f $self->build_log) {
          print "Last lines of log file:\n";
          system('tail', $self->build_log);
      }
  }
  
  
  sub process_error {
      my ($self, $sh_on_error, $eval_error, $status) = @_;
  
      if($eval_error || $status) {
          $self->error_debug_info($eval_error);
  
          if($sh_on_error) {
              warn $@ if $@;
  
              my $cwd = getcwd();
  
              $self->package->bag->shell_user();
  
              chdir $cwd;
          }
      }
  }
  
  sub checksum {
      my ($self, $load) = @_;
  
      if(!$self->{checksum}) {
          $load ||= 'no source';
  
          my $txt = $self->hash_to_canonical_str($load);
          my $dgt = md5_hex($txt);
  
          $self->{checksum} = $dgt;
      }
  
      return $self->{checksum};
  }
  
  sub hash_to_canonical_str {
      my ($self, $ref) = @_;
  
      my $str;
  
      if(ref($ref) eq 'HASH') {
          my @ks = sort { $a cmp $b } keys %{$ref};
  
          $str 
          = '{'
          . join(',', map { $_ .  ':' . $self->hash_to_canonical_str($ref->{$_}) } @ks)
          . '}';
      } elsif(ref($ref) eq 'ARRAY') {
          $str 
          = '['
          . join(',', map { $self->hash_to_canonical_str($_) } @{$ref})
          . ']';
      } else {
          $str = $ref;
      }
  
      return $str;
  }
  
  
  sub msgs_manual_requirements {
      my ($self) = @_;
  
      my $source = $self->source;
  
      if(!$self->source->check_manual_requirements()) {
          return $self->source->msg_manual_requirement();
      }
  }
  
  sub prepare_recipe_sandbox {
      my ($self, $source, $no_erase) = @_;
  
      # clear build directory, to avoid bugs from uncleaned sources.
      my $build = $self->build_dir;
      if( -d $build ) {
          File::Path::rmtree($build);
      }
  
      # clear destination directory, to make sure we are running what we believe
      # we are running.
      unless($no_erase) {
          my $dir = $self->root_dir;
          if( -d $dir ) {
              File::Path::rmtree($dir);
          }
  
          if($self->root_dir ne $self->bookeeping_dir) {
              my $dir = $self->bookeeping_dir;
              if( -d $dir ) {
                  File::Path::rmtree($dir);
              }
          }
      }
  
      # create the dirs we removed above.
      File::Path::make_path($self->build_dir);
      File::Path::make_path($self->root_dir);
      File::Path::make_path($self->bookeeping_dir);
  
      # make sure tmp dir exists
      File::Path::make_path($self->package->bag->tmp_dir);
  
      # set the destination directory as an environment variable before
      # setting up the shell, so that the child created inherets it.
      $self->package->bag->add_builder_variable('VC3_PREFIX', $self->root_dir);
      $self->package->bag->add_builder_variable('VC3_BUILD',  $self->build_dir);
      $self->package->bag->add_builder_variable('VC3_FILES',  join(" ", @{$source->files}));
  }
  
  sub cleanup_recipe_sandbox {
      my ($self, $result) = @_;
  
      $self->package->bag->del_builder_variable('VC3_PREFIX');
      $self->package->bag->del_builder_variable('VC3_BUILD');
      $self->package->bag->del_builder_variable('VC3_FILES');
  
      if($result eq '0') {
          File::Path::rmtree($self->build_dir);
          $self->ribbon->commit('DONE');
      }
  
      # we do not delete the buildir in case of error, to ease debugging.
  }
  
  sub setup_build_shell {
      my ($self, @log_messages) = @_;
  
      # log the recipe used. Since we are opening sh with -e, the recipe executes
      # as if all steps were &&-ed together.
      open(my $build_log, '>', $self->build_log);
      print { $build_log } join("\n && ", @log_messages . "\n");
      close $build_log;
  
      # open sh with -e. This terminates the shell at the first step that returns
      # a non-zero status.
      my ($pid, $build_in) = $self->package->bag->shell();
  
      croak "Could not execute shell for building."
      unless $build_in;
  
      # redirect all output to our log file.
      print { $build_in } 'exec 1>> ' . $self->build_log . " || echo Could not redirect stdout to logfile.\n";
      print { $build_in } "exec 2>&1                         || echo Could not redirect stderr to logfile.\n";
      print { $build_in } "set -ex\n";
  
      # return the stdin of the shell, and the pid so we can wait for it.
      return ($pid, $build_in);
  }
  
  sub shell {
      my ($self) = @_;
      return $self->package->bag->shell();
  }
  
  sub compute_auto_version {
      my ($self, $root) = @_;
  
      unless($self->source->auto_version) {
          die "I don't know how to compute the version of '" . $self->package->name . "'\n";
      }
  
      if($root) {
          $self->package->bag->add_builder_variable('VC3_PREFIX', $root);
      }
  
      my ($pid, $auto_in) = $self->package->bag->shell();
  
      if($root) {
          $self->package->bag->del_builder_variable('VC3_PREFIX');
      }
  
      die "Could not execute shell for auto-version.\n"
      unless $auto_in;
  
      my $template = catfile($self->package->bag->tmp_dir, $self->package->name . 'XXXXXX');
      my $fh = File::Temp->new(template => $template, unlink => 1);
      close($fh);
      
      my $fname = $fh->filename;
  
      # redirect all output to our log file.
      print { $auto_in } 'exec 1> ' . $fname . "\n";
      print { $auto_in } "exec 2>&1\n";
      print { $auto_in } "set -ex\n";
  
      if($root) {
          print { $auto_in } q(export PATH="${VC3_PREFIX}/bin":"$PATH") . "\n";
      }
  
      for my $step (@{$self->source->auto_version}) {
          print { $auto_in } "$step\n";
      }
      print { $auto_in } "exit 0\n";
  
      my $status = -1;
      eval { close $auto_in; $status = $? };
  
  
      open(my $f, '<', $fname) || die 'Did not produce auto-version file';
      my @lines;
      my $version;
      while( my $line = <$f>) {
          push @lines, $line;
          if($line =~ m/^VC3_VERSION_SYSTEM:\s*v?(?<version>([0-9]+(\.?[0-9]){0,3}))$/) {
              $version = $+{version};
              chomp($version);
              last;
          }
      }
      close $f;
      if(!$version) {
          die $self->package->name . " did not produce version information.\n";
      }
  
      return $version;
  }
  
  
  sub compute_os_distribution {
      my ($self) = @_;
  
      unless($self->source) {
          die "I don't know how to find the distribution from '" . $self->package->name . "'\n";
      }
  
      my ($pid, $auto_in) = $self->package->bag->shell();
  
      die "Could not execute shell for operating-system-distro.\n"
      unless $auto_in;
  
      my $template = catfile($self->package->bag->tmp_dir, $self->package->name . 'XXXXXX');
      my $fh = File::Temp->new(template => $template, unlink => 1);
      close($fh);
      
      my $fname = $fh->filename;
  
      # redirect all output to our log file.
      print { $auto_in } 'exec 1> ' . $fname . "\n";
      print { $auto_in } "exec 2>&1\n";
      print { $auto_in } "set -ex\n";
  
      for my $step (@{$self->source->recipe}) {
          print { $auto_in } "$step\n";
      }
      print { $auto_in } "exit 0\n";
  
      my $status = -1;
      eval { close $auto_in; $status = $? };
  
      if($@) {
          warn "$@\n";
      }
  
      open(my $f, '<', $fname) || die 'Did not produce a distribution file';
      my @lines;
      my $distro;
      while( my $line = <$f>) {
          push @lines, $line;
          if($line =~ m/^VC3_MACHINE_DISTRIBUTION:\s*(?<distro>.*)/) {
              $distro = $+{distro};
              chomp($distro);
              last;
          }
      }
      close $f;
      if(!$distro) {
          return;
      }
  
      return $self->distro_canonical_name($distro);
  }
  
  sub distro_canonical_name {
      my ($self, $distro) = @_;
  
      my ($name, $version) = ($distro =~ m/(.+) (.+)/);
  
      if($name =~ m/(redhat|rhel|centos|scientific)/) {
          $name = 'redhat';
      } elsif($name =~ m/debian/) {
          $name = 'debian';
      } elsif($name =~ m/ubuntu/) {
          $name = 'ubuntu';
      } elsif($name =~ m/opensuse/) {
          $name = 'opensuse';
      } else {
          $name =~ s/[^A-z0-9_]/_/g;
      }
  
      return "$name$version";
  }
  
  1;
  
VC3_WIDGET

$fatpacked{"common/sense.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMON_SENSE';
  package common::sense;
  
  our $VERSION = 3.74;
  
  # overload should be included
  
  sub import {
     local $^W; # work around perl 5.16 spewing out warnings for next statement
     # use warnings
     ${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x0c\x3f\x33\x00\x0f\xf0\x0f\xc0\xf0\xfc\x33\x00";
     # use strict, use utf8; use feature;
     $^H |= 0x820700;
     @^H{qw(feature_say feature_state feature_switch)} = (1) x 3;
  }
  
  1
COMMON_SENSE

$fatpacked{"lib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIB';
  package lib;
  
  # THIS FILE IS AUTOMATICALLY GENERATED FROM lib_pm.PL.
  # ANY CHANGES TO THIS FILE WILL BE OVERWRITTEN BY THE NEXT PERL BUILD.
  
  use Config;
  
  use strict;
  
  my $archname         = $Config{archname};
  my $version          = $Config{version};
  my @inc_version_list = reverse split / /, $Config{inc_version_list};
  
  
  our @ORIG_INC = @INC;	# take a handy copy of 'original' value
  our $VERSION = '0.63';
  
  sub import {
      shift;
  
      my %names;
      foreach (reverse @_) {
  	my $path = $_;		# we'll be modifying it, so break the alias
  	if ($path eq '') {
  	    require Carp;
  	    Carp::carp("Empty compile time value given to use lib");
  	}
  
  	if ($path !~ /\.par$/i && -e $path && ! -d _) {
  	    require Carp;
  	    Carp::carp("Parameter to use lib must be directory, not file");
  	}
  	unshift(@INC, $path);
  	# Add any previous version directories we found at configure time
  	foreach my $incver (@inc_version_list)
  	{
  	    my $dir = "$path/$incver";
  	    unshift(@INC, $dir) if -d $dir;
  	}
  	# Put a corresponding archlib directory in front of $path if it
  	# looks like $path has an archlib directory below it.
  	my($arch_auto_dir, $arch_dir, $version_dir, $version_arch_dir)
  	    = _get_dirs($path);
  	unshift(@INC, $arch_dir)         if -d $arch_auto_dir;
  	unshift(@INC, $version_dir)      if -d $version_dir;
  	unshift(@INC, $version_arch_dir) if -d $version_arch_dir;
      }
  
      # remove trailing duplicates
      @INC = grep { ++$names{$_} == 1 } @INC;
      return;
  }
  
  
  sub unimport {
      shift;
  
      my %names;
      foreach my $path (@_) {
  	my($arch_auto_dir, $arch_dir, $version_dir, $version_arch_dir)
  	    = _get_dirs($path);
  	++$names{$path};
  	++$names{$arch_dir}         if -d $arch_auto_dir;
  	++$names{$version_dir}      if -d $version_dir;
  	++$names{$version_arch_dir} if -d $version_arch_dir;
      }
  
      # Remove ALL instances of each named directory.
      @INC = grep { !exists $names{$_} } @INC;
      return;
  }
  
  sub _get_dirs {
      my($dir) = @_;
      my($arch_auto_dir, $arch_dir, $version_dir, $version_arch_dir);
  
      $arch_auto_dir    = "$dir/$archname/auto";
      $arch_dir         = "$dir/$archname";
      $version_dir      = "$dir/$version";
      $version_arch_dir = "$dir/$version/$archname";
  
      return($arch_auto_dir, $arch_dir, $version_dir, $version_arch_dir);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  lib - manipulate @INC at compile time
  
  =head1 SYNOPSIS
  
      use lib LIST;
  
      no lib LIST;
  
  =head1 DESCRIPTION
  
  This is a small simple module which simplifies the manipulation of @INC
  at compile time.
  
  It is typically used to add extra directories to perl's search path so
  that later C<use> or C<require> statements will find modules which are
  not located on perl's default search path.
  
  =head2 Adding directories to @INC
  
  The parameters to C<use lib> are added to the start of the perl search
  path. Saying
  
      use lib LIST;
  
  is I<almost> the same as saying
  
      BEGIN { unshift(@INC, LIST) }
  
  For each directory in LIST (called $dir here) the lib module also
  checks to see if a directory called $dir/$archname/auto exists.
  If so the $dir/$archname directory is assumed to be a corresponding
  architecture specific directory and is added to @INC in front of $dir.
  lib.pm also checks if directories called $dir/$version and $dir/$version/$archname
  exist and adds these directories to @INC.
  
  The current value of C<$archname> can be found with this command:
  
      perl -V:archname
  
  The corresponding command to get the current value of C<$version> is:
  
      perl -V:version
  
  To avoid memory leaks, all trailing duplicate entries in @INC are
  removed.
  
  =head2 Deleting directories from @INC
  
  You should normally only add directories to @INC.  If you need to
  delete directories from @INC take care to only delete those which you
  added yourself or which you are certain are not needed by other modules
  in your script.  Other modules may have added directories which they
  need for correct operation.
  
  The C<no lib> statement deletes all instances of each named directory
  from @INC.
  
  For each directory in LIST (called $dir here) the lib module also
  checks to see if a directory called $dir/$archname/auto exists.
  If so the $dir/$archname directory is assumed to be a corresponding
  architecture specific directory and is also deleted from @INC.
  
  =head2 Restoring original @INC
  
  When the lib module is first loaded it records the current value of @INC
  in an array C<@lib::ORIG_INC>. To restore @INC to that value you
  can say
  
      @INC = @lib::ORIG_INC;
  
  =head1 CAVEATS
  
  In order to keep lib.pm small and simple, it only works with Unix
  filepaths.  This doesn't mean it only works on Unix, but non-Unix
  users must first translate their file paths to Unix conventions.
  
      # VMS users wanting to put [.stuff.moo] into 
      # their @INC would write
      use lib 'stuff/moo';
  
  =head1 NOTES
  
  In the future, this module will likely use File::Spec for determining
  paths, as it does now for Mac OS (where Unix-style or Mac-style paths
  work, and Unix-style paths are converted properly to Mac-style paths
  before being added to @INC).
  
  If you try to add a file to @INC as follows:
  
    use lib 'this_is_a_file.txt';
  
  C<lib> will warn about this. The sole exceptions are files with the
  C<.par> extension which are intended to be used as libraries.
  
  =head1 SEE ALSO
  
  FindBin - optional module which deals with paths relative to the source file.
  
  PAR - optional module which can treat C<.par> files as Perl libraries.
  
  =head1 AUTHOR
  
  Tim Bunce, 2nd June 1995.
  
  C<lib> is maintained by the perl5-porters. Please direct
  any questions to the canonical mailing list. Anything that
  is applicable to the CPAN release can be sent to its maintainer,
  though.
  
  Maintainer: The Perl5-Porters <perl5-porters@perl.org>
  
  Maintainer of the CPAN release: Steffen Mueller <smueller@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This package has been part of the perl core since perl 5.001.
  It has been released separately to CPAN so older installations
  can benefit from bug fixes.
  
  This package has the same copyright and license as the perl core.
  
  =cut
LIB

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;
  use strict;
  use vars qw($VERSION);
  $VERSION = '0.234';
  
  sub import {
      my $class = shift;
  
      my $inheritor = caller(0);
  
      if ( @_ and $_[0] eq '-norequire' ) {
          shift @_;
      } else {
          for ( my @filename = @_ ) {
              s{::|'}{/}g;
              require "$_.pm"; # dies if the file is not found
          }
      }
  
      {
          no strict 'refs';
          push @{"$inheritor\::ISA"}, @_;
      };
  };
  
  "All your base are belong to us"
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  parent - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use parent qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Mostly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  By default, every base class needs to live in a file of its own.
  If you want to have a subclass and its parent class in the same file, you
  can tell C<parent> not to load any modules by using the C<-norequire> switch:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    use parent -norequire, 'Foo', 'Bar';
    # will not go looking for Foo.pm or Bar.pm
  
  This is equivalent to the following code:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';
  
  This is also helpful for the case where a package lives within
  a differently named file:
  
    package MyHash;
    use Tie::Hash;
    use parent -norequire, 'Tie::StdHash';
  
  This is equivalent to the following code:
  
    package MyHash;
    require Tie::Hash;
    push @ISA, 'Tie::StdHash';
  
  If you want to load a subclass from a file that C<require> would
  not consider an eligible filename (that is, it does not end in
  either C<.pm> or C<.pmc>), use the following code:
  
    package MySecondPlugin;
    require './plugins/custom.plugin'; # contains Plugin::Custom
    use parent -norequire, 'Plugin::Custom';
  
  =head1 HISTORY
  
  This module was forked from L<base> to remove the cruft
  that had accumulated in it.
  
  =head1 CAVEATS
  
  =head1 SEE ALSO
  
  L<base>
  
  =head1 AUTHORS AND CONTRIBUTORS
  
  Rafaël Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern
  
  =head1 MAINTAINER
  
  Max Maischein C< corion@cpan.org >
  
  Copyright (c) 2007-10 Max Maischein C<< <corion@cpan.org> >>
  Based on the idea of C<base.pm>, which was introduced with Perl 5.004_04.
  
  =head1 LICENSE
  
  This module is released under the same terms as Perl itself.
  
  =cut
PARENT

$fatpacked{"version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION';
  #!perl -w
  package version;
  
  use 5.006002;
  use strict;
  use warnings::register;
  if ($] >= 5.015) {
      warnings::register_categories(qw/version/);
  }
  
  use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);
  
  $VERSION = 0.9917;
  $CLASS = 'version';
  
  # !!!!Delete this next block completely when adding to Perl core!!!!
  
  push @ISA, "version::vpp";
  local $^W;
  
  *version::qv = \&version::vpp::qv;
  *version::declare = \&version::vpp::declare;
  *version::_VERSION = \&version::vpp::_VERSION;
  *version::vcmp = \&version::vpp::vcmp;
  *version::new = \&version::vpp::new;
  *version::numify = \&version::vpp::numify;
  *version::normal = \&version::vpp::normal;
  if ($] >= 5.009000) {
      no strict 'refs';
      *version::stringify = \&version::vpp::stringify;
      *{'version::(""'} = \&version::vpp::stringify;
      *{'version::(<=>'} = \&version::vpp::vcmp;
      *{'version::(cmp'} = \&version::vpp::vcmp;
      *version::parse = \&version::vpp::parse;
  }
  
  # avoid using Exporter
  require version::regex;
  *version::is_lax = \&version::regex::is_lax;
  *version::is_strict = \&version::regex::is_strict;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
          local $^W;
          *{$class.'::declare'} =  \&{$CLASS.'::declare'};
          *{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
          map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
          %args =
          (
              qv => 1,
              'UNIVERSAL::VERSION' => 1,
          );
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
          *{$callpkg.'::declare'} =
          sub {return $class->declare(shift) }
          unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
          *{$callpkg.'::qv'} =
          sub {return $class->qv(shift) }
          unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
          local $^W;
          *UNIVERSAL::VERSION
          = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
          *{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
          *{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
          unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
          *{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
          unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  
  use 5.006002;
  use strict;
  use warnings::register;
  
  use Config;
  use vars qw($VERSION $CLASS @ISA $LAX $STRICT $WARN_CATEGORY);
  $VERSION = 0.9917;
  $CLASS = 'version::vpp';
  if ($] > 5.015) {
      warnings::register_categories(qw/version/);
      $WARN_CATEGORY = 'version';
  } else {
      $WARN_CATEGORY = 'numeric';
  }
  
  require version::regex;
  *version::vpp::is_strict = \&version::regex::is_strict;
  *version::vpp::is_lax = \&version::regex::is_lax;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	no warnings qw/redefine/;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
      if ($saw_decimal > 1 && ($d-1) eq '.') {
  	# no trailing period allowed
  	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos) || $pos eq '_') {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			next if $s eq '_';
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			next if $end eq '_';
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) || $pos eq '_') {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale}) {
  	use POSIX qw/locale_h/;
  	use if $Config{d_setlocale}, 'locale';
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn(sprintf "Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      if ($alpha and warnings::enabled()) {
  	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
      }
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf("%03d", $digit);
      }
  
      if ( $len == 0 ) {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
  
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 1 && $value !~ /[,._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      $tvalue =~ tr/_//d;
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
  
VERSION

$fatpacked{"version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'VERSION_REGEX';
  package version::regex;
  
  use strict;
  
  use vars qw($VERSION $CLASS $STRICT $LAX);
  
  $VERSION = 0.9917;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  my $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  my $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  my $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  my $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  $LAX =
      qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
VERSION_REGEX

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#
# Copyright (C) 2016- The University of Notre Dame
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.
#

use v5.009;
use strict;
use warnings;

# load module path, for bare, if needed
eval {use Cwd; use lib getcwd . "/builder-pack/fatlib";};

use VC3::Bag;
use VC3::Plan;
use VC3::Source;

package VC3::Builder;

use English qw/-mo_match_vars/;
use File::Basename qw/basename/;
use File::Spec::Functions qw/catfile rel2abs file_name_is_absolute/;
use Getopt::Long qw/GetOptions/;
use File::Path qw/make_path remove_tree/;
use Cwd;

use Carp qw( confess );
$SIG{TERM} = \&cleanup_signal_handler;
$SIG{INT}  = \&cleanup_signal_handler;
$SIG{ALRM} = \&cleanup_signal_handler;

# disable stdout buffering
select(STDOUT); $OUTPUT_AUTOFLUSH = 1;

my $pwd            = getcwd();
my $vc3_root       = catfile(${pwd}, 'vc3-root');
my $vc3_distfiles  = catfile(${pwd}, 'vc3-distfiles');
my $vc3_user_home  = 'vc3-home';
my $vc3_repository = "https://s3.ssl-hep.org/vc3-repository-70e707f3-6df8-41f6-adb2-fa5ecba1548d/builder-files";

my $shell          = '/bin/sh';

my $unsafe_path    = qr/[\\"#\$&'`\n]/;

my @external_dependencies = qw/perl sh tail tar gcc g++ ld pkconfig make/;
my @cleanups;     # functions to call on exit.

# call main if running interactively
VC3::Builder::main();

END {
    local $?;

    for my $fn (@cleanups) {
        eval { $fn->() };
    }
}

sub usage {
    my ($script_name) = @_;
    return <<EOF;
$script_name [options] [-- command-and-args]

  command-and-args      defaults to $shell

  and options are:

  --require  <pkg>[:<m>[:<M>]]
                        Ensure that the package <pkg> is installed, optionally
                        specifying a minimum <m> and maximum <M> version. May
                        be specified several times.

  --require-os <name>   Ensure the operating system is <name>. May use a
                        container to fulfill the requirement. May be specified
                        several times, but only the last occurance is honored.
                        Use --list=os for a list of available operating
                        systems. 

  --mount /<x>          Ensure that path /<x> is exists inside the execution
                        environment. If using --require-os with a non-native
                        operating system, it is equivalent to --mount /<x>:/<x>
  --mount /<x>:/<y>     Mount path <x> into path <y> inside the execution
                        environment.  When executing in a native operating
                        system, <x> and <y> cannot be different paths.

  --database <f-d>      defaults to <internal> if available. <f-d> may be a
                        file, or a directory.  The unique file, or the files in
                        the directory should contain a JSON encoded object with
                        package recipes.  May be specified several times, with
                        latter package recipes overwriting previous ones. 


  Installation locations:
  --install <root>      Install with base <root>. 
                        Default is ${vc3_root}
  --home <home>         Set \${HOME} to <root>/<home> if <home> is a relative
                        path, otherwise to <home> if it is an absolute path.
                        Default is ${vc3_user_home}
  --distfiles <dir>     Directory to cache unbuilt packages locally.
                        Default is ${vc3_distfiles}

  --repository <url>    Fallback site to fetch packages if needed.
                        Default is ${vc3_repository}

  --make-jobs <n>       Concurrent make jobs. Default is 4.


  Host system software handling:
  --sys package:version=<dir>
                        Assume <dir> to be the installation location of
                        package:version in the system.
                        (e.g. --sys python:2.7=/opt/local/)
  --no-sys=<package>    Do not use host system version of <package>. If
                        package is 'ALL', do not use system versions at
                        all. (Ignored if package specified with --sys.)


  Environment variables:
  --var NAME=VALUE      Add environment variable NAME with VALUE. 
                        May be specified several times.
  --revar PATTERN       All environment variables matching the regular
                        expression PATTERN are preserved.
                        (E.g. --revar "SGE_.*", --revar NAME is equivalent
                        to -var NAME=\$NAME)


  Running options:
  --force               Reinstall the packages named with --require and the
                        packages they depend on.

  --interactive         Treat command-and-args as an interactive terminal.

  --no-run              Set up environment, but do not execute any payload.

  --prestage            Download all files to --distfiles <dir> before
                        processing.

  --silent              Do not print any progress information.
  --silent=plan         Do not print dependency information.

  --timeout SECONDS     Terminate after SECONDS have elapased. 
                        If 0, then the timeout is not activated (default).


  Listing software available:
  --list                List packages available with their versions.
                        Software that may be detected as already installed
                        is marked as 'auto' version 
  --list=section        List packages available, classified by
                        sections.
  --list=all            List all the packages available, even vc3-internals.


  Output modes:
  --env-to <file>       Write environment script to <file>.{,env,payload}, but
                        do not execute command-and-args.
                        To execute command-and-args, run ./<file>.

  --dot <file>          Write a dependency graph of the requirements to <file>.


  Parallel batch build mode:
  --parallel <dir>      Write specifications for a parallel build to <dir>.
                        (Implies --prestage.)

  --parallel-mode <m>   One of local, condor, slurm, workqueue, sge, pbs,
                        torque, or amazon. (Default is local.)

  --parallel-max  <n>   Maximum number of parallel concurrent jobs.
                        (Default is 10.)


  Developers options:
  --debug               On a builder error, print the full back-trace. 
  --sh-on-error         On building error, run $shell on the partially-built
                        environment.


Examples:
    ${script_name} --require cvmfs 'ls /cvmfs/atlas.cern.ch' 
    ${script_name} --require-os redhat7 --require maker-example-ecoli-01
EOF

}

sub main {
    my @requires     = ();

    my %pkg_opts;

    my $require_os;
    my $no_os_switch = 0;

    my @mounts       = ();

    my $print_help   = 0;
    my $make_jobs    = 4;
    my $sh_on_error  = 0;

    my $debug_modules_used = 0;
    my $dry_run            = 0;
    my $no_run             = 0;
    my $debug_run          = 0;
    my $interactive_run    = 0;
    my $force_rebuild      = 0;
    my $prestage           = 0;
    my $timeout;

    my $ignore_locks       = 0;

    my $env_to;
    my $dot_output;
    my $to_script;
    my $list_option;

    my $silent_option;

    my $parallel_dir;       
    my $parallel_mode;       
    my $parallel_max;       

    my $bosco_fix;

    my @extra_env_vars = ();
    my @databases   = ();
    my @re_vars     = ();
    my @sys_manual  = ();
    my @no_sys      = ();

    # if the executable name does looks like "perl", we use $0, as it has the
    # name of the script. Otherwise, this is a static run, and we use the given
    # executable name.
    my $script_name = ${EXECUTABLE_NAME} =~ /perl/ ? $0 : ${EXECUTABLE_NAME};

    my $original_command = join(' ', $script_name, @ARGV);
    
    VC3::Builder::remove_vc3_vars();
    VC3::Builder::fix_http_proxy_vars();

    my @saved_args = @ARGV;

    my $opt_result = GetOptions(
        "help"  => \$print_help,
        "debug" => \$debug_run,

        "silent:s" => sub { my ($o, $s) = @_; $silent_option = $s ? $s : 'ALL'},

        "database=s"  => \@databases,
        "require=s"   => \@requires, 

        "require-os=s" => \$require_os, 
        "no-os-switch" => \$no_os_switch, 

        "mount=s" => \@mounts,

        "option|o=s"     =>
            sub {
                my ($o, $s) = @_;
                my ($key, $value) = split('=', $s, 2);
                unless(defined $key and defined $value) {
                    die "\n--option should be of the form package=option\n";
                }
                $pkg_opts{$key} ||= [];
                push @{$pkg_opts{$key}}, $value;
            },

        "install=s" => \$vc3_root,
        "home=s"    => \$vc3_user_home,

        "distfiles=s"  => \$vc3_distfiles, 
        "repository=s" => \$vc3_repository, 

        "make-jobs=n" => \$make_jobs,

        "sh-on-error"     => \$sh_on_error,

        "force"           => \$force_rebuild,
        "ignore-locks"    => \$ignore_locks,

        "env-to=s"    => \$env_to,
        "dot=s"       => \$dot_output,
        "to-script=s" => \$to_script,

        "dry-run"  => \$dry_run,
        "no-run"   => \$no_run,
        "prestage" => \$prestage,
        "list:s"   => \$list_option,

        "bosco-workaround" => \$bosco_fix,

        "interactive" => \$interactive_run,

        "timeout=i"   => \$timeout,

        "sys=s"    => \@sys_manual,
        "no-sys=s" => \@no_sys,
        "var=s"    => \@extra_env_vars,
        "revar=s"  => \@re_vars,

        "parallel=s"  => \$parallel_dir,
        "parallel-mode=s" => \$parallel_mode,
        "parallel-max=i"  => \$parallel_max,

        # options for developing, not for runtime:
        "debug-modules-used" => \$debug_modules_used,
    );

    unless($opt_result) {
        die "\nTerminating because of invalid command line arguments.\n";
    }

    if($debug_run) {
        $SIG{__DIE__}  =  \&confess;
    }

    unshift @databases, '<internal>';

    if($print_help) {
        print usage($script_name);
        exit 0;
    }

    if($debug_modules_used) {
        print_modules_used();
        exit 0;
    }

    if(defined $dot_output) {
        push @no_sys, 'ALL';
        $dry_run = 1;
    }

    if(defined $to_script) {
        $dry_run = 1;
    }

    if(defined $list_option) {
        $silent_option = 'ALL';
        $dry_run = 1;
    }

    if(defined $timeout) {
        if($timeout < 0) {
            die 'timeout cannot be less than 0';
        } else {
            alarm $timeout;
        }
    }

    # split mounts
    my $mount_map = get_mount_map(@mounts);

    # set up parallel mode
    if(defined $parallel_dir) {
        push @no_sys, 'ALL';

        $parallel_mode ||= 'local';
        $parallel_max  ||= 10;

        if(@ARGV) {
            die "Cannot specify command-and-args with --parallel build mode.\n";
        }
    } else {
        if(defined($parallel_mode) or defined($parallel_max)) {
            die "Cannot use --parallel-mode or --parallel-max options without specifying --parallel\n";
        }
    }

    push @extra_env_vars, "MAKEFLAGS=-j${make_jobs}";
    push @extra_env_vars, "VC3_COMMAND_LINE=" . rel2abs(join(" ", $original_command));

    # honor paths from enclosing builder, if any.
    unshift @re_vars, 'VC3_.*';

    for my $pat (@re_vars) {
        for my $name (keys %ENV) {
            next unless $name =~ /$pat/;
            push @extra_env_vars, "$name='" . $ENV{$name} . "'";
        }
    }

    if($bosco_fix) {
        #remove this case once we figure out how to give installation paths to
        #bosco
        $vc3_root = bosco_fix_path($vc3_root);
    } else {
        is_safe_path($vc3_root);
    }

    # set default payload
    my @command_and_args;

    if(defined($parallel_dir)) {
        @command_and_args = ("sh -c 'cd $parallel_dir && ./build -T$parallel_mode -j$parallel_max -J$parallel_max'");
    } elsif(@ARGV) {
        @command_and_args = @ARGV;
    } else {
        @command_and_args = ($shell,);
        $interactive_run = 1;
    }

    my $bag = VC3::Bag->new(
        root       => $vc3_root,
        home       => $vc3_user_home,
        distfiles  => $vc3_distfiles,
        repository => $vc3_repository,
        shell      => $shell,
        dry_run    => $dry_run,
        on_terminal=> $interactive_run,
        silent     => $silent_option,
        databases  => \@databases,
        pkg_opts   => \%pkg_opts,
        sys_manual => \@sys_manual,
        no_sys     => \@no_sys,
        env_vars   => \@extra_env_vars);

    push @cleanups, sub { $bag->cleanup() };

    if(defined $list_option) {
        $bag->list_packages($list_option);
        exit(0);
    }

    if($require_os and not $no_os_switch) {
        # following call may produce an exec to a container.  original command line
        # is executed, dropping --require-os.
        my $exe = $0 eq '-e' ? $^X : $0;
        
        switch_os($bag, $require_os, $exe, \@saved_args, \@ARGV, $mount_map); # ARGV is original payload now.
    } else {
        unless(check_local_mounts($mount_map)) {
            die "Some mount points do not exists locally and no mounting can be performed natively.\n";
        }
    }

    unshift @requires, 'vc3-builder-hands';

    $bag->set_plan_for(@requires);

    if(defined $dot_output) {
        $bag->dot_graph($dot_output);
    }

    if(defined $to_script) {
        $bag->plan->to_script($to_script);
    }

    if($bag->dry_run) {
        exit 0;
    }

    $bag->check_manual_requirements();

    if(defined $parallel_dir) {
        $bag->to_parallel($parallel_dir, $make_jobs);
        $bag->check_manual_requirements();
 
        $bag->set_plan_for('cctools-statics');
        $ignore_locks = 1;
        $prestage     = 1;
    }

    if($prestage) {
        $bag->plan->prestage();
    }

    $bag->execute_plan($sh_on_error, $force_rebuild, $ignore_locks);
    
    # run the payload
    my $exit_code;
    if($no_run) {
        $exit_code = 0;
    } elsif($env_to) {
        $bag->preserve_profile(1);
        $bag->set_profile($env_to, @command_and_args);
        $exit_code = 0;
    } elsif(defined $parallel_dir) {
        $exit_code = $bag->execute(@command_and_args);
        if($exit_code) {
            warn "Parallel build mode failed.\n";
        }
    } else {
        $exit_code = $bag->execute(@command_and_args);
    }

    exit $exit_code;
}

sub print_modules_used {
    my $file = "stub-debug-modules.txt";

    unlink catfile($vc3_distfiles, $file);

    File::Path::make_path($vc3_distfiles);

    my $ff       = HTTP::Tiny->new();
    my $url      = $vc3_repository . '/' . $file;
    my $output   = catfile($vc3_distfiles,  $file);

    # dummy calls to trigger the use of the http module.
    my $response_a = $ff->mirror($url, $output);
    my $response_b = $ff->mirror($url, $output);

    my @modules = grep { /\.pm$/ } keys %INC;

    # turn :: into /
    map { s^/^::^g }   @modules;

    # remove .pm extension
    map { s^\.pm$^^g } @modules;

    # add modules that %INC sometimes does not find:
    my @manuals = 
    qw(
        encoding
        strict
        Cwd
        Digest::Perl::MD5
        English 
        Getopt::Long
        LockFile::Simple
        PerlIO
        Tie::RefHash );

    @modules = (@manuals, @modules);


    # remove duplicates
    @modules = uniq_words(@modules);

    @modules = sort { uc($a) cmp uc($b) } @modules;

    print join("\n", @modules), "\n";
}

sub uniq_words {
    my %words;
    for my $word (@_) {
        $words{$word} = 1;
    }

    return keys %words;
}

sub switch_os {
    my ($bag, $os, $exe, $all_args, $payload_args, $mount_map) = @_;

    # chop payload args from all args to only get builder args.
    my $builder_args  = [@{$all_args}];
    my $payload_count = scalar @{$payload_args};
    if($payload_count > 0) {
        splice @{$builder_args}, -1 * $payload_count;
    }
    splice @{$builder_args}, -1, 1 if $builder_args->[-1] eq '--';

    my ($name, $min, $max) = VC3::Plan->parse_requirement($os);

    my $pkg = $bag->{recipes}{op_sys}{$name};
    unless($pkg) {
        die "I don't know anything about operating system '$name'.\n";
    }

    # try to satisfy the os requirement
    for my $w (@{$pkg->widgets}) {

        unless($w->available) {
            next;
        }

        my $exit_status = -1;
        eval { $exit_status = $w->source->check_prerequisites() };

        if($exit_status) {
            next;
        }

        my $fmt = sprintf("OS %%-14s %12s %s:%s for %s", $w->source->type, $w->package->name, $w->version, $os);
        $bag->say(sprintf($fmt, 'trying:'));

        if($min and $min > $w->version) {
            $bag->say(sprintf($fmt, 'fail min:'));
            next;
        }

        if($max and $max < $w->version) {
            $bag->say(sprintf($fmt, 'fail max:'));
            next;
        }

        # if generic, simply check mount points.
        if($w->source->type eq 'os-native') {
            if(check_local_mounts($mount_map)) {
                return;
            } else {
                $bag->say(sprintf($fmt, 'fail mounts:'));
                next;
            }
        }

        eval {
            if($w->source) {
                $w->source->prepare_recipe_sandbox($exe, $builder_args, $payload_args, $mount_map);
            }

            unless($w->wrapper) {
                $bag->say(sprintf($fmt, 'fail wrapper:'));
                die "\n";
                
            }

            system @{$w->wrapper};
        };

        if($@) {
            $bag->say(sprintf($fmt, 'failed'));
            next;
        } else {
            # payload executed, so we end this builder.
            exit(0);
        }
    }

    die "Could not satisfy operating system requirement '$os'.\n";
}

sub get_mount_map {
    my (@mounts) = @_;

    my %mount_map;
    for my $spec (@mounts) {
        $spec =~ m/^(?<from>[^:]+)(:(?<to>.*))?/;

        unless($+{from}) {
            die "Malformed mount specification: '$spec'.\n";
        }

        $mount_map{$+{from}} = $+{to} || $+{from}; 

        unless(file_name_is_absolute($+{from})) {
            die "Path '$+{from}' is not absolute.\n";
        }

        unless(file_name_is_absolute($mount_map{$+{from}})) {
            die "Path '$mount_map{$+{from}}' is not absolute.\n";
        }
    }
    
    return \%mount_map;
}

sub check_local_mounts {
    my ($mount_map) = @_;

    my $all_present = 1;
    for my $from (keys %{$mount_map}) {
        my $to = $mount_map->{$from};

        if($from ne $to) {
            $all_present = 0;
            print("Mount source '$from' and target '$to' are different.\n");
        } elsif(! -d $to) {
            $all_present = 0;
            print("Mount target '$to' does not exist locally.\n");
        }
    }

    return $all_present;
}

sub is_safe_path {
    my ($root) = @_;

    my @chars = ($root =~ m/(${unsafe_path})/g);
    if(@chars) {
        my %uniq = map { ( $_ => 1 ) } @chars;

        if($uniq{"\n"}) {
            delete $uniq{"\n"};
            $uniq{'\n'} = 1;
        }

        die 'Terminating because installation path contains unsafe characters: ' . join(' ', keys %uniq) . "\n";
    }
}

sub bosco_fix_path {
    #remove this function once we figure out how to give installation paths to bosco
    #
    my ($original_root) = @_;

    $original_root = rel2abs($original_root);

    my $bosco_infix = qr^bosco/sandbox/[[:xdigit:]]+/[[:xdigit:]]+/^;

    eval { is_safe_path($original_root); };
    my $msg = $@;

    unless($msg) {
        # path does not need any fixes.
        return $original_root;
    }

    unless($original_root =~ m^(?<pre>.*?${bosco_infix})(?<post>.*)^) {
        die "This does not look like a bosco path with a sandbox.\n$msg\n";
    }

    my ($pre, $post) = ($+{pre}, $+{post});

    if($pre =~ m/${unsafe_path}/) {
        die "This bosco path cannot be fixed inside the sandbox.\n$msg\n";
    }

    $post =~ s^${unsafe_path}^_^g;
    $post =~ s^/^_^g;

    my $new_root = catfile($pre, $post); 

    warn "Fixing bosco path to '$new_root'\n";

    push @cleanups, sub { remove_tree($new_root) };
    make_path($new_root);

    my @files = (glob("${original_root}/*"), glob("${original_root}/.*"));

    for my $file (@files) {
        my $base = basename($file);

        next if $base eq '.';
        next if $base eq '..';

        symlink $file, catfile(${new_root}, $base);

        warn "symlinking $file ${new_root}/$base\n";
    }

    return $new_root;
}

sub select_sleep {
    my ($seconds) = @_;

    select(undef, undef, undef, $seconds);
}

sub cleanup_signal_handler {
    my ($signal) = @_;

    if($signal) {
        warn("Got signal!: $signal\n");

        if($signal eq 'ALRM') {
            warn("Timeout!\n");
        }

        exit 128;
    }
}

sub fix_http_proxy_vars {
    for my $var (qw(http_proxy HTTP_PROXY)) {
        my $val = $ENV{$var};

        if($val) {
            if($val =~ /^:?;?DIRECT$/) {
                delete $ENV{$var};
                next;
            }

            if($val !~ m#^https?://#) { 
                $ENV{$var} = "http://$val";
            }
        }
    }
}

sub remove_vc3_vars() {
    for my $var (keys %ENV) {
        if($var =~ '^VC3_') {
            delete $ENV{$var};
        }
    }
}



package VC3::Builder;
__DATA__
[

{
    "noop":{
        "versions":[
            {
                "version":"v0.0.1",
                "phony":1
            }
        ]
    },

    "vc3-builder-hands":{
        "versions":[
            {
                "version":"v1.0.0",
                "local":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "echo 'hello builder'"
                    ],
                    "dependencies":{
                        "tar":[
                            "v1.0"
                        ],
                        "gzip":[
                            "v1.0"
                        ],
                        "make":[
                            "v3.0"
                        ],
                        "sed":[
                            "v1.0"
                        ],
                        "pkg-config":[
                            "v0.23.0"
                        ],
                        "which":[
                            "v1.0"
                        ]
                    }
                }
            }
        ]
    },

    "static-get":{
        "versions":[
            {
                "version":"v1.0.0",
                "local":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "static-get"
                    ],
                    "prerequisites":[
                        "[ ${VC3_MACHINE_ARCH} = \"x86_64\" ] || exit 1"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "cp -L static-get ${VC3_PREFIX}/bin",
                        "chmod 755 ${VC3_PREFIX}/bin/static-get"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "pax":{
        "tags":["file utilities"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2016.11.4",
                "source":{
                    "type":"tarball",
                    "files":[
                        "pax-20161104.tar.gz"
                    ],
                    "recipe":[
                        "${CC} -O2 -o pax  -DPAX_SAFE_PATH=\\\"/bin\\\" *.c",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "cp pax ${VC3_PREFIX}/bin"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "sharutils":{
        "tags":["file utilities"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v4.15.0",
                "source":{
                    "type":"configure",
                    "files":[
                        "sharutils-4.15.tar.gz"
                    ]
                },
                "dependencies":{
                    "c-build-environment":[
                        "v1.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "r-lang":{
        "tags":["programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v3.5.1",
                "source":{
                    "type":"configure",
                    "files":[
                        "R-3.5.1.tar.gz"
                    ]
                },
                "dependencies":{
                    "c-build-environment":[
                        "v1.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "gcc":{
        "tags":["compilation tools", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"gcc"
                }
            },
            {
                "version":"v4.6.1",
                "local":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "gcc-4.6.1-2.tar.gz"
                    ],
                    "recipe":[
                        ": from static-get",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xf gcc-4.6.1-2.tar.gz"
                    ]
                },
                "environment-variables":[
                    {
                        "name":"C_INCLUDE_PATH",
                        "value":"lib/gcc/i586-linux-uclibc/4.6.1/include"
                    }
                ]
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ],
        "environment-variables":[
            {
                "name":"CC",
                "value":"gcc",
                "absolute":1,
                "clobber":1
            }
        ]
    },

    "gcc-cplusplus":{
        "tags":["compilation tools", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"g++"
                }
            },
            {
                "version":"5.3.0",
                "source":{
                    "type":"system",
                    "prerequisites":[
                        "case \"${VC3_MACHINE_TARGET}\" in x86_64/redhat7*);; *) exit 1;; esac",
                        "stat /cvmfs/cms.cern.ch/slc7_amd64_gcc530/external/gcc/5.3.0"
                    ],
                    "recipe":[
                        "echo \"VC3_ROOT_SYSTEM: /cvmfs/cms.cern.ch/slc7_amd64_gcc530/external/gcc/5.3.0\""
                    ]
                },
                "dependencies":{
                    "cvmfs":[
                        "v2.0"
                    ]
                }
            },
            {
                "version":"5.3.0",
                "source":{
                    "type":"system",
                    "prerequisites":[
                        "case \"${VC3_MACHINE_TARGET}\" in x86_64/redhat6*);; *) exit 1;; esac",
                        "stat /cvmfs/cms.cern.ch/slc6_amd64_gcc530/external/gcc/5.3.0"
                    ],
                    "recipe":[
                        "echo \"VC3_ROOT_SYSTEM: /cvmfs/cms.cern.ch/slc6_amd64_gcc530/external/gcc/5.3.0\""
                    ]
                },
                "dependencies":{
                    "cvmfs":[
                        "v2.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ],
        "environment-variables":[
            {
                "name":"LD_LIBRARY_PATH",
                "value":"lib64"
            },
            {
                "name":"CC",
                "value":"gcc",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"CXX",
                "value":"g++",
                "absolute":1,
                "clobber":1
            }
        ]
    },

    "gcc-fortran":{
        "tags":["compilation tools", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"gfortran"
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },

    "make":{
        "tags":["compilation tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"make"
                }
            },
            {
                "version":"v3.82",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "make-x86_64-3.82.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "sed":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"sed"
                }
            },
            {
                "version":"v4.2",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "sed-x86_64-4.2.tar.gz"
                    ]
                }
            },
            {
                "version":"v4.7",
                "local":1,
                "source":{
                    "type":"configure",
                    "files":[
                        "sed-4.7.tar.gz"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "grep":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"grep"
                },
                "version":"v2.6.3",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "grep-x86_64-2.6.3-2.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "gawk":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"gawk"
                },
                "version":"v4.1.1",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "gawk-x86_64-4.1.1.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "which":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"which"
                }
            },
            {
                "version":"v2.20.0",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "which-x86_64-2.20-1.tar.gz"
                    ]
                }
            },
            {
                "version":"v2.21.0",
                "source":{
                    "type":"configure",
                    "files":[
                        "which-2.21.tar.gz"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "coreutils":{
        "versions":[
            {
                "version":"v7.6.0",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "coreutils-x86_64-7.6-5.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "tar":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"tar"
                }
            },
            {
                "version":"v1.23.0",
                "local":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "tar-1.23"
                    ],
                    "recipe":[
                        ": from static-get",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "cp -L tar-1.23 ${VC3_PREFIX}/bin/tar",
                        "chmod 755 ${VC3_PREFIX}/bin/tar"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "gzip":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"gzip"
                }
            },
            {
                "version":"v1.4.0",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "gzip-x86_64-1.4-1.tar"
                    ]
                },
                "dependencies":{
                    "tar":[
                        "v1.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "bzip2":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"bzip2"
                }
            },
            {
                "version":"v1.0.6",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "bzip2-bin-1.0.6-1.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "xz":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"xz"
                }
            },
            {
                "version":"v5.0.5",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "xz-x86_64-5.0.5.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "pkg-config":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"pkg-config"
                }
            },
            {
                "version":"v0.23",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "pkg-config-x86_64-0.23-1.tar.gz"
                    ]
                }
            },
            {
                "version":"v0.23",
                "local":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "pkg-config-0.23-1.tar.gz"
                    ],
                    "recipe":[
                        ": from static-get",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xf pkg-config-0.23-1.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "icecube-argonne-demo":{
        "tags":["demos"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.0",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "icecube-argonne-demo-01.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/icecube-argonne-demo-01",
                        "tar -C ${VC3_INSTALL_USER_HOME}/icecube-argonne-demo-01 --strip-components=1 -xpf icecube-argonne-demo-01.tar.gz"
                    ]
                },
                "dependencies":{
                    "icecube-environment":[
                        "v1.0"
                    ],
                    "python":[
                        "v2.6"
                    ]
                }
            }
        ]
    },

    "icecube-environment":{
        "tags":["environments"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.0",
                "prologue": [
                    "eval $(/cvmfs/icecube.opensciencegrid.org/py2-v3.0.1/setup.sh)"
                ],
                "dependencies":{
                    "cvmfs":[
                        "v2.0"
                    ],
                    "python":[
                        "v2.6"
                    ]
                }
            }
        ]
    },

    "oasis-environment":{
        "tags":["environments"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.0",
                "prologue": [
                    "source /cvmfs/oasis.opensciencegrid.org/osg/modules/lmod/current/init/bash"
                ],
                "dependencies":{
                    "cvmfs":[
                        "v2.0"
                    ]
                }
            }
        ]
    },

    "atlas-local-root-base-environment":{
        "tags":["environments"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.0",
                "prologue": [
                    "export ATLAS_LOCAL_ROOT_BASE=/cvmfs/atlas.cern.ch/repo/ATLASLocalRootBase",
                    "source ${ATLAS_LOCAL_ROOT_BASE}/user/atlasLocalSetup.sh"
                ],
                "dependencies":{
                    "cvmfs":[
                        "v2.0"
                    ]
                }
            }
        ]
    },

    "cmssw-environment":{
        "tags":["environments"],
        "versions":[
            {
                "version":"1.0",
                "phony":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "if [ -z $VC3_OPTIONS_CMSSW_ENVIRONMENT ]; then",
                        "cat <<EOF",
                        "    No CMSSW environment defined. For example:",
                        "    vc3-builder -o cmssw-environment=CMSSW_9_3_0_pre2 ...",
                        "EOF",
                        "exit 1",
                        "fi"
                    ]
                },
                "prologue":[
                    ". /cvmfs/cms.cern.ch/cmsset_default.sh",
                    "if [ ! -d ${HOME}/${VC3_OPTIONS_CMSSW_ENVIRONMENT} ]; then",
                    "   cd ${HOME}",
                    "   vc3_cmsrel=$(alias cmsrel | sed -r -e \"s/.*='(.*)'/\\1/\")",
                    "   ${vc3_cmsrel} ${VC3_OPTIONS_CMSSW_ENVIRONMENT}",
                    "fi",
                    "if [ -d ${HOME}/${VC3_OPTIONS_CMSSW_ENVIRONMENT} ]; then",
                    "    cd ${HOME}/${VC3_OPTIONS_CMSSW_ENVIRONMENT}",
                    "    vc3_cmsenv=$(alias cmsenv | sed -r -e \"s/.*='(.*)'/\\1/\")",
                    "    ${vc3_cmsenv} ${VC3_OPTIONS_CMSSW_ENVIRONMENT}",
                    "    cd ${HOME}",
                    "fi"
                ],
                "dependencies":{
                    "cvmfs":[
                        "v2.0"
                    ]
                }
            }
        ]
    },

    "vc3-glidein":{
        "versions": [
            {
                "version":"v1.1.8",
                "source":{
                    "type":"tarball",
                    "files":[
                        "vc3-glidein-v1.1.8.tar.gz"
                    ],
                    "recipe":[
                        "chmod 755 vc3-glidein",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "mv vc3-glidein ${VC3_PREFIX}/bin"
                    ]
                }
            },
            {
                "version":"v1.0",
                "source":{
                    "type":"generic",
                    "mirrors":[
                        "https://raw.githubusercontent.com/vc3-project/vc3-glidein/master"
                    ],
                    "files":[
                        "vc3-glidein"
                    ],
                    "recipe":[
                        "chmod 755 vc3-glidein",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "mv vc3-glidein ${VC3_PREFIX}/bin"
                    ]
                }
            }
        ],
        "dependencies":{
            "python":[
                "v2.6"
            ]
        },
        "environment-autovars":[
            "PATH"
        ]
    },

    "osg-advertise": {
        "tags":["environments"],
        "versions": [
            {
                "version": "v0.0.1",
                "source":{ 
                    "type":"generic",
                    "mirrors":[
                        "https://raw.githubusercontent.com/opensciencegrid/osg-flock/master/node-check"
                    ],
                    "files":[
                        "osgvo-node-advertise"
                    ],
                    "recipe":[
                        "chmod 755 osgvo-node-advertise",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "mv osgvo-node-advertise ${VC3_PREFIX}/bin"
                    ]
                }
            },
            {
                "version": "v0.0.2",
                "source": {
                    "type":"generic",
                    "mirrors":[
                        "http://stash.ci-connect.net/~briedel/"
                    ],
                    "files":[
                        "osg-env"
                    ],
                    "recipe":[
                        "chmod 755 osg-env",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "mv osg-env ${VC3_PREFIX}/bin"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    

    "osg-advertise-wrapper": {
        "tags": ["environments"],
        "show-in-list": 1,
        "versions": [
            {
                "version": "v0.0.1",
                "wrapper": [
                    "osgvo-node-advertise"
                ],
                "dependencies": {
                    "osg-advertise": [
                        "v0.0.1"
                    ]
                }
            },
            {
                "version": "v0.0.2",
                "prologue": [
                    "source ${VC3_ROOT_OSG_ADVERTISE}/bin/osg-env"
                ],
                "dependencies": {
                    "osg-advertise": [
                        "v0.0.2"
                    ]
                }
            }
        ]
    },

    "cvmfs-parrot-libcvmfs":{
        "versions":[
            {
                "version":"v2.4.0",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "stat /cvmfs/cms.cern.ch"
                    ],
                    "dependencies":{
                        "parrot-wrapper":[
                            "v6.0.0"
                        ]
                    }
                }
            }
        ]
    },

    "cvmfs":{
        "tags":["file systems"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "auto-version":[
                        "echo VC3_VERSION_SYSTEM: $(cvmfs2 -V | sed -r -e 's/CernVM-FS version\\s+([0-9]+\\.[0-9]+\\.[0-9]+)(\\.[0-9])?/\\1/')" 
                    ],
                    "prerequisites":[
                        "stat /cvmfs/cms.cern.ch"
                    ],
                    "recipe":[
                        "echo \"VC3_ROOT_SYSTEM: /\""
                    ]
                },
                "environment-variables":[
                    {
                        "name":"VC3_PARROT_EXTRA_OPTIONS",
                        "value":"--disable-service=cvmfs",
                        "absolute":1,
                        "clobber":1
                    }
                ]
            },
            {
                "version":"v2.4.0",
                "dependencies":{
                    "cvmfs-parrot-libcvmfs":[
                        "v2.4.0"
                    ]
                }
            }
        ]
    },

    "parrot-wrapper":{
        "tags":["file systems"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v7.0.6",
                "wrapper":[
                    "parrot_run",
                    "--dynamic-mounts",
                    "-p", "\"${PARROT_HTTP_PROXY}\"",
                    "--cvmfs-repo-switching",
                    "$(echo ${VC3_PARROT_EXTRA_OPTIONS} | sed -e 's/:/ /g')",
                    "{}"
                ],
                "dependencies":{
                    "cctools":[
                        "v7.0.6"
                    ]
                }
            }
        ]
    },

    "parrot-static":{
        "versions":[
            {
                "version":"v7.0.11",
                "source":{
                    "type":"tarball",
                    "files":[
                        "cctools-7.0.11-source.tar.gz"
                    ],
                    "mirrors":[
                        "http://ccl.cse.nd.edu/software/files/"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "./configure --prefix ${VC3_PREFIX} --without-system-sand --without-system-allpairs --without-system-wavefront --without-system-makeflow --without-system-umbrella --without-system-prune --without-system-resource_monitor --without-system-doc --with-zlib-path ${VC3_ROOT_ZLIB} --with-cvmfs-path ${VC3_ROOT_LIBCVMFS} --with-uuid-path ${VC3_ROOT_UUID} --with-openssl-path ${VC3_ROOT_OPENSSL} --with-fuse-path ${VC3_ROOT_FUSE} --with-globus-path no --with-irods-path no --with-mysql-path no --with-xrootd-path no",
                        "make",
                        "(cd parrot/src && make parrot_cvmfs_static_run && cp parrot_cvmfs_static_run ${VC3_PREFIX}/bin)"
                    ],
                    "dependencies":{
                        "zlib":[
                            "v1.2"
                        ],
                        "libcvmfs":[
                            "v2.2"
                        ],
                        "fuse":[
                            "v2.9"
                        ],
                        "openssl":[
                            "v1.0"
                        ],
                        "uuid":[
                            "v1.0"
                        ],
                        "gcc-cplusplus":[
                            "v4.4"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ]
    },

    "cctools-catalog-server":{
        "versions":[
            {
                "version":"v6.0.0",
                "dependencies":{
                    "cctools-statics":[
                        "v0.0.1"
                    ]
                }
            },
            {
                "version":"v6.0.0",
                "dependencies":{
                    "cctools":[
                        "v6.0.0"
                    ]
                }
            }
        ]
    },

    "cctools-binary":{
        "versions":[
            {
                "version":"v7.0.6",
                "source":{
                    "type":"binary",
                    "native":"x86_64/redhat7",
                    "files":[
                        "cctools-7.0.6-x86_64-redhat7.tar.gz"
                    ],
                    "mirrors":[
                        "http://ccl.cse.nd.edu/software/files/"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cctools-7.0.6-x86_64-redhat7.tar.gz",

                        "mkdir -p $(python -m site --user-site)",
                        "cp -r ${VC3_PREFIX}/lib/python${VC3_VERSION_PYTHON}/site-packages $(python -m site --user-site)"
                    ],
                    "dependencies":{
                        "perl":[
                            "v5.16"
                        ],
                        "python":[
                            "v2.7.0"
                        ]
                    }
                }
            },
            {
                "version":"v7.0.6",
                "source":{
                    "type":"binary",
                    "native":"x86_64/redhat6",
                    "files":[
                        "cctools-7.0.6-x86_64-redhat6.tar.gz"
                    ],
                    "mirrors":[
                        "http://ccl.cse.nd.edu/software/files/"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cctools-7.0.6-x86_64-redhat6.tar.gz",
                        "mkdir -p $(python -m site --user-site)",
                        "cp -r ${VC3_PREFIX}/lib/python${VC3_VERSION_PYTHON}/site-packages $(python -m site --user-site)"
                    ],
                    "dependencies":{
                        "perl":[
                            "v5.10.0"
                        ],
                        "python":[
                            "v2.6.0"
                        ]
                    }
                }
            }
        ],
        "dependencies":{
            "zlib":[
                "v1.2"
            ]
        },
        "environment-autovars":[
            "PATH", "PERL5LIB"
        ],
        "environment-variables":[
            {
                "name":"PARROT_HTTP_PROXY",
                "value":":;DIRECT",
                "clobber":1,
                "absolute":1
            }
        ]
    },

    "cctools-source":{
        "versions":[
            {
                "version":"v7.0.6",
                "source":{
                    "type":"configure",
                    "files":[
                        "cctools-7.0.6-source.tar.gz"
                    ],
                    "mirrors":[
                        "http://ccl.cse.nd.edu/software/files/"
                    ],
                    "options":"--without-system-umbrella --without-system-prune --without-system-doc --with-swig-path ${VC3_ROOT_SWIG} --with-python-path ${VC3_ROOT_PYTHON} --with-perl-path ${VC3_ROOT_PERL} --with-zlib-path ${VC3_ROOT_ZLIB} --with-cvmfs-path ${VC3_ROOT_LIBCVMFS} --with-uuid-path ${VC3_ROOT_UUID} --with-openssl-path ${VC3_ROOT_OPENSSL} --with-fuse-path ${VC3_ROOT_FUSE} --with-globus-path no --with-irods-path no --with-mysql-path no --with-xrootd-path no",
                    "postface":[
                        "mkdir -p $(python -m site --user-site)",
                        "cp -r ${VC3_PREFIX}/lib/python${VC3_VERSION_PYTHON}/site-packages $(python -m site --user-site)"
                    ],
                    "dependencies":{
                        "swig":[
                            "v3.0"
                        ],
                        "python":[
                            "v2.6"
                        ],
                        "perl":[
                            "v5.10"
                        ],
                        "libcvmfs":[
                            "v2.2"
                        ],
                        "fuse":[
                            "v2.9"
                        ],
                        "openssl":[
                            "v1.0"
                        ],
                        "uuid":[
                            "v1.0"
                        ],
                        "gcc-cplusplus":[
                            "v4.4"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "dependencies":{
            "zlib":[
                "v1.2"
            ]
        },
        "environment-autovars":[
            "PATH", "PERL5LIB"
        ],
        "environment-variables":[
            {
                "name":"PARROT_HTTP_PROXY",
                "value":":;DIRECT",
                "clobber":1,
                "absolute":1
            }
        ]
    },

    "cctools":{
        "tags":["workflow tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v7.0.6",
                "dependencies":{
                    "cctools-binary":[
                        "v7.0.6"
                    ]
                }
            },
            {
                "version":"v7.0.6",
                "dependencies":{
                    "cctools-source":[
                        "v7.0.6"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"PARROT_HTTP_PROXY",
                "value":":;DIRECT",
                "clobber":1,
                "absolute":1
            }
        ]
    },

    "cctools-unstable":{
        "tags":["workflow tools"],
        "show-in-list":1,
        "phony":1,
        "versions":[
            {
                "version":"v999.999.999",
                "source":{
                    "type":"binary",
                    "native":"x86_64/redhat7",
                    "recipe":[
                        "wget http://ccl.cse.nd.edu/software/autobuild/commit/most-recent/cctools-current-x86_64-redhat7.tar.gz",
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cctools-*-redhat7.tar.gz",
                        "mkdir -p $(python -m site --user-site)",
                        "cp -r ${VC3_PREFIX}/lib/python${VC3_VERSION_PYTHON}/site-packages $(python -m site --user-site)"
                    ],
                    "dependencies":{
                        "perl":[
                            "v5.16"
                        ],
                        "python":[
                            "v2.7.0"
                        ],
                        "wget":[
                            "v1.0"
                        ]
                    }
                }
            },
            {
                "version":"v999.999.999",
                "source": {
                    "type":"binary",
                    "native":"x86_64/redhat6",
                    "recipe":[
                        "wget http://ccl.cse.nd.edu/software/autobuild/commit/most-recent/cctools-current-x86_64-redhat6.tar.gz",
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cctools-*-redhat6.tar.gz",
                        "mkdir -p $(python -m site --user-site)",
                        "cp -r ${VC3_PREFIX}/lib/python${VC3_VERSION_PYTHON}/site-packages $(python -m site --user-site)"
                    ],
                    "dependencies":{
                        "perl":[
                            "v5.10.0"
                        ],
                        "python":[
                            "v2.6.0"
                        ]
                    }
                }
            }
        ],
        "dependencies":{
            "zlib":[
                "v1.2"
            ],
            "wget":[
                "v1.0"
            ]
        },
        "environment-autovars":[
            "PATH", "PERL5LIB"
        ],
        "environment-variables":[
            {
                "name":"PARROT_HTTP_PROXY",
                "value":":;DIRECT",
                "clobber":1,
                "absolute":1
            }
        ]
    },

    "swig":{
        "tags":["compilation tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v3.0.12",
                "source":{
                    "type":"configure",
                    "files":[
                        "swig-3.0.12.tar.gz"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib",
                    "dependencies":{
                        "pcre":[
                            "v8.34"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "e2fsprogs":{
        "tags":["file systems"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v1.44.5",
                "source":{
                    "type":"configure",
                    "files":[
                        "e2fsprogs-1.44.5.tar.gz"
                    ],
                    "preface":[
                        "export LN='/bin/cp -pR'"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-symlink-install",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ]
    },

    "patch":{
        "tags":["file utilities", "compilation tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"patch"
                }
            },
            {
                "version":"v2.7.5",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "patch-x86_64-2.7.5.tar.gz"
                    ]
                }
            },
            {
                "version":"v2.7.5",
                "source":{
                    "type":"configure",
                    "files":[
                        "patch-2.7.5.tar.gz"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "cmake":{
        "tags":["compilation tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"cmake",
                    "auto-version":[
                        "echo VC3_VERSION_SYSTEM: $(cmake --version | sed -r -e 's/cmake version ([0-9]+\\.[0-9]+)(\\.[0-9])?/\\1/')" 
                    ]
                }
            },
            {
                "version":"v3.10.2",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "cmake-3.10.2-Linux-x86_64.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cmake-3.10.2-Linux-x86_64.tar.gz"
                    ]
                }
            },
            {
                "version":"v3.5.2",
                "source":{
                    "type":"tarball",
                    "files":[
                        "cmake-3.5.2.tar.gz"
                    ],
                    "recipe":[
                        "prefix=$(echo ${VC3_PREFIX} | sed -e 's/#/_/g')",
                        "./bootstrap --prefix=${prefix}",
                        ": ./bootstrap --prefix=${VC3_PREFIX}",
                        "make",
                        "make install"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "libcvmfs":{
        "versions":[
            {
                "version":"v2.7.1",
                "source":{
                    "type":"tarball",
                    "files":[
                        "cvmfs-2.7.1.tar.gz"
                    ],
                    "recipe":[
                        "export CPLUS_INCLUDE_PATH=${VC3_ROOT_UUID}/include",                                           
                        "mkdir -p build",
                        "cd build",
                        ": set NO_INTERNET to stop parcparser tests",
                        "export NO_INTERNET=1",
                        ": to force openssl static, nullify PKG_CONFIG_PATH",
                        ": export PKG_CONFIG_PATH=invalid",
                        "sed -i '305ifind_package (FUSE REQUIRED)' ../CMakeLists.txt",
                        "sed -i '306iset (INCLUDE_DIRECTORIES ${INCLUDE_DIRECTORIES} ${FUSE_INCLUDE_DIR} ${ATTR_INCLUDE_DIR})' ../CMakeLists.txt",
                        "cmake -Wno-dev -DINSTALL_MOUNT_SCRIPTS=OFF -DBUILD_SERVER:BOOL=OFF -DBUILD_CVMFS:BOOL=OFF -DBUILD_LIBCVMFS:BOOL=ON -DINSTALL_BASH_COMPLETION:BOOL=OFF -DUUID_LIBRARY=${VC3_ROOT_UUID}/lib/libuuid.a -DUUID_INCLUDE_DIR:PATH=${VC3_ROOT_UUID}/include -DZLIB_LIBRARY=${VC3_ROOT_ZLIB}/lib/libz.a -DZLIB_INCLUDE_DIR:PATH=${VC3_ROOT_ZLIB}/include -DOPENSSL_ROOT_DIR:PATH=${VC3_ROOT_OPENSSL} -DOPENSSL_INCLUDE_DIR:PATH=${VC3_ROOT_OPENSSL}/include -DOPENSSL_CRYPTO_LIBRARY:PATH=${VC3_ROOT_OPENSSL}/lib/libcrypto.a -DOPENSSL_SSL_LIBRARY:PATH=${VC3_ROOT_OPENSSL}/lib/libssl.a -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} -DFUSE_INCLUDE_DIR:PATH=${VC3_ROOT_FUSE}/include -DFUSE_LIBRARY=${VC3_ROOT_FUSE}/lib/libfuse.a -DATTR_INCLUDE_DIR:PATH=${VC3_ROOT_ATTR}/include .. -DATTR_LIBRARY=${VC3_ROOT_ATTR}/lib/libattr.a",
                        "cd cvmfs",
                        "make libcvmfs",
                        "mkdir -p ${VC3_PREFIX}/lib",
                        "mkdir -p ${VC3_PREFIX}/include",
                        "cp libcvmfs.a ${VC3_PREFIX}/lib",
                        "cp ../../cvmfs/libcvmfs*.h ${VC3_PREFIX}/include"
                    ],
                    "dependencies":{
                        "uuid":[
                            "v1.0"
                        ],
                        "zlib":[
                            "v1.2"
                        ],
                        "fuse":[
                            "v2.9"
                        ],
                        "cmake":[
                            "v3.1"
                        ],
                        "patch":[
                            "v2.0"
                        ],
                        "attr":[
                            "v2.4"
                        ],
                        "openssl":[
                            "v1.0"
                        ],
                        "python":[
                            "v2.6"
                        ]
                    }
                },
                "environment-variables":[
                    {
                        "name":"LD_LIBRARY_PATH",
                        "value":"lib64"
                    }
                ]
            }
        ]
    },

    "uuid":{
        "versions":[
            {
                "version":"v1.0.3",
                "source":{
                    "type":"configure",
                    "files":[
                        "libuuid-1.0.3.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static --enable-shared",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },

    "openssl":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"openssl",
                    "auto-version":[
                        "pkg-config openssl --exists",
                        "echo VC3_VERSION_SYSTEM: $(openssl version -v | sed -r -e 's/OpenSSL (([0-9]+\\.){2}[0-9]+).*/\\1/')"
                    ]
                }
            },
            {
                "version":"v1.0.2",
                "source":{
                    "type":"tarball",
                    "files":[
                        "openssl-1.0.2h.tar.gz"
                    ],
                    "recipe":[
                        "./config -fPIC --prefix=${VC3_PREFIX} --libdir=lib -D_GNU_SOURCE -DOPENSSL_NO_HEARTBEAT -Wl,-rpath=${VC3_PREFIX}/lib shared no-zlib no-comp no-weak-ssl-ciphers",
                        "make depend",
                        "make build_all",
                        "make install_sw"
                    ]
                },
                "dependencies":{
                    "perl":[
                        "v5.10"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },

    "openssl-static":{
        "versions":[
            {
                "version":"v1.0.2",
                "source":{
                    "type":"tarball",
                    "files":[
                        "openssl-1.0.2h.tar.gz"
                    ],
                    "recipe":[
                        "CC=musl-gcc ./config -fPIC --prefix=${VC3_PREFIX} --libdir=lib -DOPENSSL_NO_HEARTBEAT -Wl,-rpath=${VC3_PREFIX}/lib no-shared no-zlib no-comp no-weak-ssl-ciphers",
                        "make depend",
                        "make build_all",
                        "make install_sw"
                    ]
                },
                "dependencies":{
                    "perl":[
                        "v5.10"
                    ]
                },
                "musl-zlib":[
                    "v1.2.0"
                ],
                "musl":[
                    "v1.0"
                ]
            }
        ],
        "environment-autovars":[
            "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },


    "libssh2":{
        "versions":[
            {
                "version":"v1.8.0",
                "source":{
                    "type":"configure",
                    "files":[
                        "libssh2-1.8.0.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--with-libssl-prefix=${VC3_ROOT_OPENSSL} --enable-static=yes --enable-shared=yes"
                },
                "dependencies":{
                    "openssl":[
                        "v1.0.2"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "gss":{
        "versions":[
            {
                "version":"v1.0.3",
                "source":{
                    "type":"configure",
                    "files":[
                        "gss-1.0.3.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--enable-static=yes --enable-shared=no",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "curl":{
        "tags":["data transfer tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v7.53.1",
                "source":{
                    "type":"tarball",
                    "files":[
                        "curl-7.53.1.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "export LIBS='-ldl -lz'",
                        "./configure --prefix=${VC3_PREFIX} --enable-static=yes --enable-shared=yes --enable-http --enable-ftp --enable-file --enable-proxy --enable-tftp --disable-ldap --disable-ldaps --with-ssl=${VC3_ROOT_OPENSSL} --with-libssh2=${VC3_ROOT_LIBSSH2} --with-zlib=${VC3_ROOT_ZLIB}  --with-gssapi=${VC3_ROOT_GSS}/bin --with-gssapi-libs=${VC3_ROOT_GSS}/lib",
                        "make",
                        "make install"
                    ]
                },
                "dependencies":{
                    "zlib":[
                        "v1.2"
                    ],
                    "openssl":[
                        "v1.0.2"
                    ],
                    "gss":[
                        "v1.0.3"
                    ],
                    "libssh2":[
                        "v1.8.0"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },

    "wget":{
        "tags":["data transfer tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"wget"
                }
            },
            {
                "version":"v1.81",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "wget-1.18-1.tar.gz"
                    ]
                }
            },
            {
                "version":"v1.19.4",
                "source":{
                    "type":"tarball",
                    "files":[
                        "wget-1.19.4.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX} --with-zlib --with-ssl=openssl --with-libssl-prefix=${VC3_ROOT_OPENSSL} --with-libuuid",
                        "make",
                        "make install"
                    ]
                },
                "dependencies":{
                    "zlib":[
                        "v1.2"
                    ],
                    "openssl":[
                        "v1.0.2"
                    ],
                    "uuid":[
                        "v1.0"
                    ],
                    "libssh2":[
                        "v1.8.0"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "git":{
        "tags":["source version control", "compilation tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"git",
                    "auto-version":[
                        "echo VC3_VERSION_SYSTEM: $(git --version | sed -r -e 's/git version (([0-9]+\\.){2}[0-9]+).*/\\1/')"
                    ]
                }
            },
            {
                "version":"v2.7.2",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "git-x86_64-2.7.2-2.tar.gz"
                    ]
                },
                "environment-autovars":[
                    "PATH"
                    ]
            },
            {
                "version":"v2.12.0",
                "source":{
                    "type":"configure",
                    "files":[
                        "git-2.12.0.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--with-openssl=${VC3_ROOT_OPENSSL} --with-curl=${VC3_ROOT_CURL} --with-zlib=${VC3_ROOT_ZLIB} --with-perl=${VC3_ROOT_PERL}/bin/perl --with-python=${VC3_ROOT_PYTHON}/bin/python --without-tcltk"
                },
                "dependencies":{
                    "zlib":[
                        "v1.2"
                    ],
                    "openssl":[
                        "v1.0.2"
                    ],
                    "gss":[
                        "v1.0.3"
                    ],
                    "curl":[
                        "v7.53.1"
                    ],
                    "libssh2":[
                        "v1.8.0"
                    ],
                    "perl":[
                        "v5.24"
                    ],
                    "python":[
                        "v2.7"
                    ],
                    "perl-extutils-makemaker":[
                        "v7.24.0"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "condor-personal":{
        "versions":[
            {
                "version":"v8.6.0",
                "phony":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        ": run as condor_master -f",
                        "cd ${VC3_ROOT_CONDOR}",
                        "[ -f etc/condor_config ] && rm etc/condor_config",
                        "if [ ! -f ${VC3_ROOT_CONDOR}/etc/condor_config.local ]; then",
                        "    echo SCHEDD_NAME = $$.$(hostname)    >> ${VC3_ROOT_CONDOR}/condor_config.local",
                        "    echo ALLOW_WRITE = \\*               >> ${VC3_ROOT_CONDOR}/condor_config.local",
                        "fi",
                        "./condor_install --make-personal-condor"
                    ]
                }
            }
        ],
        "dependencies":{
            "condor":[
                "v8.6.0"
            ]
        },
        "environment-variables":[
            {
                "name":"CONDOR_CONFIG",
                "value":"${VC3_ROOT_CONDOR}/etc/condor_config",
                "absolute":1,
                "clobber":1
            }
        ]
    },

    "condor-configure":{
        "versions":[
            {
                "version":"v8.6.0",
                "sources":[
                    {
                        "type":"generic",
                        "phony":1,
                        "recipe":[
                            "echo BROKEN FOR NOW",
                            "exit 1",
                            ": run as condor_master -dyn -f",
                            "if [ -z \"${VC3_CONDOR_CONFIG_OPTIONS}\" ]; then",
                            "export VC3_CONDOR_CONFIG_OPTIONS='--make-personal-condor --type=submit,manager,execute'",
                            "cat <<EOF",
                            "   No VC3_CONDOR_CONFIG_OPTIONS defined. Examples:",
                            "   export VC3_CONDOR_CONFIG_OPTIONS='--type=submit,manager --central-manager \\$(hostname -i)'",   
                            "   export VC3_CONDOR_CONFIG_OPTIONS='--type=submit --central-manager somewhere.net'",
                            "   export VC3_CONDOR_CONFIG_OPTIONS='--type=execute --central-manager somewhere.net'",
                            "   using: ${VC3_CONDOR_CONFIG_OPTIONS}",
                            "EOF",
                            "fi",
                            "if [ -z \"${VC3_CONDOR_PASSWORD}\" ]; then",
                            "cat <<EOF",
                            "   [Warning]: No VC3_CONDOR_PASSWORD defined.",
                            "   Condor will use the default authentication protocols (FS, CLAIMTOBE).",
                            "EOF",
                            "elif [ ! -f \"${VC3_CONDOR_PASSWORD}\" ]; then",
                            "   echo \"[Error]: Could not find:  \"${VC3_CONDOR_PASSWORD}\"\"",
                            "   exit 1",
                            "fi",
                            "export CONDOR_CONFIG=${VC3_CONDOR_LOCAL_DIR}/etc/condor_config",
                            ": rm -f ${CONDOR_CONFIG}",
                            "cd ${VC3_ROOT_CONDOR}",
                            "if [ ! -f ${VC3_CONDOR_LOCAL_DIR}/etc/condor_config.local ]; then",
                            "    echo SCHEDD_NAME = $$.$(hostname)    >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "    echo ALLOW_WRITE = \\*               >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "    if [ -n \"${VC3_CONDOR_PASSWORD}\" ]; then",
                            "       echo SEC_PASSWORD_FILE = ${VC3_CONDOR_PASSWORD}    >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo SEC_DEFAULT_AUTHENTICATION_METHODS = PASSWORD, FS   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo SEC_DAEMON_AUTHENTICATION = REQUIRED   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo SEC_ADVERTISE_STARTD_AUTHENTICATION = REQUIRED   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo SEC_ADVERTISE_STARTD_INTEGRITY = REQUIRED   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo SEC_ADVERTISE_STARTD_AUTHENTICATION_METHODS =  PASSWORD, FS   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo SEC_CLIENT_AUTHENTICATION_METHODS = PASSWORD, FS   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo ALLOW_ADVERTISE_STARTD = \\*   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo ALLOW_ADVERTISE_MASTER = \\*   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "       echo ALLOW_ADVERTISE_SCHEDD = \\*   >> ${VC3_CONDOR_LOCAL_DIR}/condor_config.local",
                            "    fi",
                            "fi",
                            "if [ -f \"${CONDOR_CONFIG}\" ]; then",
                            "    ./condor_configure $(eval echo ${VC3_CONDOR_CONFIG_OPTIONS}) --overwrite",
                            "else",
                            "    ./condor_configure --install --local-dir=${VC3_CONDOR_LOCAL_DIR} $(eval echo ${VC3_CONDOR_CONFIG_OPTIONS}) --overwrite",
                            "fi",
                            ": condor_master -dyn -f -r 120"
                        ]
                    }
                ],
                "dependencies":{
                    "condor":[
                        "v8.6.0"
                    ],
                    "perl":[
                        "v5.10.0"
                    ]
                },
                "environment-variables":[
                    {
                        "name":"CONDOR_CONFIG",
                        "value":"${VC3_ROOT_CONDOR}/etc/condor_config",
                        "absolute":1,
                        "clobber":1
                    }
                ]
            }
        ]
    },

    "condor":{
        "versions":[
            {
                "version":"v8.6.9",
                "source":{
                    "type":"binary",
                    "native":"x86_64/redhat6",
                    "files":[
                        "condor-8.6.9-x86_64_RedHat6-stripped.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "mkdir -p ${VC3_PREFIX}/config",
                        "mkdir -p ${VC3_PREFIX}/log",
                        "mkdir -p ${VC3_PREFIX}/spool",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf condor-8.6.9-x86_64_RedHat6-stripped.tar.gz"
                    ]
                }
            },
            {
                "version":"v8.6.9",
                "source":{
                    "type":"binary",
                    "native":"x86_64/redhat7",
                    "files":[
                        "condor-8.6.9-x86_64_RedHat7-stripped.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/var/condor/log",
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/var/condor/spool",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf condor-8.6.9-x86_64_RedHat7-stripped.tar.gz",
                        "mkdir -p $(python -m site --user-site)",
                        "cp -r ${VC3_PREFIX}/lib/python $(python -m site --user-site)"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "LD_LIBRARY_PATH", "PATH"
        ],
        "environment-variables":[
            {
                "name":"PATH",
                "value":"sbin"
            }
        ]
    },

    "berkeley-db":{
        "versions":[
            {
                "version":"v6.2.23",
                "source":{
                    "type":"tarball",
                    "files":[
                        "db-6.2.23.tar.gz"
                    ],
                    "recipe":[
                        "cd build_unix",
                        "export CFLAGS=-fPIC",
                        "export CXXFLAGS=-fPIC",
                        "../dist/configure --prefix=${VC3_PREFIX} --enable-static --enable-shared --enable-compat185 --enable-dbm --enable-cxx",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "readline":{
        "versions":[
            {
                "version":"v6.3",
                "source":{
                    "type":"configure",
                    "files":[
                        "readline-6.3.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static --enable-shared",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "glib":{
        "versions":[
            {
                "version":"v2.18.1",
                "source":{
                    "type":"configure",
                    "files":[
                        "glib-2.48.1.tar.gz"
                    ],
                    "preface":[
                        ": system pcre is not working! using internal",
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static --enable-shared --with-python=${VC3_ROOT_PYTHON}/bin/python --with-pcre=internal"
                },
                "dependencies":{
                    "libffi":[
                        "v3.2.1"
                    ],
                    "gettext":[
                        "v0.19"
                    ],
                    "zlib":[
                        "v1.2"
                    ],
                    "pcre":[
                        "v8.13"
                    ],
                    "python":[
                        "v2.5"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "attr":{
        "versions":[
            {
                "version":"v2.4.47",
                "source":{
                    "type":"configure",
                    "files":[
                        "attr-2.4.47.src.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--enable-static=yes --enable-shared=yes --enable-gettext=no",
                    "postface":[
                        "make install-dev install-lib",
                        "chmod -v 755 ${VC3_PREFIX}/lib/libattr.so"
                    ]
                },
                "dependencies":{
                    "c-build-environment":[
                        "v1.0"
                    ]
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "libffi":{
        "versions":[
            {
                "version":"v3.2.1",
                "source":{
                    "type":"configure",
                    "files":[
                        "libffi-3.2.1.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static --enable-shared --enable-portable-binary",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-variables":[
                    {
                        "name":"LD_LIBRARY_PATH",
                        "value":"lib64"
                    },
                    {
                        "name":"LIBRARY_PATH",
                        "value":"lib64"
                    }
                ],
                "environment-autovars":[
                    "PKG_CONFIG_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "pcre":{
        "versions":[
            {
                "version":"v8.43",
                "source":{
                    "type":"configure",
                    "files":[
                        "pcre-8.43.tar.gz"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static --disable-shared --enable-unicode-properties --enable-pcre16 --enable-pcre32 ",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "fuse":{
        "versions":[
            {
                "version":"v2.9.3",
                "source":{
                    "type":"configure",
                    "files":[
                        "fuse-2.9.3.tar.gz"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib  --enable-lib --disable-util",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "perl":{
        "tags":["scripting languages", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"perl",
                    "auto-version":[
                        "perl -e  'print(\"VC3_VERSION_SYSTEM: $^V\\n\");'"
                    ],
                    "recipe":[
                        "perl -MConfig -e '$cmd = $Config{perlpath}; $cmd =~ s:(.*)\/bin/perl:\\1:; print \"VC3_ROOT_SYSTEM: $cmd\n\"'"
                    ]
                }
            },
            {
                "version":"v5.24",
                "source":{
                    "type":"tarball",
                    "files":[
                        "perl-5.24.0.tar.gz"
                    ],
                    "recipe":[
                        "CFLAGS='-m64 -mtune=nocona' ./Configure -Dprefix=${VC3_PREFIX} -Dcc=${CC} -des -A ccflags=-fPIC make",
                        "make install",
                        "mkdir -p ${VC3_PREFIX}/local_modules"
                    ]
                }
            }
        ],
        "dependencies":{
            "perl-vc3-modules":[
                "v0.5.0"
            ]
        },
        "environment-variables":[
            {
                "name":"PATH",
                "value":"bin"
            },
            {
                "name":"PERL5LIB",
                "value":"${VC3_MODULES_PERL}/lib/perl5",
                "absolute":1
            },
            {
                "name":"PERL5LIB",
                "value":"lib/perl5/site_perl/${VC3_VERSION_FULL_PERL}"
            },
            {
                "name":"PERL_MB_OPT", 
                "value":"--install_base ${VC3_MODULES_PERL}",
                "clobber":1,
                "absolute":1
            },
            {
                "name":"PERL_MM_OPT", 
                "value":"INSTALL_BASE=${VC3_MODULES_PERL}",
                "clobber":1,
                "absolute":1 
            },
            {
                "name":"PATH",
                "value":"${VC3_MODULES_PERL}/bin",
                "absolute":1
            }
        ]
    },

    "perl-vc3-modules":{
        "versions":[
            {
                "version":"v0.5.0",
                "source":{
                    "type":"generic",
                    "files":[
                        "perl-vc3-modules-005.tar"
                    ],
                    "recipe":[
                        ": cpanm --force -L none --save-dists /path/ --scandeps PACKAGE", 
                        ": orepan2-indexer /path/",
                        "local_cpan=${VC3_ROOT}/${VC3_MACHINE_TARGET}/perl_local_modules/local_cpan",
                        "mkdir -p ${local_cpan}",
                        "tar -C ${local_cpan} -xf perl-vc3-modules-005.tar"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"VC3_MODULES_PERL", 
                "value":"${VC3_ROOT}/${VC3_MACHINE_TARGET}/perl_local_modules",
                "clobber":1,
                "absolute":1
            },
            {
                "name":"VC3_MODULES_PERL_LOCAL_CPAN", 
                "value":"${VC3_MODULES_PERL}/local_cpan",
                "clobber":1,
                "absolute":1
            },
            {
                "name":"PATH",
                "value":"${VC3_MODULES_PERL}/bin",
                "absolute":1
            }
        ]
    },

    "perl-local-lib":{
        "versions":[
            {
                "version":"v2.19",
                "source":{
                    "type":"tarball",
                    "files":[
                        "local-lib-2.000019.tar.gz"
                    ],
                    "recipe":[
                        "perl Makefile.PL --bootstrap=${VC3_MODULES_PERL}",
                        "make install"
                    ]
                },
                "dependencies":{
                    "perl":[
                        "v5.10"
                    ]
                }
            }
        ]
    },

    "perl-cpanminus":{
        "tags":["perl packages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.7",
                "source":{
                    "type":"generic",
                    "files":[
                        "cpanminus-1.7.distribution"
                    ],
                    "recipe":[
                        "chmod 755 cpanminus-1.7.distribution",
                        "cp cpanminus-1.7.distribution ${VC3_MODULES_PERL}/bin/cpanm"
                    ]
                },
                "dependencies":{
                    "perl-local-lib":[
                        "v2.0"
                    ]
                }
            }
        ]
    },

    "python-pip":{
        "tags":["python packages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v9.0.1",
                "phony":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "pip-9.0.1.distribution"
                    ],
                    "recipe":[
                        "python pip-9.0.1.distribution --user --ignore-installed",
                        ": patch pip otherwise the lenght of the hash-bang is too long and fails. both after install and update",
                        "sed -i ~/.local/bin/pip -e '1s:.*:#! /usr/bin/env python:'",
                        "pip install --user -U pip",
                        "sed -i ~/.local/bin/pip -e '1s:.*:#! /usr/bin/env python:'",

                        "pip install --user -U wheel",
                        "pip install --user -U setuptools",
                        ": patch wheel otherwise the lenght of the hash-bang is too long and fails.",
                        "wheel=\"${VC3_INSTALL_USER_HOME}/.local/lib/python${VC3_VERSION_PYTHON}/site-packages/pip\"",
                        "if [ -d \"${wheel}/_internal\" ]; then",
                        "   wheel=\"$wheel/_internal/wheel.py\"",
                        "else",
                        "   wheel=\"$wheel/wheel.py\"",
                        "fi",
                        "sed -i \"$wheel\" -e \"/^def fix_script/,/return True/s:firstline =.*:firstline = '#! /usr/bin/env python':\""
                    ]
                },
                "dependencies":{
                    "python":[
                        "v2.6"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"PATH",
                "value":"${VC3_INSTALL_USER_HOME}/.local/bin",
                "absolute":1
            },
            {
                "name":"PYTHONUSERBASE",
                "value":"${VC3_INSTALL_USER_HOME}/.local",
                "absolute":1
            }
        ]
    },

    "python":{
        "tags":["scripting languages", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"python",
                    "prerequisites":[
                        ": check that dev files are available",
                        "version=$(python -c 'import sys; print \"%d.%d\" % (sys.version_info[0], sys.version_info[1])')",
                        "gcc -xc - <<EOF",
                        "#include <python${version}/Python.h>",
                        "int main() { return 0; }",
                        "EOF"
                    ],
                    "auto-version":[
                        "python -c 'import sys; print \"VC3_VERSION_SYSTEM: %d.%d.%d\" % (sys.version_info[0], sys.version_info[1], sys.version_info[2])'"
                    ],
                    "recipe":[
                        "cmd=$(which python)",
                        "base=$(echo $cmd | sed -r -n -e 's:(^.*/)bin/python$:\\1:p')",
                        "[ -n \"$base\" ] || exit 1",
                        "echo \"VC3_ROOT_SYSTEM: $base\""
                    ]
                }
            },
            {
                "version":"v2.7.12",
                "source":{
                    "type":"tarball",
                    "files":[
                        "Python-2.7.12.tgz"
                    ],
                    "recipe":[
                        "sed -i Modules/Setup.dist -e \"217s:.*:_ssl _ssl.c -DUSE_SSL -I${VC3_ROOT_OPENSSL}/include -I${VC3_ROOT_OPENSSL}/include/openssl -L${VC3_ROOT_OPENSSL}/lib -lssl -lcrypto:\"",
                        "sed -i Modules/Setup.dist -e \"468s:.*:zlib zlibmodule.c -I${VC3_ROOT_ZLIB}/include -L${VC3_ROOT_ZLIB}/lib -Wl,-Bstatic -lz -Wl,-Bdynamic:\"",
                        ": using shared library, and instead of using LD_LIBRARY_PATH, we set it with rpath",
                        "LDFLAGS='-Wl,-rpath=\\$$ORIGIN/../lib' ./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-shared --enable-unicode=ucs4",
                        "make",
                        "make install",
                        "ln -s ${VC3_PREFIX}/bin/pydoc{,2}"
                    ],
                    "dependencies":{
                        "zlib":[
                            "v1.2.8"
                        ],
                        "openssl":[
                            "v1.0"
                        ],
                        "libffi":[
                            "v3.2.1"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ],
        "environment-variables":[
            {
                "name":"C_INCLUDE_PATH",
                "value":"${VC3_ROOT_PYTHON}/include/python${VC3_VERSION_PYTHON}",
                "absolute":1
            }
        ]
    },

    "python3":{
        "tags":["scripting languages", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"python3",
                    "prerequisites":[
                        ": check that dev files are available",
                        "version=$(python3 -c 'import sys; print \"%d.%d\" % (sys.version_info[0], sys.version_info[1])')",
                        "gcc -xc - <<EOF",
                        "#include <python${version}/Python.h>",
                        "int main() { return 0; }",
                        "EOF"
                    ],
                    "auto-version":[
                        "python3 -c 'import sys; print(\"VC3_VERSION_SYSTEM: %d.%d.%d\" % (sys.version_info[0], sys.version_info[1], sys.version_info[2]))'"
                    ],
                    "recipe":[
                        "cmd=$(which python3)",
                        "base=$(echo $cmd | sed -E -n -e 's:(^.*/)bin/python3$:\\1:p')",
                        "[ -n \"$base\" ] || exit 1",
                        "echo \"VC3_ROOT_SYSTEM: $base\""
                    ]
                }
            },
            {
                "version":"v3.6.4",
                "source":{
                    "type":"tarball",
                    "files":[
                        "Python-3.6.4.tgz"
                    ],
                    "recipe":[
                        "sed -i Modules/Setup.dist -e \"217s:.*:_ssl _ssl.c -DUSE_SSL -I${VC3_ROOT_OPENSSL}/include -I${VC3_ROOT_OPENSSL}/include/openssl -L${VC3_ROOT_OPENSSL}/lib -lssl -lcrypto:\"",
                        "sed -i Modules/Setup.dist -e \"468s:.*:zlib zlibmodule.c -I${VC3_ROOT_ZLIB}/include -L${VC3_ROOT_ZLIB}/lib -Wl,-Bstatic -lz -Wl,-Bdynamic:\"",
                        ": using shared library, and instead of using LD_LIBRARY_PATH, we set it with rpath",
                        "LDFLAGS='-Wl,-rpath=\\$$ORIGIN/../lib' ./configure --prefix=${VC3_PREFIX} --libdir=${VC3_PREFIX}/lib --enable-shared --enable-unicode=ucs4",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "zlib":[
                            "v1.2.8"
                        ],
                        "openssl":[
                            "v1.0"
                        ],
                        "libffi":[
                            "v3.2.1"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ],
        "environment-variables":[
            {
                "name":"C_INCLUDE_PATH",
                "value":"${VC3_ROOT_PYTHON3}/include/python${VC3_VERSION_PYTHON3}",
                "absolute":1
            }
        ]
    },

    "python3-pip":{
        "tags":["python packages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v9.0.1",
                "phony":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "pip-9.0.1.distribution"
                    ],
                    "recipe":[
                        ": updating pip3 is broken for now",
                        "if pip3 --help; then exit 0; fi",
                        "python3 pip-9.0.1.distribution --user --ignore-installed",
                        ": patch pip otherwise the lenght of the hash-bang is too long and fails. both after install and update",
                        "sed -i ~/.local/bin/pip3 -e '1s:.*:#! /usr/bin/env python3:'",
                        "pip3 install --user -U pip",
                        "sed -i ~/.local/bin/pip3 -e '1s:.*:#! /usr/bin/env python3:'",
                        "pip3 install --user -U wheel",
                        "pip3 install --user -U setuptools",
                        ": patch pip and wheel, otherwise the lenght of the hash-bang is too long and fails.",
                        "sed -i ~/.local/lib/python${VC3_VERSION_PYTHON3}/site-packages/pip/_internal/wheel.py -e \"/^def fix_script/,/return True/s:firstline =.*:firstline = b'#! /usr/bin/env python3':\""
                    ]
                },
                "dependencies":{
                    "python3":[
                        "v3.0"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"PATH",
                "value":"${VC3_INSTALL_USER_HOME}/.local/bin",
                "absolute":1
            },
            {
                "name":"PYTHONUSERBASE",
                "value":"${VC3_INSTALL_USER_HOME}/.local",
                "absolute":1
            }
        ]
    },

    "zlib": {
        "versions":[
            {
                "version":"v1.2.8",
                "source":{
                    "type":"configure",
                    "files":[
                        "zlib-1.2.8.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --static",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "gsl": {
        "versions":[
            {
                "version":"v2.1",
                "source":{
                    "type":"configure",
                    "files":[
                        "gsl-2.1.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static --disable-shared",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "gettext": {
        "versions":[
            {
                "version":"v0.19.8",
                "source":{
                    "type":"configure",
                    "files":[
                        "gettext-0.19.8.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static --enable-shared",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "mash": {
        "tags":["bioinformatics tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.1",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "mash-Linux64-v1.1.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf mash-Linux64-v1.1.tar.gz"
                    ]
                },
                "environment-autovars":[
                    "PATH"
                ]
            }
        ]
    },


    "xrootd": {
        "tags":["data transfer tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v4.8.4",
                "source":{
                    "type":"cmake",
                    "files":[
                        "xrootd-4.8.4.tar.gz"
                    ],
                    "mirrors":[
                        "http://xrootd.org/download/v4.8.4/"
                    ]                    
                }
            },
            {
                "version":"v3.0.2",
                "source":{
                    "type":"tarball",
                    "files":[
                        "xrootd-3.0.2.tar.gz"
                    ],
                    "recipe":[
                        "sed -i -e'14s/.*/#include <fcntl.h>/' src/XrdOss/XrdOssAio.cc",
                        "sed -i -e'25s/.*/#define R__SSL_GE_098 yes/' src/XrdCrypto/XrdCryptosslAux.hh",
                        "./configure.classic --no-arch-subdirs --enable-posix --enable-pwd --enable-ssl --prefix=${VC3_PREFIX}",
                        "make",
                        "make install"
                    ]
                }
            }
        ],
        "dependencies":{
            "gcc-cplusplus":[
                "v4.4"
            ],
            "perl":[
                "v5.10"
            ],
            "zlib":[
                "v1.2"
            ],
            "fuse":[
                "v2.9"
            ]
        },
        "environment-variables":[
            {
                "name":"LD_LIBRARY_PATH",
                "value":"lib64"
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },

    "irods":{
        "tags":["file systems"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v3.0",
                "source":{
                    "type":"tarball",
                    "files":[
                        "irods3.0.tgz"
                    ],
                    "recipe":[
                        "mv * ${VC3_PREFIX}",
                        "cd ${VC3_PREFIX}",
                        "if [ \"$INSIDE_CONTAINER\" = yes ]; then",
                        "   sed -i -e '149d' scripts/perl/configure.pl",
                        "fi",
                        "if perl -e \"$VC3_VERSION_GCC >= 5 ? exit 0 : exit 1\"; then",
                        "export LDFLAGS=\"-pthread\"",
                        "fi",
                        "./scripts/configure",
                        "make"
                    ],
                    "dependencies":{
                        "help2man":[
                            "v1.0.0"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-variables":[
                    {
                        "name":"PATH",
                        "value":"clients/icommands/bin"
                    },
                    {
                        "name":"LD_LIBRARY_PATH",
                        "value":"lib/core/obj"
                    },
                    {
                        "name":"C_INCLUDE_PATH",
                        "value":"lib/api/include"
                    },
                    {
                        "name":"CPLUS_INCLUDE_PATH",
                        "value":"lib/api/include"
                    }
                ]
            }
        ]
    },

    "help2man":{
        "versions":[
            {
                "version":"v1.43.3",
                "source":{
                    "type":"configure",
                    "files":[
                        "help2man-1.43.3.tar.gz"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH"
                ]
            }
        ]
    },

    "perl-text-soundex":{
        "versions":[
            {
                "version":"v3.0",
                "source":{
                    "type":"cpan",
                    "files":[
                        "Text::Soundex"
                    ]
                }
            }
        ]
    },

    "perl-bioperl":{
        "tags":["bioinformatics tools", "perl packages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.6",
                "source":{
                    "type":"cpan",
                    "files":[
                        "CJFIELDS/BioPerl-1.6.924.tar.gz"
                    ]
                },
                "dependencies":{
                    "berkeley-db":[
                        "v6.0"
                    ],
                    "perl-DB_File":[
                        "v1.8"
                    ]

                }
            }
        ]
    },

    "perl-DB_File":{
        "versions":[
            {
                "version":"v1.8",
                "source":{
                    "type":"tarball",
                    "files":["DB_File-1.838.tar.gz"],
                    "recipe":[
                        "sed -i -e 's%^INCLUDE.*%INCLUDE = '${VC3_ROOT_BERKELEY_DB}'/include%;s%^LIB.*%LIB = '${VC3_ROOT_BERKELEY_DB}'/lib%' config.in",
                        "perl Makefile.PL --bootstrap=${VC3_MODULES_PERL}",
                        "make",
                        "make install"
                    ]
                },
                "dependencies":{
                    "perl":[
                        "v5.10"
                    ],
                    "berkeley-db":[
                        "v6.0"
                    ]
                }
            }
        ]
    },

    "perl-extutils-makemaker":{
        "versions":[
            {
                "version":"v7.24",
                "source":{
                    "type":"cpan",
                    "files":[
                        "ExtUtils::MakeMaker"
                    ]
                }
            }
        ]
    },

    "perl-dbi":{
        "versions":[
            {
                "version":"v1.6",
                "source":{
                    "type":"cpan",
                    "files":[
                        "DBI"
                    ]
                }
            }
        ]
    },

    "perl-file-which":{
        "versions":[
            {
                "version":"v1.2",
                "source":{
                    "type":"cpan",
                    "files":[
                        "File::Which"
                    ]
                }
            }
        ]
    },

    "perl-unsafe-signals":{
        "versions":[
            {
                "version":"v0.3",
                "source":{
                    "type":"cpan",
                    "files":[
                        "Perl::Unsafe::Signals"
                    ]
                }
            }
        ]
    },

    "perl-bit-vector":{
        "versions":[
            {
                "version":"v7.4",
                "source":{
                    "type":"cpan",
                    "files":[
                        "STBEY/Bit-Vector-7.4.tar.gz"
                    ]
                }
            }
        ]
    },

    "perl-inline":{
        "versions":[
            {
                "version":"v0.8",
                "source":{
                    "type":"cpan",
                    "files":[
                        "Inline"
                    ]
                }
            }
        ]
    },

    "perl-inline-c":{
        "versions":[
            {
                "version":"v0.76",
                "source":{
                    "type":"cpan",
                    "files":[
                        "Inline::C"
                    ]
                }
            }
        ]
    },

    "perl-forks":{
        "versions":[
            {
                "version":"v0.36",
                "source":{
                    "type":"cpan",
                    "files":[
                        "forks"
                    ]
                }
            }
        ]
    },

    "perl-io-all":{
        "versions":[
            {
                "version":"v0.86",
                "source":{
                    "type":"cpan",
                    "files":[
                        "IO::All"
                    ]
                }
            }
        ]
    },

    "perl-dbd-sqlite":{
        "versions":[
            {
                "version":"v1.5",
                "source":{
                    "type":"cpan",
                    "files":[
                        "DBD::SQLite"
                    ]
                }
            }
        ]
    },

    "perl-want":{
        "versions":[
            {
                "version":"v0.29",
                "source":{
                    "type":"cpan",
                    "files":[
                        "Want"
                    ]
                }
            }
        ]
    },

    "perl-lwp-simple":{
        "versions":[
            {
                "version":"v6.15",
                "source":{
                    "type":"cpan",
                    "files":[
                        "LWP::Simple"
                    ]
                }
            }
        ]
    },

    "hmmer":{
        "tags":["bioinformatics tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v3.1",
                "source":{
                    "type":"configure",
                    "files":[
                        "hmmer-3.1b2.tar.gz"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-mpi"
                },
                "dependencies":{
                    "openmpi":[
                        "v1.10"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "openmpi":{
        "tags":["compilation tools", "hpc"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.10",
                "source":{
                    "type":"configure",
                    "files":[
                        "openmpi-1.10.3.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-shared --disable-dependency-tracking --with-sge --disable-debug",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "ncbi-blast":{
        "tags":["bioinformatics tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2.2.28",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "ncbi-blast-2.2.28+-x64-linux.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf ncbi-blast-2.2.28+-x64-linux.tar.gz"
                    ]
                }
            },
            {
                "version":"v2.2.28",
                "source":{
                    "type":"configure",
                    "files":[
                        "ncbi-blast-2.2.28+-src.tar.gz"
                    ],
                    "preface":[
                        "cd c++",
                        "export CFLAGS=-fpermissive", 
                        "export CXXFLAGS=-fpermissive", 
                        ": patch ncbiconf so that blast compiles in RHEL6 with gcc4.4.7",
                        "sed -i -e '36s/^/#include <string.h>/' include/ncbiconf.h"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --with-mt --with-z=${VC3_ROOT_ZLIB} --with-pcre=${VC3_ROOT_PCRE} --with-python=${VC3_ROOT_PYTHON} --with-sqlite3=${VC3_ROOT_SQLITE3} --without-debug"
                },
                "dependencies":{
                    "zlib":[
                        "v1.2"
                    ],
                    "pcre":[
                        "v8.34"
                    ],
                    "python":[
                        "v2.6"
                    ],
                    "perl":[
                        "v5.8"
                    ],
                    "sqlite3":[
                        "v3.13"
                    ],
                    "gcc-cplusplus":[
                        "v4.4"
                    ],
                    "make":[
                        "v3.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },

    "ncbi-rmblastn":{
        "tags":["bioinformatics tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2.2.28",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "ncbi-rmblastn-2.2.28-x64-linux.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf ncbi-rmblastn-2.2.28-x64-linux.tar.gz",
                        "cd ${VC3_PREFIX}/bin",
                        "for file in ${VC3_ROOT_NCBI_BLAST}/bin/*; do ln -s ../../../${file#${VC3_ROOT}/${VC3_MACHINE_TARGET}/}; done"
                    ]
                }
            },
            {
                "version":"v2.2.28",
                "source":{
                    "type":"configure",
                    "files":[
                        "rmblastn-2.2.28+-src.tar.gz"
                    ],
                    "preface":[
                        "cd c++",
                        "export CFLAGS=-fpermissive", 
                        "export CXXFLAGS=-fpermissive", 
                        ": patch ncbiconf so that blast compiles in RHEL6 with gcc4.4.7",
                        "sed -i -e '36s/^/#include <string.h>/' include/ncbiconf.h"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --with-mt --with-z=${VC3_ROOT_ZLIB} --with-pcre=${VC3_ROOT_PCRE} --with-python=${VC3_ROOT_PYTHON} --with-sqlite3=${VC3_ROOT_SQLITE3} --without-debug"
                },
                "dependencies":{
                    "zlib":[
                        "v1.2"
                    ],
                    "pcre":[
                        "v8.34"
                    ],
                    "python":[
                        "v2.6"
                    ],
                    "perl":[
                        "v5.8"
                    ],
                    "ncbi-blast":[
                        "v2.2.28"
                    ],
                    "sqlite3":[
                        "v3.13"
                    ],
                    "gcc-cplusplus":[
                        "v4.4"
                    ],
                    "make":[
                        "v3.0"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
        ]
    },

    "sqlite3":{
        "tags":["databases"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v3.13",
                "source":{
                    "type":"configure",
                    "files":[
                        "sqlite-autoconf-3130000.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-static",
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "exonerate":{
        "tags":["bioinformatics tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2.2.0",
                "source":{
                    "type":"configure",
                    "files":[
                        "exonerate-2.2.0.tar.gz"
                    ],
                    "preface":[
                        ": exonerate does not like parallel compilation",
                        "export MAKEFLAGS=-j1",
                        ": for old glibc we need to manually link librt",
                        "export LDFLAGS=-lrt"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --enable-glib2 --enable-utilities",
                    "dependencies":{
                        "glib":[
                            "v2.0"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "snap":{
        "tags":["bioinformatics tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2013.11.29",
                "source":{
                    "type":"tarball",
                    "files":[
                        "snap-2013-11-29.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "cp -af ${VC3_BUILD} ${VC3_PREFIX}/snap",
                        "cd ${VC3_PREFIX}/snap",
                        "sed -i -e '678s/h2->q_end/h1->q_end/;684s/h2->s_end/h1->s_end/' Zoe/zoeAlignment.c",
                        "sed -i -e 's/-Wall//;s/-Werror//' Makefile",
                        "sed -i -e 's/-Wall//;s/-Werror//' Zoe/Makefile",
                        "make"
                    ]
                },
                "dependencies":{
                    "perl":[
                        "v5.8"
                    ]
                },
                "environment-variables":[
                    {
                        "name":"ZOE",
                        "value":"${VC3_ROOT_SNAP}/snap/Zoe",
                        "clobber":1,
                        "absolute":1
                    },
                    {
                        "name":"PATH",
                        "value":"${VC3_ROOT_SNAP}/snap",
                        "absolute":1
                    }
                ]
            }
        ]
    },

    "repeatmasker":{
        "versions":[
            {
                "version":"v4.0.6",
                "source":{
                    "type":"manual-distribution",
                    "msg-manual-requirement":[
                        "RepeatMasker library have a restrictive distribution license, and have to",
                        "be downloaded manually. Please follow these steps:",
                        "    1) On http://www.girinst.org, click on 'Downloads'.",
                        "    2) Register for a free account.",
                        "    3) Download the most recent library repeatmaskerlibrary-YEARMONTDAY.tar.gz.",
                        "    4) Copy the file into",
                        "${VC3_DISTFILES}/manual-distribution/repeatmaskerlibrary-LATEST.tar.gz.",
                        "    For example:",
                        "cp ~/Downloads/repeatmaskerlibrary-20150807.tar.gz ${VC3_DISTFILES}/manual-distribution/repeatmaskerlibrary-LATEST.tar.gz",
                        "    5) Try again '${VC3_COMMAND_LINE}'."],
                        "files":[
                            "repeatmaskerlibrary-LATEST.tar.gz"
                        ],
                        "recipe":[
                            "mkdir -p ${VC3_ROOT_REPEATMASKER_COMMON}",
                            "tar -C ${VC3_ROOT_REPEATMASKER_COMMON} -xpf repeatmaskerlibrary-LATEST.tar.gz",
                            "cd ${VC3_ROOT_REPEATMASKER_COMMON}",
                            "perl VC3_RepeatMasker-open-4-0-6.configure -re_exec_perl=${VC3_ROOT_PERL}/bin/perl -repeatmasker_dir=${VC3_ROOT_REPEATMASKER_COMMON} -trf_bin_path=${VC3_ROOT_TRF}/bin/trf -hmmer_bin_dir=${VC3_ROOT_HMMER}/bin -rmblast_bin_dir=${VC3_ROOT_NCBI_RMBLASTN}/bin -default_engine=rmblast"
                        ]
                },
                "dependencies":{
                    "repeatmasker-free":[
                        "v4.0.6"
                    ]
                }
            }
        ]
    },

    "repeatmasker-free":{
        "versions":[
            {
                "version":"v4.0.6",
                "source":{
                    "type":"generic",
                    "files":[
                        "RepeatMasker-open-4-0-6.tar.gz",
                        "VC3_RepeatMasker-open-4-0-6.configure"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_ROOT_REPEATMASKER_COMMON}",
                        "tar -C ${VC3_ROOT_REPEATMASKER_COMMON} --strip-components=1 -xpf RepeatMasker-open-4-0-6.tar.gz",
                        "cp VC3_RepeatMasker-open-4-0-6.configure ${VC3_ROOT_REPEATMASKER_COMMON}/"
                    ]
                },
                "dependencies": {
                    "repeatmasker-common":[
                        "v4.0.6"
                    ],
                    "perl":[
                        "v5.8"
                    ],
                    "hmmer":[
                        "v3.1"
                    ],
                    "ncbi-blast":[
                        "v2.2.28"
                    ],
                    "ncbi-rmblastn":[
                        "v2.2.28"
                    ],
                    "trf":[
                        "v4.0.9"
                    ],
                    "perl-text-soundex":[
                        "v3.0"
                    ]
                }
            }
        ]
    },

    "repeatmasker-common":{
        "versions":[
            {
                "version":"v4.0.6",
                "source": {
                    "type":"generic",
                    "recipe":[
                        "echo setting variables..."
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"PATH",
                "value":"${VC3_ROOT_REPEATMASKER_COMMON}",
                "absolute":1
            },
            {
                "name":"LD_LIBRARY_PATH",
                "value":"${VC3_ROOT_REPEATMASKER_COMMON}/lib",
                "absolute":1
            }
        ]
    },

    "augustus":{
        "tags":["bioinformatics tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2.4",
                "source":{
                    "type":"generic",
                    "files":[
                        "augustus.2.4.src.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf augustus.2.4.src.tar.gz",
                        "cd ${VC3_PREFIX}",
                        "make"
                    ]
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ],
                "environment-variables":[
                    {
                        "name":"AUGUSTUS_CONFIG_PATH",
                        "value":"config",
                        "clobber":1
                    }
                ]
            }
        ]
    },

    "trf":{
        "versions":[
            {
                "version":"v4.9",
                "source":{
                    "msg-manual-requirement":[
                        "Tandem Repeats Finder (trf) has a restrictive distribution license, and has to",
                        "be downloaded manually. Please follow these steps:",
                        "    1) On https://tandem.bu.edu/trf/trf.html, click on 'Download Your Own Copy of the Program'.",
                        "    2) Download the version appropiate for your machine.",
                        "      (Your machine is a ${VC3_MACHINE_OS}-${VC3_MACHINE_ARCH}, GLIBC version ${VC3_MACHINE_GLIBC_VERSION})",
                        "    3) Copy the file into",
                        "${VC3_DISTFILES}/manual-distribution/trf409",
                        "    For example:",
                        "cp ~/Downloads/trf409.legacylinux64 ${VC3_DISTFILES}/manual-distribution/trf409",
                        "    4) Try again '${VC3_COMMAND_LINE}'."],
                        "type":"manual-distribution",
                        "files":[
                            "trf409"
                        ],
                        "recipe":[
                            "mkdir -p ${VC3_PREFIX}/bin",
                            ": -L to ensure real files are copied, and not only symlinks",
                            "cp -L trf409 ${VC3_PREFIX}/bin/trf",
                            "chmod 755 ${VC3_PREFIX}/bin/trf"
                        ]
                },
                "environment-autovars":[
                    "PATH"
                ]
            }
        ]
    },

    "maker":{
        "versions":[
            {
                "version":"v2.31",
                "source":{
                    "type":"manual-distribution",
                    "msg-manual-requirement":[
                        "maker has a restrictive distribution license, and has to",
                        "be downloaded manually. Please follow these steps:",
                        "    1) On http://www.yandell-lab.org/software/maker.html, click on 'Registration Page'.",
                        "    2) Fill the form and click on 'Submit and Download MAKER.",
                        "    3) Download maker-2.31.8.tgz.",
                        "    4) Copy the file into",
                        "${VC3_DISTFILES}/manual-distribution/maker-2.31.8.tgz",
                        "    For example:",
                        "cp ~/Downloads/maker-2.31.8.tgz ${VC3_DISTFILES}/manual-distribution/",
                        "    5) Try again '${VC3_COMMAND_LINE}'."],
                        "files":[
                            "maker-2.31.8.tgz"
                        ],
                        "recipe":[
                            "mkdir -p ${VC3_PREFIX}",
                            "tar -C ${VC3_PREFIX} --strip-components=1 -xpf maker-2.31.8.tgz",
                            "cd ${VC3_PREFIX}/src",
                            ": y to activate MPI support",
                            "/bin/echo -e 'y\n\n' | perl Build.PL",
                            "./Build install",
                            "cd ${VC3_PREFIX}/bin",
                            "echo '#! /bin/sh' > maker_mpi",
                            "echo 'if [ -n \"$LD_PRELOAD\" ]; then' >> maker_mpi",
                            "echo ' LD_PRELOAD=${VC3_ROOT_OPENMPI}/lib/libmpi.so:${LD_PRELOAD} mpiexec $* maker' >> maker_mpi", 
                            "echo else >> maker_mpi",
                            "echo ' LD_PRELOAD=${VC3_ROOT_OPENMPI}/lib/libmpi.so mpiexec $* maker' >> maker_mpi", 
                            "echo fi >> maker_mpi",
                            "chmod 755 maker_mpi"
                        ]
                },
                "dependencies":{
                    "ncbi-blast":[
                        "v2.2.28"
                    ],
                    "snap":[
                        "v2013.11.29"
                    ],
                    "repeatmasker":[
                        "v4.0.6"
                    ],
                    "exonerate":[
                        "v2.2"
                    ],
                    "augustus":[
                        "v2.4"
                    ],
                    "openmpi":[
                        "v1.10"
                    ],
                    "perl-bioperl":[
                        "v1.6"
                    ],
                    "perl-dbi":[
                        "v1.6"
                    ],
                    "perl-dbd-sqlite":[
                        "v1.5"
                    ],
                    "perl-want":[
                        "v0.29"
                    ],
                    "perl-lwp-simple":[
                        "v6.15"
                    ],
                    "perl-file-which":[
                        "v1.2"
                    ],
                    "perl-unsafe-signals":[
                        "v0.3"
                    ],
                    "perl-bit-vector":[
                        "v7.4"
                    ],
                    "perl-inline":[
                        "v0.8"
                    ],
                    "perl-inline-c":[
                        "v0.76"
                    ],
                    "perl-forks":[
                        "v0.36"
                    ],
                    "perl-io-all":[
                        "v0.86"
                    ]
                },
                "environment-variables":[
                    {
                        "name":"PATH",
                        "value":"${VC3_ROOT_MAKER}/bin",
                        "absolute":1
                    }
                ]
            }
        ]
    },

    "findutils":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"find"
                }
            },
            {
                "version":"4.4.2",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "findutils-x86_64-4.4.2-1.tar.gz"
                    ]
                }
            },
            {
                "version":"v4.6.0",
                "source":{
                    "type":"configure",
                    "files":[
                        "findutils-4.6.0.tar.gz"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH"
                ]
            }
        ]
    },

    "maker-example-ecoli-01":{
        "versions":[
            {
                "version":"v1",
                "source":{
                    "type":"generic",
                    "files":[
                        "maker-example-ecoli-01.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/maker-example-ecoli-01",
                        "tar -C ${VC3_INSTALL_USER_HOME}/maker-example-ecoli-01 --strip-components=1 -xpf maker-example-ecoli-01.tar.gz"
                    ]
                },
                "dependencies":{
                    "maker":[
                        "v2.31"
                    ]
                }
            }
        ]
    },

    "namd":{
        "versions":[
            {
                "version":"v2.12.0",
                "source":{
                    "type":"manual-distribution",
                    "msg-manual-requirement":[
                        "NAMD has a restrictive distribution license, and has to",
                        "be downloaded manually. Please follow these steps:",
                        "    1) On http://www.ks.uiuc.edu/Research, click on 'Sofware/NAMD/Download'.",
                        "    3) Click 'Source code' on the most recent stable release.",
                        "    2) Register for a free account.",
                        "    3) Download the most recent stable release.",
                        "    4) Copy the file into",
                        "${VC3_DISTFILES}/manual-distribution/NAMD_Source.tar.gz.",
                        "    For example:",
                        "cp ~/Downloads/NAMD_2.12_Source.tar.gz ${VC3_DISTFILES}/manual-distribution/NAMD_Source.tar.gz",
                        "    5) Try again '${VC3_COMMAND_LINE}'."],
                        "files":[
                            "NAMD_Source.tar.gz"
                        ],
                        "recipe":[
                            "tar -C ${VC3_PREFIX} --strip-components=1 -xpf NAMD_Source.tar.gz",
                            "cd ${VC3_PREFIX}",
                            "./config Linux-x86_64-g++ --charm-arch mpi-linux-x86_64 --charm-base ${VC3_ROOT_CHARM} --tcl-prefix ${VC3_ROOT_TCL} --fftw-prefix ${VC3_ROOT_FFTW} --python-prefix ${VC3_ROOT_PYTHON}",
                            "cd Linux-x86_64-g++",
                            "make"
                        ]
                },
                "dependencies":{
                    "openmpi":[
                        "v1.10"
                    ],
                    "charm":[
                        "v6.7.1"
                    ],
                    "fftw":[
                        "v3.3.6"
                    ],
                    "tcl":[
                        "v8.5.9"
                    ],
                    "python":[
                        "v2.6.0"
                    ]
                },
                "environment-variables":
                [
                    {
                        "name":"PATH",
                        "value":"${VC3_ROOT_NAMD}/Linux-x86_64-g++",
                        "absolute":1
                    }
                ]
            }
        ]
    },

    "charm":{
        "tags":["compilation tools", "hpc"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v6.7.1",
                "source":{
                    "type":"generic",
                    "files":[
                        "charm-6.7.1.tar.gz"
                    ],
                    "recipe":[
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf charm-6.7.1.tar.gz",
                        "cd ${VC3_PREFIX}",
                        "env MPICXX=mpicxx ./build charm++ mpi-linux-x86_64 --with-production"
                    ]
                },
                "dependencies":{
                    "openmpi":[
                        "v1.10"
                    ]
                },
                "environment-variables":[
                    {
                        "name":"CHARM_BASE",
                        "value":"$VC3_ROOT_CHARM/mpi-linux-x86_64",
                        "absolute":1,
                        "clobber":1
                    },
                    {
                        "name":"PATH",
                        "value":"${VC3_ROOT_CHARM}/mpi-linux-x86_64/bin",
                        "absolute":1
                    },
                    {
                        "name":"LD_LIBRARY_PATH",
                        "value":"${VC3_ROOT_CHARM}/mpi-linux-x86_64/lib",
                        "absolute":1
                    },
                    {
                        "name":"CPLUS_INCLUDE_PATH",
                        "value":"${VC3_ROOT_CHARM}/mpi-linux-x86_64/include",
                        "absolute":1
                    }
                ]
            }
        ]
    },

    "tcl":{
        "tags":["scripting languages", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v8.5.9",
                "source":{
                    "type":"configure",
                    "files":[
                        "tcl8.5.9-src.tar.gz"
                    ],
                    "preface":[
                        "cd unix"
                    ],
                    "options":"--enable-threads --enable-64bit",
                    "postface":[
                        "ln -s tclsh8.5 ${VC3_PREFIX}/bin/tclsh"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "fftw":{
        "versions":[
            {
                "version":"v3.3.6",
                "source":{
                    "type":"configure",
                    "files":[
                        "fftw-3.3.6-pl2.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC"
                    ],
                    "options":"--enable-openmp --enable-mpi --enable-shared --enable-float",
                    "dependencies":{
                        "openmpi":[
                            "v1.10"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "octave":{
        "tags":["scripting languages", "programming languages"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v4.2.1",
                "source":{
                    "type":"configure",
                    "files":[
                        "octave-4.2.1.tar.gz"
                    ],
                    "options":"--prefix ${VC3_PREFIX} --disable-java --with-qhull-includedir=${VC3_ROOT_QHULL}/include --with-qhull-libdir=${VC3_ROOT_QHULL}/lib --with-z-includedir=${VC3_ROOT_ZLIB}/include --with-z-libdir=${VC3_ROOT_ZLIB}/lib  --with-hdf5-includedir=${VC3_ROOT_HDF5}/include --with-hdf5-libdir=${VC3_ROOT_HDF5}/lib --with-fftw3-includedir=${VC3_ROOT_FFTW}/include --with-fftw3-libdir=${VC3_ROOT_FFTW}/lib --with-fftw3f-includedir=${VC3_ROOT_FFTW}/include --with-fftw3f-libdir=${VC3_ROOT_FFTW}/lib --with-glpk-includedir=${VC3_ROOT_GLPK}/include --with-glpk-libdir=${VC3_ROOT_GLPK}/lib --with-curl-includedir=${VC3_ROOT_CURL}/include --with-curl-libdir=${VC3_ROOT_CURL}/lib --without-x --without-opengl --without-qt --without-fltk --with-blas=${VC3_ROOT_LAPACK}/lib64/libblas.so --with-lapack=${VC3_ROOT_LAPACK}/lib64/liblapack.so --with-qrupdate-includedir=${VC3_ROOT_QRUPDATE}/include --with-qrupdate-libdir=${VC3_ROOT_QRUPDATE}/lib --with-arpack-includedir=${VC3_ROOT_ARPACK}/includedir --with-arpack-libdir=${VC3_ROOT_ARPACK}/lib --with-openssl --disable-readline"
                },
                "dependencies":{
                    "qhull":[
                        "v7.2"
                    ],
                    "zlib":[
                        "v1.2"
                    ],
                    "hdf5":[
                        "v1.8"
                    ],
                    "fftw":[
                        "v3.3"
                    ],
                    "glpk":[
                        "v4.61"
                    ],
                    "curl":[
                        "v7.53"
                    ],
                    "lapack":[
                        "v3.7"
                    ],
                    "qrupdate":[
                        "v1.2"
                    ],
                    "arpack":[
                        "v3.4"
                    ],
                    "pcre":[
                        "v8.39"
                    ],
                    "c-build-environment":[
                        "v1.0"
                    ]
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "qrupdate":{
        "tags":["numerical methods tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.2.2",
                "source":{
                    "type":"tarball",
                    "files":[
                        "qrupdate-1.1.2.tar.gz"
                    ],
                    "recipe":[
                        "sed -i Makeconf -e 's:^BLAS=-lblas.*:BLAS=-L${VC3_ROOT_LAPACK}/lib -lblas:'",
                        "sed -i Makeconf -e 's:^LAPACK=-llapack.*:LAPACK=-L${VC3_ROOT_LAPACK}/lib64 -llapack:'",
                        "export CFLAGS=-fPIC",
                        "export FCFLAGS=-fPIC",
                        "make lib",
                        "make PREFIX=${VC3_PREFIX} install"
                    ]
                },
                "dependencies":{
                    "lapack":[
                        "v3.7"
                    ]
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "hdf5":{
        "tags":["data management tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.8.18",
                "source":{
                    "type":"cmake",
                    "files":[
                        "hdf5-1.8.18.tar.gz"
                    ],
                    "options":"-DCMAKE_C_FLAGS=-fPIC -DCMAKE_Fortran_FLAGS=-fPIC",
                    "dependencies":{
                        "openmpi":[
                            "v1.10"
                        ]
                    }
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "qhull":{
        "tags":["numerical methods tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v7.2.0",
                "source":{
                    "type":"cmake",
                    "files":[
                        "qhull-2015-src-7.2.0.tgz"
                    ],
                    "options":"-DCMAKE_Fortran_FLAGS=-fPIC -DCMAKE_C_FLAGS=-fPIC"
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "glpk":{
        "versions":[
            {
                "version":"v4.61.0",
                "source":{
                    "type":"configure",
                    "files":[
                        "glpk-4.61.tar.gz"
                    ],
                    "preface":[
                        "export CFLAGS=-fPIC",
                        "export FCFLAGS=-fPIC",
                        "./configure --prefix ${VC3_PREFIX} --with-pic",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "arpack":{
        "tags":["numerical methods libraries"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v3.4.0",
                "source":{
                    "type":"tarball",
                    "files":[
                        "arpack-ng-3.4.0.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p build",
                        "cd build",
                        "cmake -DMPI=ON -DBLAS_LIBRARIES=${VC3_ROOT_LAPACK} -DLAPACK_LIBRARIES=${VC3_ROOT_LAPACK} -DCMAKE_Fortran_FLAGS=-fPIC -DCMAKE_C_FLAGS=-fPIC ..",
                        "make",
                        "mkdir -p ${VC3_PREFIX}/lib",
                        "cp *.a ${VC3_PREFIX}/lib"
                    ],
                    "dependencies":{
                        "cmake":[
                            "v3.0"
                        ],
                        "openmpi":[
                            "v1.10"
                        ],
                        "lapack":[
                            "v3.7.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "lapack":{
        "tags":["numerical methods libraries"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v3.7.0",
                "source":{
                    "type":"tarball",
                    "files":[
                        "lapack-3.7.0.tgz"
                    ],
                    "recipe":[
                        "mkdir build-static",
                        "cd build-static",
                        "cmake -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} -DCMAKE_BUILD_TYPE=RELEASE ..",
                        "export FCFLAGS=-fPIC",
                        "make",
                        "make install",
                        "cd ..",
                        "mkdir build-shared",
                        "cd build-shared",
                        "cmake -DCMAKE_INSTALL_PREFIX:PATH=${VC3_PREFIX} -DCMAKE_BUILD_TYPE=RELEASE -DBUILD_SHARED_LIBS=ON ..",
                        "export FCFLAGS=-fPIC",
                        "make",
                        "make install",
                        "mkdir -p ${VC3_PREFIX}/include",
                        "cp ../LAPACKE/include/* ${VC3_PREFIX}/include"
                    ],
                    "dependencies":{
                        "cmake":[
                            "3.0.0"
                        ]
                    }
                },
                "environment-variables":[
                    {
                        "name":"LD_LIBRARY_PATH",
                        "value":"lib64"
                    },
                    {
                        "name":"PKG_CONFIG_PATH",
                        "value":"lib64/pkgconfig"
                    },
                    {
                        "name":"C_INCLUDE_PATH",
                        "value":"include"
                    }
                ]
            }
        ]
    },

    "openblas":{
        "tags":["numerical methods libraries"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v0.2.19",
                "source":{
                    "type":"tarball",
                    "files":[
                        "openblas-0.2.19.tar.gz"
                    ],
                    "recipe":[
                        "export CFLAGS=-fPIC",
                        "export FCFLAGS=-fPIC",
                        "make",
                        "make PREFIX=${VC3_PREFIX} install"
                    ]
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ]
    },

    "musl":{
        "tags":["compilation tools", "programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.1.23",
                "source":{
                    "type":"tarball",
                    "files":[
                        "musl-1.1.23.tar.gz"
                    ],
                    "recipe":[
                        ": patch to fix segfaults of static binaries with binutils 2.31 ",
                        "sed -i tools/musl-gcc.specs.sh   -e '/^-dynamic-linker/s:^:--build-id :'",
                        "./configure --prefix=${VC3_PREFIX} --disable-shared x86_64",
                        "make",
                        "make install"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                },
                "environment-autovars":[
                    "PATH"
                ]
            }
        ]
    },

    "musl-zlib": {
        "versions":[
            {
                "version":"v1.2.8",
                "source":{
                    "type":"configure",
                    "files":[
                        "zlib-1.2.8.tar.gz"
                    ],
                    "preface":[
                        "export CC=musl-gcc CFLAGS=-fPIC"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib --static"
                },
                "environment-autovars":[
                    "PATH", "LD_LIBRARY_PATH", "PKG_CONFIG_PATH", "LIBRARY_PATH", "C_INCLUDE_PATH", "CPLUS_INCLUDE_PATH"
                ]
            }
        ],
        "dependencies":{
            "musl":[
                "v1.0"
            ]
        },
        "environment-variables":[
            {
                "name":"CC",
                "value":"musl-gcc",
                "absolute":1,
                "clobber":1
            }
        ]
    },

    "cctools-statics":{
        "versions":[
            {
                "version":"v7.0.11",
                "source":{
                    "type":"tarball",
                    "mirrors":[
                        "http://ccl.cse.nd.edu/software/files/"
                    ],
                    "files":[
                        "cctools-7.0.11-source.tar.gz"
                    ],
                    "recipe":[
                        ": first work queue and makeflow",
                        "CFLAGS=-D__MUSL__ CC=musl-gcc ./configure --prefix ${VC3_PREFIX} --without-system-{doc,apps,chirp} --with-readline-path=no --static --with-zlib-path=${VC3_ROOT_MUSL_ZLIB}",
                        "(cd dttools/src          && make && make install)",
                        "(cd work_queue/src       && make && make install)",
                        "(cd batch_job/src        && make && make install)",
                        "(cd makeflow/src         && make && make install)",
                        "(cd resource_monitor/src && make resource_monitor && cp resource_monitor ${VC3_PREFIX}/bin)"
                    ],
                    "dependencies":{
                        "openssl":[
                            "v1.0"
                        ],
                        "c-build-environment":[
                            "v1.0"
                        ],
                        "musl-zlib":[
                            "v1.2.0"
                        ],
                        "musl":[
                            "v1.0"
                        ]
                    }
                }
            },
            {
                "version":"v7.0.6",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "cctools-statics-7.0.6.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}",
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf cctools-statics-*.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "cctools-wq-worker":{
        "versions":[
            {
                "version":"v999.999.999",
                "phony":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "CCTOOLS_ND=${CCTOOLS_ND:-stable}",
                        "AFS=/afs/crc.nd.edu/group/ccl/software",
                        "CCLPLATFORM=$(${AFS}/cclplatform.sh)",
                        "CCLSOFTWARE=\"${AFS}/$CCLPLATFORM\"",
                        "mkdir -p $VC3_PREFIX/bin",
                        "cp \"${CCLSOFTWARE}/cctools/${CCTOOLS_ND}/bin/work_queue_worker\" $VC3_PREFIX/bin"
                    ]
                },
                "environment-autovars":[
                    "PATH"
                ]
            }
        ]
    },

    "vim":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"vim"
                }
            },
            {
                "version":"v7.3.0",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "vim-x86_64-7.3-1.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "singularity":{
        "tags":["containers"],
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"singularity"
                }
            },
            {
                "version":"2.5",
                "comment":"For Bridges",
                "prologue":[
                    "eval $(modulecmd sh load singularity)"
                ],
                "source":{
                    "type":"generic",
                    "auto-version":[
                        "eval $(modulecmd sh load singularity)",
                        "echo VC3_VERSION_SYSTEM: $(singularity --version | sed -r -e 's/(([0-9]+\\.){2}[0-9]+).*/\\1/')"
                    ],
                    "prerequisites":[
                        "which modulecmd"
                    ]
                }
            },
            {
                "version":"2.5",
                "comment":"For TACC-Stampede",
                "prologue":[
                    "eval $(/opt/apps/lmod/lmod/libexec/lmod sh load tacc-singularity)"
                ],
                "source":{
                    "type":"generic",
                    "auto-version":[
                        "eval $(/opt/apps/lmod/lmod/libexec/lmod sh load tacc-singularity)",
                        "echo VC3_VERSION_SYSTEM: $(singularity --version | sed -r -e 's/(([0-9]+\\.){2}[0-9]+).*/\\1/')"
                    ],
                    "prerequisites":[
                        "which /opt/apps/lmod/lmod/libexec/lmod"
                    ]
                }
            }
        ]
    },

    "docker":{
        "tags":["containers"],
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"docker"
                }
            }
        ]
    },

    "container-technology":{
        "tags":["containers"],
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"shifter"
                }
            },
            {
                "version":"2.5",
                "comment":"For NERSC",
                "source":{
                    "type":"system",
                    "executable":"shifter"
                }
            },
            {
                "version":"2.5",
                "comment":"For Blue-Waters",
                "prologue":[
                    "eval $(/opt/modules/default/bin/modulecmd bash load shifter)"
                ],
                "source":{
                    "type":"generic",
                    "auto-version":[
                        "eval $(/opt/modules/default/bin/modulecmd bash load shifter)",
                        "echo VC3_VERSION_SYSTEM: $(which shifter | sed -r -e 's/(([0-9]+\\.){2}[0-9]+).*/\\1/')"
                    ],
                    "prerequisites":[
                        "which /opt/modules/default/bin/modulecmd"
                    ]
                }
            },
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"singularity"
                }
            },
            {
                "version":"2.5",
                "comment":"Temporarily for Notre Dame",
                "source":{
                    "type":"generic",
                    "auto-version":[
                        "echo VC3_VERSION_SYSTEM: $(singularity --version | sed -r -e 's/(([0-9]+\\.){2}[0-9]+).*/\\1/')"
                    ],
                    "prerequisites":[
                        "command -v singularity",
                        "PATH=$PATH:/usr/sbin SINGULARITY_CACHEDIR=$PWD singularity exec docker://alpine pwd"
                    ]
                },
                "environment-variables":[
                    {
                        "name":"PATH",
                        "value":"/usr/sbin",
                        "absolute":1
                    }
                ]
            },
            {
                "version":"2.5",
                "comment":"For Bridges",
                "prologue":[
                    "eval $(modulecmd sh load singularity)"
                ],
                "source":{
                    "type":"generic",
                    "auto-version":[
                        "eval $(modulecmd sh load singularity)",
                        "echo VC3_VERSION_SYSTEM: $(singularity --version | sed -r -e 's/(([0-9]+\\.){2}[0-9]+).*/\\1/')"
                    ],
                    "prerequisites":[
                        "which modulecmd"
                    ]
                }
            },
            {
                "version":"2.5",
                "comment":"For TACC-Stampede",
                "prologue":[
                    "eval $(/opt/apps/lmod/lmod/libexec/lmod sh load tacc-singularity)"
                ],
                "source":{
                    "type":"generic",
                    "auto-version":[
                        "eval $(/opt/apps/lmod/lmod/libexec/lmod sh load tacc-singularity)",
                        "echo VC3_VERSION_SYSTEM: $(singularity --version | sed -r -e 's/(([0-9]+\\.){2}[0-9]+).*/\\1/')"
                    ],
                    "prerequisites":[
                        "which /opt/apps/lmod/lmod/libexec/lmod"
                    ]
                }
            }
        ]
    },

    "spack":{
        "tags":["software building"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v0.11",
                "phony":1,
                "prologue":[
                    ". ${SPACK_ROOT}/share/spack/setup-env.sh"
                ],
                "source":{
                    "type":"generic",
                    "phony":1,
                    "recipe":[
                        ". ${SPACK_ROOT}/share/spack/setup-env.sh",
                        "spack load || spack bootstrap"
                    ]
                }
            }
        ],
        "dependencies":{
            "spack-noconf":[
                "v0.11"
            ]
        }
    },

    "spack-noconf":{
        "tags":["software building"],
        "show-in-list":0,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"spack"
                }
            },
            {
                "version":"0.11.2",
                "source":{
                    "type":"generic",
                    "files":[
                        "spack-0.11.2.tar.gz"
                    ],
                    "mirrors":[
                        "https://github.com/spack/spack/releases/download/v0.11.2/"
                    ],
                    "recipe":[
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xf spack-0.11.2.tar.gz"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"SPACK_ROOT",
                "value":"${VC3_ROOT_SPACK_NOCONF}",
                "absolute":1,
                "clobber":1
            }
        ]
    },

    "bc":{
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"bc"
                }
            },
            {
                "version":"v1.0.6",
                "source":{
                    "type":"binary",
                    "native":"x86_64",
                    "files":[
                        "bc-x86_64-1.06-1.tar.gz"
                    ],
                    "dependencies":{
                        "c-build-environment":[
                            "v1.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "libfreetype": {
        "versions":[
            {
                "version":"v2.3.11",
                "source":{
                    "type":"configure",
                    "files":[
                        "freetype-2.3.11.src.tar.gz"
                    ],
                    "options":"--libdir=${VC3_PREFIX}/lib64"
                }
            }
        ],
        "environment-variables":[
            {
                "name":"LD_LIBRARY_PATH",
                "value":"lib64"
            }
        ]
    },

    "libaio": {
        "versions":[
            {
                "version":"v0.3.107",
                "source":{
                    "type":"tarball",
                    "files":[
                        "libaio_0.3.107.src.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/lib64",
                        "make prefix=${VC3_PREFIX} libdir=${VC3_PREFIX}/lib64 install"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"LD_LIBRARY_PATH",
                "value":"lib64"
            }
        ]
    },

    "libmysql":{
        "tags":["software building"],
        "show-in-list":0,
        "versions":[
            {
                "version":"5.6.48",
                "source":{
                    "type":"cmake",
                    "files":[
                        "mysql-5.6.48.tar.gz"
                    ],
                    "options":"-DCMAKE_INSTALL_PREFIX=${VC3_PREFIX} -DCMAKE_BUILD_TYPE=Release -DWITH_READLINE=OFF"
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ]
    },

    "gridftp":{
        "tags":["software building"],
        "show-in-list":0,
        "versions":[
            {
                "version":"5.0.3",
                "source":{
                    "type":"tarball",
                    "files":[
                        "gt5.0.3-all-source-installer.tar.gz"
                    ],
                    "recipe":[
                        "./configure --prefix=${VC3_PREFIX} --with-flavor=gcc64 --with-gsiopensshargs='--enable-static-only'",
                        "make -j1 gridftp",
                        "make -j1 install"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ]
    },

    "environment-modules":{
        "tags":["software building"],
        "show-in-list":0,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "executable":"modulecmd",
                    "postface":[
                        "/bin/echo  -e '#!/bin/sh\neval $(${VC3_ROOT_ENVIRONMENT_MODULES}/bin/modulecmd sh \"$@\")\n' > ${VC3_PREFIX}/bin/module",
                        "chmod 755 ${VC3_PREFIX}/bin/module"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "c-build-environment":{
        "tags":["software building"],
        "show-in-list":0,
        "versions":[
            {
                "version":"1.0",
                "type":"generic",
                "phony":1,
                "dependencies":{
                    "gcc":[
                        "v4.4"
                    ],
                    "make":[
                        "v3.0"
                    ]
                }
            }
        ]
    }
}

,
{
    "java-jre":{
        "tags":["programming languages"],
        "versions":[
            {
                "version":"v1.8.0_181",
                "source":{
                    "type":"tarball",
                    "files":[
                        "jre-8u181-linux-x64.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/{bin,lib}",
                        "cp -r bin/* ${VC3_PREFIX}/bin/",
                        "cp -r lib/* ${VC3_PREFIX}/lib/"
                    ] 
                }
            }
        ],
        "environment-variables":[
            {
                "name":"JAVA_HOME",
                "value":"${VC3_ROOT_JAVA_JRE}",
                "clobber":1,
                "absolute":1
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ]
    },

    "java-jdk":{
        "tags":["programming languages"],
        "versions":[
            {
                "version":"v1.8.0_181",
                "source":{
                    "type":"tarball",
                    "files":[
                        "jdk-8u181-linux-x64.tar.gz"
                    ],
                    "recipe":[
                        "[ -d ${VC3_ROOT_JAVA_JRE} ] || exit 1",
                        "cp -r bin/* ${VC3_ROOT_JAVA_JRE}/bin/",
                        "cp -r lib/* ${VC3_ROOT_JAVA_JRE}/lib/"
                    ] 
                }
            }
        ],
        "dependencies":{
            "java-jre":[
                "v1.8"
            ]
        },
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ]
    },

    "scala":{
        "tags":["programming languages"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2.11.12",
                "dependencies":{
                    "java-jre":[
                        "v1.8.0"
                    ]
                },
                "source":{
                    "type":"tarball",
                    "files":[
                        "scala-2.11.12.tgz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/{bin,lib}",
                        "cp -r bin/* ${VC3_PREFIX}/bin/",
                        "cp -r lib/* ${VC3_PREFIX}/lib/"
                    ] 
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "maven":{
        "tags":["packager"],
        "show-in-list": 1,
        "versions":[
            {
                "version":"v3.6.0",
                "dependencies":{
                    "java-jdk":[
                        "v1.8"
                    ]
                },
                "source":{
                    "type":"generic",
                    "files":[
                        "apache-maven-3.6.0-bin.tar.gz"
                    ],
                    "recipe":[
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xf apache-maven-3.6.0-bin.tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    }
}
,
{
    "spark":{
        "tags":["job execution engines"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2.4.0",
                "source":{ 
                    "type":"tarball",
                    "files":[
                        "spark-2.4.0-bin-vc3-custom-spark.tgz",
                        "aws-jars-1.11.234.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/{bin,jars,sbin}",
                        "cp -r bin/* ${VC3_PREFIX}/bin/",
                        "cp -r jars/* ${VC3_PREFIX}/jars",
                        "cp -r sbin/* ${VC3_PREFIX}/sbin",
                        "tar -C ${VC3_PREFIX}/jars --strip-components=1 -xf aws-jars-*.tar.gz"
                    ]
                },
                "dependencies":{
                    "scala":[
                        "v2.11.12"
                    ],
                    "hadoop":[
                        "v3.1"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"PATH",
                "value":"sbin"
            },
            {
                "name":"SPARK_HOME",
                "value":"${VC3_ROOT_SPARK}",
                "clobber":1,
                "absolute":1
            },
            {
                "name":"SPARK_DIST_CLASSPATH",
                "value":"${JAVA_HOME}",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"SPARK_DIST_CLASSPATH",
                "value":"$(${VC3_ROOT_HADOOP}/bin/hadoop classpath)",
                "absolute":1
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },
    
    "spark-xrootd":{
        "tags":["xrootd plugin for spark"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.0.0",
                "dependencies":{
                    "pyspark":[
                        "v2.4.0"
                    ],
                    "xrootd":[
                        "v4.8.4"
                    ]
                },
                "source":{
                    "type":"tarball",
                    "files":[
                        "spark-xrootd-plugins-v1.0.0.tar.gz"
                    ],
                    "recipe":[
                        "cp EOSfs.jar ${VC3_ROOT_SPARK}/jars",
                        "mkdir -p ${VC3_PREFIX}/lib",
                        "chmod 755 libjXrdCl.so",
                        "cp libjXrdCl.so ${VC3_PREFIX}/lib"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ]
    },
    
    "pyspark":{
        "tags":["python packages"],
        "show-in-list": 1,
        "versions":[
            {
                "version":"v2.4.0",
                "dependencies":{
                    "spark":[
                        "v2.4.0"
                    ],
                    "python":[
                        "v2.7"
                    ],
                    "python-pip":[
                        "v9"
                    ]
                },
                "source":{
                    "type":"generic",
                    "recipe":[
                       "pip install --user pyspark==2.4.0 matplotlib==2.1.0 histogrammar",
                       "ln -s $VC3_INSTALL_USER_HOME/.local/lib/python2.7/site-packages/pyspark/python $VC3_ROOT_SPARK"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"PYTHONPATH",
                "value":"${VC3_INSTALL_USER_HOME}/.local/lib/python2.7/site-packages",
                "clobber":1,
                "absolute":1
            }
         ]
    },

    "minio":{
        "tags":["file systems"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2018.11.8",
                "source":{
                    "type":"generic",
                    "files":[
                        "minio"
                    ],
                    "mirrors":[
                        "https://dl.minio.io/server/minio/release/linux-amd64"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "chmod 755 minio",
                        "cp minio ${VC3_PREFIX}/bin"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ],
        "dependencies":{
            "minio-client":[
                "v2.4.0"
            ]
        }
    },

    "minio-client":{
        "tags":["file system tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2018.11.8",
                "source":{
                    "type":"generic",
                    "files":[
                        "mc"
                    ],
                    "mirrors":[
                        "https://dl.minio.io/client/mc/release/linux-amd64"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "chmod 755 mc",
                        "cp mc ${VC3_PREFIX}/bin"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "hadoop":{
        "tags":["filesystems"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v3.1.1",
                "dependencies":{
                    "java-jre":[
                        "v1.8.0"
                    ]
                },
                "source":{
                    "type":"generic",
                    "files":[
                        "hadoop-3.1.1.tar.gz"
                    ],
                    "recipe":[
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf hadoop-*tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ],
        "environment-variables":[
            {
                "name":"HADOOP_HOME",
                "value":"${VC3_ROOT_HADOOP}",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"HADOOP_CONF_DIR",
                "value":"${VC3_ROOT_HADOOP}/etc/hadoop",
                "absolute":1,
                "clobber":1
            }
        ]
    }
}
,
{
    "spark":{
        "tags":["job execution engines"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v2.4.3",
                "source":{ 
                    "type":"tarball",
                    "files":[
                        "spark-2.4.3-bin-custom-spark.tgz",
                        "aws-jars-1.11.234.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/{bin,jars,sbin}",
                        "cp -r bin/* ${VC3_PREFIX}/bin/",
                        "cp -r jars/* ${VC3_PREFIX}/jars",
                        "cp -r sbin/* ${VC3_PREFIX}/sbin",
                        "tar -C ${VC3_PREFIX}/jars --strip-components=1 -xf aws-jars-*.tar.gz"
                    ]
                },
                "dependencies":{
                    "scala":[
                        "v2.11.12"
                    ],
                    "hadoop":[
                        "v3.1"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"PATH",
                "value":"sbin"
            },
            {
                "name":"SPARK_HOME",
                "value":"${VC3_ROOT_SPARK}",
                "clobber":1,
                "absolute":1
            },
            {
                "name":"SPARK_DIST_CLASSPATH",
                "value":"${JAVA_HOME}",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"SPARK_DIST_CLASSPATH",
                "value":"$(${VC3_ROOT_HADOOP}/bin/hadoop classpath)",
                "absolute":1
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },
    
    "spark-xrootd":{
        "tags":["xrootd plugin for spark"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v1.0.0",
                "dependencies":{
                    "pyspark":[
                        "v2.4.3"
                    ],
                    "xrootd":[
                        "v4.8.4"
                    ]
                },
                "source":{
                    "type":"tarball",
                    "files":[
                        "spark-xrootd-plugins-v1.0.0.tar.gz"
                    ],
                    "recipe":[
                        "cp EOSfs.jar ${VC3_ROOT_SPARK}/jars",
                        "mkdir -p ${VC3_PREFIX}/lib",
                        "chmod 755 libjXrdCl.so",
                        "cp libjXrdCl.so ${VC3_PREFIX}/lib"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ]
    },
    
    "pyspark":{
        "tags":["python packages"],
        "show-in-list": 1,
        "versions":[
            {
                "version":"v2.4.3",
                "dependencies":{
                    "spark":[
                        "v2.4.3"
                    ],
                    "python":[
                        "v2.7"
                    ],
                    "python-pip":[
                        "v9"
                    ]
                },
                "source":{
                    "type":"generic",
                    "recipe":[
                       "pip install --user pyspark==2.4.3 matplotlib==2.1.0 histogrammar",
                       "ln -s $VC3_INSTALL_USER_HOME/.local/lib/python2.7/site-packages/pyspark/python $VC3_ROOT_SPARK"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"PYTHONPATH",
                "value":"${VC3_INSTALL_USER_HOME}/.local/lib/python2.7/site-packages",
                "clobber":1,
                "absolute":1
            }
         ]
    },

    "minio":{
        "tags":["file systems"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2018.11.8",
                "source":{
                    "type":"generic",
                    "files":[
                        "minio"
                    ],
                    "mirrors":[
                        "https://dl.minio.io/server/minio/release/linux-amd64"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "chmod 755 minio",
                        "cp minio ${VC3_PREFIX}/bin"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ],
        "dependencies":{
            "minio-client":[
                "v2.4.0"
            ]
        }
    },

    "minio-client":{
        "tags":["file system tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v2018.11.8",
                "source":{
                    "type":"generic",
                    "files":[
                        "mc"
                    ],
                    "mirrors":[
                        "https://dl.minio.io/client/mc/release/linux-amd64"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "chmod 755 mc",
                        "cp mc ${VC3_PREFIX}/bin"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    },

    "hadoop":{
        "tags":["filesystems"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v3.1.1",
                "dependencies":{
                    "java-jre":[
                        "v1.8.0"
                    ]
                },
                "source":{
                    "type":"generic",
                    "files":[
                        "hadoop-3.1.1.tar.gz"
                    ],
                    "recipe":[
                        "tar -C ${VC3_PREFIX} --strip-components=1 -xpf hadoop-*tar.gz"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH", "LD_LIBRARY_PATH"
        ],
        "environment-variables":[
            {
                "name":"HADOOP_HOME",
                "value":"${VC3_ROOT_HADOOP}",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"HADOOP_CONF_DIR",
                "value":"${VC3_ROOT_HADOOP}/etc/hadoop",
                "absolute":1,
                "clobber":1
            }
        ]
    }
}
,
{
  "tutorial": {
    "show-in-list":1,
    "versions": [
      {
        "version": "v0.0.1",
        "source": {
          "type": "binary",
          "native": "x86_64",
          "files":[ "tutorial-0.1.tar.gz" ]
        }
      }
    ],
    "environment-variables":[
      {
        "name":"PATH",
        "value":"bin"
      }
    ]
  },
  "connect-client": {
    "show-in-list":1,
    "versions": [
      {
        "version": "v1.0.1",
        "source": {
          "type": "binary",
          "native": "x86_64",
          "files": [ "connect_client-1.0.1.linux-x86_64.tar.gz" ]
        },
        "dependencies":{
          "python":[
            "v2.6"
          ]
        }        
      }
    ],
    "environment-variables":[
      {
        "name":"PYTHONPATH",
        "value":"${VC3_ROOT_CONNECT_CLIENT}/lib/python2.6/site-packages",
        "absolute":1
      }
    ],
    "environment-autovars":[
      "PATH"
    ]
  },
  "modules": {
    "show-in-list":1,
    "versions": [
      {
        "version": "v1.0",
        "prologue": [
            "source /cvmfs/oasis.opensciencegrid.org/osg/modules/lmod/current/init/sh"
        ],
        "source": {
          "type": "generic",
          "dependencies":{
              "cvmfs":[
                  "v2.0"
              ],
              "tcl": [
                "v8.5.0"
              ]
          }
        }
      }

    ]
  },
  "osgconnect": {
    "show-in-list":1,
    "versions": [
      {
        "version": "v0.0.1",
        "source": {
          "type": "generic",
          "prologue": [
              "source /cvmfs/oasis.opensciencegrid.org/osg/modules/lmod/current/init/sh"
          ],
          "dependencies":{
              "modules":[
                  "v1.0"
              ],
              "tutorial": [
                "v0.0.1"
              ],
              "connect-client": [
                "v1.0.1"
              ]
          }
        }
      }
    ]
  }
}
,
{
    "redhat":{
        "tags":["operating systems"],
        "show-in-list":1,
        "type":"operating-system",
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"os-native",
                    "native":"x86_64/redhat"
                }
            },
            {
                "version":"7.4",
                "source":{
                    "type":"singularity",
                    "image":"Singularity.vc3.x86_64-centos7.img"
                }
            },
            {
                "version":"7.4",
                "source":{
                    "type":"docker",
                    "drop-priviliges":1,
                    "image":"docker://virtualclusters/os:centos7"
                }
            },
            {
                "version":"6.9",
                "source":{
                    "type":"singularity",
                    "image":"Singularity.vc3.x86_64-centos6.img"
                }
            },
            {
                "version":"6.9",
                "source":{
                    "type":"docker",
                    "drop-priviliges":1,
                    "image":"docker://virtualclusters/os:centos6"
                }
            }
        ]
    },

    "centos":{
        "tags":["operating systems"],
        "show-in-list":1,
        "type":"operating-system",
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"os-native",
                    "native":"x86_64/redhat"
                }
            },
            {
                "version":"7.4",
                "source":{
                    "type":"singularity",
                    "image":"Singularity.vc3.x86_64-centos7.img"
                }
            },
            {
                "version":"7.4",
                "source":{
                    "type":"docker",
                    "drop-priviliges":1,
                    "image":"docker://virtualclusters/os:centos7"
                }
            },
            {
                "version":"6.9",
                "source":{
                    "type":"singularity",
                    "image":"Singularity.vc3.x86_64-centos6.img"
                }
            },
            {
                "version":"6.9",
                "source":{
                    "type":"docker",
                    "drop-priviliges":1,
                    "image":"docker://virtualclusters/os:centos6"
                }
            }
        ]
    },

    "ubuntu":{
        "tags":["operating systems"],
        "show-in-list":1,
        "type":"operating-system",
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"os-native",
                    "native":"x86_64/ubuntu"
                }
            },
            {
                "version":"16",
                "source":{
                    "type":"singularity",
                    "image":"Singularity.vc3.x86_64-ubuntu16.04.img"
                }
            },
            {
                "version":"16.04",
                "source":{
                    "type":"docker",
                    "drop-priviliges":1,
                    "image":"docker://virtualclusters/os:ubuntu16.04"
                }
            }
        ]
    },

    "debian":{
        "tags":["operating systems"],
        "show-in-list":1,
        "type":"operating-system",
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"os-native",
                    "native":"x86_64/debian"
                }
            },
            {
                "version":"9.2",
                "source":{
                    "type":"singularity",
                    "image":"Singularity.vc3.x86_64-debian9.2.img"
                }
            },
            {
                "version":"9.2",
                "source":{
                    "type":"docker",
                    "drop-priviliges":1,
                    "image":"docker://virtualclusters/os:debian9.2"
                }
            }
        ]
    },

    "opensuse":{
        "tags":["operating systems"],
        "show-in-list":1,
        "type":"operating-system",
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"os-native",
                    "native":"x86_64/opensuse"
                }
            },
            {
                "version":"42.3",
                "source":{
                    "type":"singularity",
                    "image":"Singularity.vc3.x86_64-opensuse42.3.img"
                }
            },
            {
                "version":"42.3",
                "source":{
                    "type":"docker",
                    "drop-priviliges":1,
                    "image":"docker://virtualclusters/os:opensuse42.3"
                }
            }
        ]
    }
}

,
{
    "parrot-static-binary":{
        "tags":["file systems"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v7.0.11",
                "source":{
                    "type":"tarball",
                    "files":[
                        "parrot-static-v7.0.11.tar.gz"
                    ],
                    "recipe":[
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "mv parrot_static_run ${VC3_PREFIX}/bin"
                    ]
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ],
        "environment-variables":[
            {
                "name":"PARROT_HTTP_PROXY",
                "value":":;DIRECT",
                "clobber":1,
                "absolute":1
            }
        ]
    },

    "parrot-static-wrapper":{
        "tags":["file systems"],
        "show-in-list":0,
        "versions":[
            {
                "version":"v7.0.11",
                "wrapper":[
                    "parrot_static_run",
                    "--dynamic-mounts",
                    "-p", "\"${PARROT_HTTP_PROXY}\"",
                    "--cvmfs-repo-switching",
                    "$(echo ${VC3_PARROT_EXTRA_OPTIONS} | sed -e 's/:/ /g')",
                    "{}"
                ],
                "dependencies":{
                    "parrot-static-binary":[
                        "v6.2.6"
                    ]
                }
            }
        ]
    }
}
,
{
    "parsl":{
        "tags":["python packages", "parallel scripting"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"generic",
                    "auto-version":[
            "python3 -c 'import parsl.version; print(\"VC3_VERSION_SYSTEM: {}\".format(parsl.version.VERSION))'"
                    ]
                }
            },
            {
                "version":"v0.6.1",
                "source":{
                    "type":"generic",
                    "recipe":[
                        "pip3 install --user -U parsl==0.6.1"
                    ]
                },
                "dependencies":{
                    "python3":[
                        "v3.6"
                    ],
                    "python3-pip":[
                        "v9.0"
                    ]
                }
            }
        ]
    }
}
,
{
    "autopyfactory":{
        "versions":[
            {
                "version":"v0.0.1",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/git && cd ${VC3_INSTALL_USER_HOME}/git",
                        "[ -d autopyfactory ] || git clone https://github.com/PanDAWMS/autopyfactory.git",
                        "cd autopyfactory",
                        "rm -rf build",
                        "python setup.py install --user",
                        "mkdir -p ${VC3_SERVICES_HOME}/etc",
                        "cp -r etc ${VC3_SERVICES_HOME}/etc/autopyfactory"
                    ]
                },
                "dependencies":{
                    "vc3-infoservice":[
                        "v0.0.1"
                    ],
                    "condor":[
                        "v8.6"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"APF_HOME",
                "value":"${VC3_SERVICES_HOME}",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"PATH",
                "value":"${APF_HOME}/bin",
                "absolute":1
            }
        ]
    },

    "vc3-factory-plugins":{
        "versions":[
            {
                "version":"v0.0.1",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/git && cd ${VC3_INSTALL_USER_HOME}/git",
                        "[ -d vc3-factory-plugins ] || git clone https://github.com/vc3-project/vc3-factory-plugins.git",
                        "cd vc3-factory-plugins",
                        "find . autopyfactory/plugins -name '*.py' | pax -r -w ${VC3_SERVICES_HOME}/lib/python${VC3_VERSION_PYTHON}/",
                        "cp -r etc/*.conf ${VC3_SERVICES_HOME}/etc"
                    ]
                },
                "dependencies":{
                    "autopyfactory":[
                        "v0.0.1"
                    ],
                    "pax":[
                        "v2016.0.0"
                    ]
                }
            }
        ]
    },

    "vc3-factory":{
        "versions":[
            {
                "version":"v0.0.1",
                "phony":1,
                "dependencies":{
                    "vc3-factory-plugins":[
                        "v0.0.1"
                    ],
                    "condor-personal":[
                        "v8.6.0"
                    ]
                }
            }
        ]
    },

    "vc3-services-common-requirements":{
        "versions":[
            {
                "version":"v0.0.1",
                "phony":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "home=$(python -m site --user-base)",
                        "mkdir -p ${home}/lib/python",
                        "mkdir -p ${home}/bin",
                        "mkdir -p ${home}/etc",
                        "mkdir -p ${home}/var/log/vc3",
                        "pip install --user requests==2.7.0 cherrypy==3.2.2 pyYAML"
                    ]
                },
                "dependencies":{
                    "python":[
                        "v2.7.12"
                    ],
                    "python-pip":[
                        "v1.8"
                    ],
                    "git":[
                        "v2.12.0"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"VC3_SERVICES_HOME",
                "value":"$(python -m site --user-base)",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"PATH",
                "value":"${VC3_SERVICES_HOME}/bin",
                "absolute":1
            }
        ]
    },

    "vc3-pluginmanager":{
        "versions":[
            {
                "version":"v0.1",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/git && cd $VC3_INSTALL_USER_HOME/git",
                        "[ -d sdcc-pluginmanager ] || git clone https://github.com/bnl-sdcc/sdcc-pluginmanager.git",
                        "cd ${VC3_INSTALL_USER_HOME}/git/sdcc-pluginmanager",
                        "rm -rf build",
                        "python setup.py install --user"
                    ]
                },
                "dependencies":{
                    "vc3-services-common-requirements":[
                        "v0.0.1"
                    ]
                }
            }
        ]
    },

    "vc3-credible":{
        "versions":[
            {
                "version":"v0.1",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/git && cd ${VC3_INSTALL_USER_HOME}/git",
                        "[ -d credible ] || git clone https://github.com/vc3-project/credible.git",
                        "cd ${VC3_INSTALL_USER_HOME}/git/credible",
                        "rm -rf build",
                        "python setup.py install --user",
                        "credroot=${VC3_SERVICES_HOME}/var/credible/ssca/defaultca/intermediate",
                        "cp etc/credible.conf{,.sample} etc/openssl.cnf.*.template ${VC3_SERVICES_HOME}/etc",
                        "missing=0",
                        "[ -f $credroot/certs/localhost.cert.pem ]      || missing=1",
                        "[ -f $credroot/certs/ca-chain.cert.pem ]       || missing=1",
                        "[ -f $credroot/certs/VC3Admin.cert.pem ]       || missing=1",
                        "[ -f $credroot/private/localhost.keynopw.pem ] || missing=1",
                        "[ -f $credroot/private/VC3Admin.keynopw.pem ]  || missing=1",
                        "if [ \"$missing\" = 1 ]; then",
                        "   mkdir -p ${credroot}/private",
                        "   ${VC3_SERVICES_HOME}/bin/credible -c ${VC3_SERVICES_HOME}/etc/credible.conf -d hostcert localhost > /dev/null",
                        "   ${VC3_SERVICES_HOME}/bin/credible -c ${VC3_SERVICES_HOME}/etc/credible.conf certchain",

                        "   ${VC3_SERVICES_HOME}/bin/credible -c ${VC3_SERVICES_HOME}/etc/credible.conf -d usercert VC3Admin > /dev/null",
                        "fi"
                    ]
                },
                "dependencies":{
                    "vc3-services-common-requirements":[
                        "v0.0.1"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"VC3_SERVICES_CERTS_HOME",
                "value":"${VC3_SERVICES_HOME}/etc/ssca/certs",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"VC3_SERVICES_CERTS_CHAINFILE",
                "value":"${VC3_SERVICES_CERTS_HOME}/ca-chain.cert.pem",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"VC3_SERVICES_CERTS_CERTFILE",
                "value":"${VC3_SERVICES_CERTS_HOME}/VC3Admin.cert.pem",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"VC3_SERVICES_CERTS_KEYFILE",
                "value":"${VC3_SERVICES_CERTS_HOME}/private/VC3Admin.keynopw.pem",
                "absolute":1,
                "clobber":1
            }
        ]
    },

    "vc3-services":{
        "versions":[
            {
                "version":"v0.1",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "recipe":[
                        "mkdir -p ${VC3_INSTALL_USER_HOME}/git && cd ${VC3_INSTALL_USER_HOME}/git",
                        "for S in vc3-infoservice vc3-client vc3-master; do",
                        "    [ -d $S ] || git clone https://github.com/vc3-project/${S}.git",
                        "    cd $S",
                        "    rm -rf build",
                        "    python setup.py install --user",
                        "    cp etc/*.conf ${VC3_SERVICES_HOME}/etc",
                        "    cd ..",
                        "done"
                    ]
                },
                "dependencies":{
                    "vc3-pluginmanager":[
                        "v0.0.1"
                    ],
                    "vc3-credible":[
                        "v0.0.1"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"VC3_SERVICES_INFOSERVICE_INFOHOST",
                "value":"localhost",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"VC3_SERVICES_INFOSERVICE_HTTP_PORT",
                "value":"20333",
                "absolute":1,
                "clobber":1
            },
            {
                "name":"VC3_SERVICES_INFOSERVICE_HTTPS_PORT",
                "value":"20334",
                "absolute":1,
                "clobber":1
            }
        ]
    },

    "vc3-builder":{
        "tags":["environment tools"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v0.1",
                "phony":1,
                "local":1,
                "source":{
                    "type":"generic",
                    "files":[
                        "vc3-builder"
                    ],
                    "mirrors":[
                        "https://raw.githubusercontent.com/vc3-project/vc3-builder/master"
                    ],
                    "recipe":[
                        "chmod 755 vc3-builder",
                        "mkdir -p ${VC3_PREFIX}/bin",
                        "cp vc3-builder ${VC3_PREFIX}/bin"
                    ],
                    "dependencies":{
                        "wget":[
                            "v1.0.0"
                        ]
                    }
                }
            }
        ],
        "environment-autovars":[
            "PATH"
        ]
    }
}

,
{
    "cvmfs-vc3ndcms":{
        "tags":["file systems"],
        "show-in-list":1,
        "versions":[
            {
                "version":"auto",
                "source":{
                    "type":"system",
                    "auto-version":[
                        "echo VC3_VERSION_SYSTEM: $(cvmfs2 -V | sed -r -e 's/CernVM-FS version\\s+([0-9]+\\.[0-9]+\\.[0-9]+)(\\.[0-9])?/\\1/')" 
                    ],
                    "prerequisites":[
                        "stat /cvmfs/cms.cern.ch"
                    ],
                    "recipe":[
                        "echo \"VC3_ROOT_SYSTEM: /\""
                    ]
                },
                "environment-variables":[
                    {
                        "name":"VC3_PARROT_EXTRA_OPTIONS",
                        "value":"--disable-service=cvmfs",
                        "absolute":1
                    }
                ]
            },
            {
                "version":"v2.4.0",
                "dependencies":{
                    "parrot-wrapper-vc3ndcms":[
                        "v2.4.0"
                    ]
                }
            }
        ]
    },

    "parrot-wrapper-vc3ndcms":{
        "tags":["file systems"],
        "versions":[
            {
                "version":"v2.4.0",
                "dependencies":{
                    "parrot-wrapper":[
                        "v6.2.10"
                    ]
                }
            }
        ],
        "environment-variables":[
            {
                "name":"VC3_PARROT_EXTRA_OPTIONS",
                "value":"--no-flock",
                "absolute":1
            },
            {
                "name":"VC3_PARROT_EXTRA_OPTIONS",
                "value":"-M /cvmfs/cms.cern.ch/SITECONF/local=/cvmfs/cms.cern.ch/SITECONF/T3_US_VC3_NotreDame",
                "absolute":1
            }
        ]
    },

    "oasis-wn-vc3ndcms":{
        "tags":["environments"],
        "show-in-list":1,
        "versions":[
            {
                "version":"v3.3",
                "native": "x86_64/redhat6",
                "prologue": [
                    "source /cvmfs/oasis.opensciencegrid.org/mis/osg-wn-client/3.3/current/el6-x86_64/setup.sh"
                ],
                "dependencies":{
                    "cvmfs-vc3ndcms":[
                        "v2.4.0"
                    ]
                }
            },
            {
                "version":"v3.3",
                "native": "x86_64/redhat7",
                "prologue": [
                    "source /cvmfs/oasis.opensciencegrid.org/mis/osg-wn-client/3.3/current/el7-x86_64/setup.sh"
                ],
                "dependencies":{
                    "cvmfs-vc3ndcms":[
                        "v2.4.0"
                    ]
                }
            }
        ],
        "dependencies":{
            "bc":[
                "v1.0.6"
            ],
            "libfreetype":[
                "v2.3.11"
            ],
            "libaio":[
                "v0.3.107"
            ]
        }
    }
}
,
{
    "redhat-distribution":{
        "type":"operating-system-distribution",
        "versions":[
            {
                "version":"v1.0.0",
                "source":{
                    "prerequisites":[
                        "[ -f /etc/redhat-release ] || exit 1"
                    ],
                    "recipe":[
                        "INPUT=/etc/redhat-release",
                        "version=$(cat ${INPUT} | sed -n -r -e 's/.*release ([0-9]+(\\.[0-9]+){0,2}).*/\\1/p')",
                        "[ -n \"${version}\" ] || exit 1",
                        "echo VC3_MACHINE_DISTRIBUTION: redhat ${version}"
                    ]
                }
            }
        ]
    },

    "os-file-distribution":{
        "type":"operating-system-distribution",
        "versions":[
            {
                "version":"v1.0.0",
                "source":{
                    "prerequisites":[
                        "[ -f /etc/os-release ] || exit 1"
                    ],
                    "recipe":[
                        "INPUT=/etc/os-release",
                        "distro=$(cat ${INPUT} | sed -n -r '/^ID=/{s/^ID=\"?(.*)\"?/\\1/p;q}')",
                        "version=$(cat ${INPUT} | sed -n -r '/^VERSION_ID=/{s/^VERSION_ID=\"?([0-9]+(\\.[0-9]+){0,2}).*\"?/\\1/p;q}')",
                        "[ -n \"${distro}\" ]  || exit 1",
                        "[ -n \"${version}\" ] || exit 1",
                        "echo VC3_MACHINE_DISTRIBUTION: ${distro} ${version}"
                    ]
                }
            }
        ]
    },

    "debian-distribution":{
        "type":"operating-system-distribution",
        "versions":[
            {
                "version":"v1.0.0",
                "source":{
                    "prerequisites":[
                        "[ -f /etc/debian_version ] || exit 1"
                    ],
                    "recipe":[
                        "INPUT=/etc/debian_version",
                        "version=$(cat ${INPUT} | sed -n -r -e 's/([0-9]+(\\.[0-9]+){0,2}).*/\\1/p')",
                        "[ -n \"${version}\" ] || exit 1",
                        "echo VC3_MACHINE_DISTRIBUTION: debian ${version}"
                    ]
                }
            }
        ]
    },

    "lsb-exe-distribution":{
        "type":"operating-system-distribution",
        "versions":[
            {
                "version":"v1.0.0",
                "source":{
                    "prerequisites":[
                        "which lsb_release"
                    ],
                    "recipe":[
                        "distro=$(lsb_release -is | tr '[A-Z]' '[a-z]')",
                        "version=$(lsb_release -rs | sed -n -r -e 's/([0-9]+(\\.[0-9]+){0,2}).*/\\1/p')",
                        "[ -n \"${distro}\"  ] || exit 1",
                        "[ -n \"${version}\" ] || exit 1",
                        "echo VC3_MACHINE_DISTRIBUTION: ${distro} ${version}"
                    ]
                }
            }
        ]
    },

    "lsb-file-distribution":{
        "type":"operating-system-distribution",
        "versions":[
            {
                "version":"v1.0.0",
                "source":{
                    "prerequisites":[
                        "[ -f /etc/lsb-release ] || exit 1"
                    ],
                    "recipe":[
                        "INPUT=/etc/lsb-release",
                        "[ -f ${INPUT} ] || exit 1",
                        "distro=$(cat ${INPUT} | sed -n -r '/^DISTRIB_ID=/{s/^DISTRIB_ID=\"?(.*)\"?/\\1/p;q}' | tr '[A-Z]' '[a-z]')",
                        "version=$(cat ${INPUT} | sed -n -r '/^DISTRIB_RELEASE=/{s/^DISTRIB_RELEASE=\"?([0-9]+(\\.[0-9]+){0,2}).*\"?/\\1/p;q}')",
                        "[ -n \"${distro}\" ] || exit 1",
                        "[ -n \"${version}\" ] || exit 1",
                        "echo VC3_MACHINE_DISTRIBUTION: ${distro} ${version}"
                    ]
                }
            }
        ]
    }
}

]
